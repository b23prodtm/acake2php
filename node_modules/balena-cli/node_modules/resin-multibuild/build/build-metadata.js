"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildMetadata = exports.QEMU_BIN_NAME = void 0;
const Either_1 = require("fp-ts/lib/Either");
const io_ts_reporters_1 = require("io-ts-reporters");
const jsYaml = require("js-yaml");
const _ = require("lodash");
const Path = require("path");
const TarUtils = require("tar-utils");
const build_secrets_1 = require("./build-secrets");
const errors_1 = require("./errors");
const PathUtils = require("./path-utils");
const registry_secrets_1 = require("./registry-secrets");
exports.QEMU_BIN_NAME = 'qemu-execve';
var MetadataFileType;
(function (MetadataFileType) {
    MetadataFileType[MetadataFileType["Json"] = 0] = "Json";
    MetadataFileType[MetadataFileType["Yaml"] = 1] = "Yaml";
})(MetadataFileType || (MetadataFileType = {}));
class BuildMetadata {
    constructor(metadataDirectories) {
        this.metadataDirectories = metadataDirectories;
        this.metadataFiles = {};
    }
    extractMetadata(tarStream) {
        return __awaiter(this, void 0, void 0, function* () {
            let foundMetadataDirectory = null;
            const onEntry = (pack, header, stream) => __awaiter(this, void 0, void 0, function* () {
                const buffer = yield TarUtils.streamToBuffer(stream);
                const entryInformation = this.getMetadataRelativePath(header.name);
                if (entryInformation == null ||
                    entryInformation.relativePath === exports.QEMU_BIN_NAME) {
                    pack.entry(header, buffer);
                }
                else {
                    if (foundMetadataDirectory != null &&
                        foundMetadataDirectory !== entryInformation.metadataDirectory) {
                        throw new errors_1.MultipleMetadataDirectoryError();
                    }
                    foundMetadataDirectory = entryInformation.metadataDirectory;
                    this.addMetadataFile(entryInformation.relativePath, buffer);
                }
            });
            return (yield TarUtils.cloneTarStream(tarStream, {
                onEntry,
            }));
        });
    }
    getBalenaYml() {
        return _.cloneDeep(this.balenaYml);
    }
    getSecretFile(source) {
        return this.metadataFiles[Path.posix.join('secrets', source)];
    }
    parseMetadata() {
        const potentials = [
            { name: 'balena.yml', type: MetadataFileType.Yaml },
            { name: 'balena.yaml', type: MetadataFileType.Yaml },
            { name: 'balena.json', type: MetadataFileType.Json },
            { name: 'resin.yml', type: MetadataFileType.Yaml },
            { name: 'resin.yaml', type: MetadataFileType.Yaml },
            { name: 'resin.json', type: MetadataFileType.Json },
        ];
        let bufData;
        let foundType;
        let foundName;
        for (const { name, type } of potentials) {
            if (name in this.metadataFiles) {
                if (foundName != null) {
                    throw new errors_1.MultipleBalenaConfigFilesError([foundName, name]);
                }
                foundName = name;
                bufData = this.metadataFiles[name];
                foundType = type;
            }
        }
        if (bufData != null) {
            let result;
            try {
                let value;
                if (foundType === MetadataFileType.Json) {
                    value = JSON.parse(bufData.toString());
                }
                else {
                    value = jsYaml.safeLoad(bufData.toString());
                }
                result = build_secrets_1.parsedBalenaYml.decode(value);
                if (Either_1.isLeft(result)) {
                    throw new Error(io_ts_reporters_1.reporter(result).join('\n'));
                }
            }
            catch (e) {
                throw new errors_1.BalenaYMLValidationError(e);
            }
            this.balenaYml = {
                buildSecrets: result.right['build-secrets'] || {},
                buildVariables: result.right['build-variables'] || {},
            };
        }
        else {
            this.balenaYml = { buildSecrets: {}, buildVariables: {} };
        }
        this.parseRegistrySecrets();
    }
    getBuildVarsForService(serviceName) {
        const vars = {};
        if (this.balenaYml.buildVariables.global != null) {
            _.assign(vars, this.balenaYml.buildVariables.global);
        }
        const services = this.balenaYml.buildVariables.services;
        if (services != null && serviceName in services) {
            _.assign(vars, services[serviceName]);
        }
        return vars;
    }
    parseRegistrySecrets() {
        const potentials = [
            { name: 'registry-secrets.json', type: MetadataFileType.Json },
            { name: 'registry-secrets.yml', type: MetadataFileType.Yaml },
            { name: 'registry-secrets.yaml', type: MetadataFileType.Yaml },
        ];
        let bufData;
        let foundType;
        for (const { name, type } of potentials) {
            if (name in this.metadataFiles) {
                bufData = this.metadataFiles[name];
                foundType = type;
            }
        }
        if (bufData != null) {
            const validator = new registry_secrets_1.RegistrySecretValidator();
            let maybeSecrets;
            try {
                if (foundType === MetadataFileType.Yaml) {
                    maybeSecrets = jsYaml.safeLoad(bufData.toString());
                }
                else {
                    maybeSecrets = JSON.parse(bufData.toString());
                }
            }
            catch (e) {
                throw new errors_1.RegistrySecretValidationError(e);
            }
            const secrets = validator.validateRegistrySecrets(maybeSecrets);
            registry_secrets_1.addCanonicalDockerHubEntry(secrets);
            this.registrySecrets = secrets;
        }
        else {
            this.registrySecrets = {};
        }
    }
    addMetadataFile(name, data) {
        this.metadataFiles[name] = data;
    }
    getMetadataRelativePath(path) {
        for (const metadataDirectory of this.metadataDirectories) {
            if (PathUtils.posixContains(metadataDirectory, path)) {
                return {
                    relativePath: Path.posix.relative(metadataDirectory, path),
                    metadataDirectory,
                };
            }
        }
    }
}
exports.BuildMetadata = BuildMetadata;
exports.default = BuildMetadata;
//# sourceMappingURL=build-metadata.js.map