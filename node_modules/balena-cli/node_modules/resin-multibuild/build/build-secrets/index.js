"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeSecrets = exports.populateSecrets = exports.generateSecretPopulationMap = exports.parsedBalenaYml = exports.secretType = void 0;
const crypto = require("crypto");
const dockerfileTemplate = require("dockerfile-template");
const t = require("io-ts");
const _ = require("lodash");
const mz_1 = require("mz");
const path = require("path");
const resin_docker_build_1 = require("resin-docker-build");
const tar = require("tar-stream");
const errors_1 = require("../errors");
const varlist_1 = require("../validation-types/varlist");
exports.secretType = t.interface({
    source: t.string,
    dest: t.string,
});
exports.parsedBalenaYml = t.partial({
    'build-variables': t.partial({
        global: varlist_1.PermissiveVarList,
        services: t.dictionary(t.string, varlist_1.PermissiveVarList),
    }),
    'build-secrets': t.partial({
        global: t.array(exports.secretType),
        services: t.dictionary(t.string, t.array(exports.secretType)),
    }),
});
function generateSecretPopulationMap(serviceNames, buildMetadata, tmpDir) {
    const secretMap = {};
    const yml = buildMetadata.getBalenaYml();
    for (const serviceName of serviceNames) {
        const serviceSecret = {
            tmpDirectory: path.posix.join(tmpDir, crypto.randomBytes(10).toString('hex')),
            files: {},
        };
        let secretObjects = [];
        if (yml.buildSecrets.global != null) {
            secretObjects = secretObjects.concat(yml.buildSecrets.global);
        }
        if (yml.buildSecrets.services != null &&
            yml.buildSecrets.services[serviceName] != null) {
            secretObjects = secretObjects.concat(yml.buildSecrets.services[serviceName]);
        }
        for (const { source, dest } of secretObjects) {
            const buf = buildMetadata.getSecretFile(source);
            if (!buf) {
                throw new errors_1.BuildSecretMissingError(source);
            }
            serviceSecret.files[dest] = buf.toString('base64');
        }
        secretMap[serviceName] = serviceSecret;
    }
    return _.omitBy(secretMap, v => _.isEmpty(v.files));
}
exports.generateSecretPopulationMap = generateSecretPopulationMap;
function populateSecrets(docker, secrets, architecture, tmpDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const pack = tar.pack();
        pack.entry({
            name: 'secrets.json',
        }, JSON.stringify(secrets));
        const dockerfileContent = dockerfileTemplate.process(yield mz_1.fs.readFile(path.join(__dirname, 'Dockerfile'), 'utf8'), {
            ARCH: architecture,
        });
        pack.entry({
            name: 'Dockerfile',
        }, dockerfileContent);
        pack.finalize();
        const imageName = 'balena-secrets:latest';
        const dockerOpts = {
            t: imageName,
            volumes: [`${tmpDir}:${tmpDir}:rw`],
            forcerm: true,
        };
        const builder = resin_docker_build_1.Builder.fromDockerode(docker);
        try {
            yield new Promise((resolve, reject) => {
                builder.createBuildStream(dockerOpts, {
                    buildStream: stream => {
                        pack.pipe(stream);
                    },
                    buildSuccess: resolve,
                    buildFailure: reject,
                });
            });
        }
        catch (e) {
            throw new errors_1.SecretPopulationError(e);
        }
        finally {
            try {
                yield docker.getImage(imageName).remove({ force: true });
            }
            catch (_e) {
            }
        }
    });
}
exports.populateSecrets = populateSecrets;
function removeSecrets(docker, secrets, architecture, tmpDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const pack = tar.pack();
        pack.entry({
            name: 'remove.json',
        }, JSON.stringify(_.map(secrets, ({ tmpDirectory }) => tmpDirectory)));
        const dockerfileContent = dockerfileTemplate.process(yield mz_1.fs.readFile(path.join(__dirname, 'Dockerfile.remove'), 'utf8'), {
            ARCH: architecture,
        });
        pack.entry({
            name: 'Dockerfile',
        }, dockerfileContent);
        pack.finalize();
        const imageName = 'balena-secrets-remove:latest';
        const dockerOpts = {
            t: imageName,
            volumes: [`${tmpDir}:${tmpDir}:rw`],
            forcerm: true,
        };
        const builder = resin_docker_build_1.Builder.fromDockerode(docker);
        try {
            yield new Promise((resolve, reject) => {
                builder.createBuildStream(dockerOpts, {
                    buildStream: stream => {
                        pack.pipe(stream);
                    },
                    buildSuccess: resolve,
                    buildFailure: reject,
                });
            });
        }
        catch (e) {
            throw new errors_1.SecretPopulationError(e);
        }
        finally {
            try {
                yield docker.getImage(imageName).remove({ force: true });
            }
            catch (_e) {
            }
        }
    });
}
exports.removeSecrets = removeSecrets;
//# sourceMappingURL=index.js.map