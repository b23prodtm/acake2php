import * as Dockerode from 'dockerode';
import * as t from 'io-ts';
import BuildMetadata from '../build-metadata';
import { VarList } from '../validation-types/varlist';
export declare const secretType: t.TypeC<{
    source: t.StringC;
    dest: t.StringC;
}>;
export declare const parsedBalenaYml: t.PartialC<{
    'build-variables': t.PartialC<{
        global: t.Type<VarList, string[] | VarList, unknown>;
        services: t.RecordC<t.StringC, t.Type<VarList, string[] | VarList, unknown>>;
    }>;
    'build-secrets': t.PartialC<{
        global: t.ArrayC<t.TypeC<{
            source: t.StringC;
            dest: t.StringC;
        }>>;
        services: t.RecordC<t.StringC, t.ArrayC<t.TypeC<{
            source: t.StringC;
            dest: t.StringC;
        }>>>;
    }>;
}>;
export declare type ParsedBalenaYml = t.TypeOf<typeof parsedBalenaYml>;
export declare type SecretObject = t.TypeOf<typeof secretType>;
export interface BalenaYml {
    buildVariables: {
        global?: VarList;
        services?: Dictionary<VarList>;
    };
    buildSecrets: {
        global?: SecretObject[];
        services?: Dictionary<SecretObject[]>;
    };
}
export declare type SecretsPopulationMap = Dictionary<{
    tmpDirectory: string;
    files: Dictionary<string>;
}>;
export declare function generateSecretPopulationMap(serviceNames: string[], buildMetadata: BuildMetadata, tmpDir: string): SecretsPopulationMap;
export declare function populateSecrets(docker: Dockerode, secrets: SecretsPopulationMap, architecture: string, tmpDir: string): Promise<void>;
export declare function removeSecrets(docker: Dockerode, secrets: SecretsPopulationMap, architecture: string, tmpDir: string): Promise<void>;
