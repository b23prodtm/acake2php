"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.performSingleBuild = exports.initializeBuildMetadata = exports.performBuilds = exports.performSingleResolution = exports.performResolution = exports.buildHasSecrets = exports.fromImageDescriptors = exports.splitBuildStream = exports.PathUtils = void 0;
const Bluebird = require("bluebird");
const _ = require("lodash");
const path = require("path");
const Compose = require("resin-compose-parse");
const tar = require("tar-stream");
const TarUtils = require("tar-utils");
const build_1 = require("./build");
const build_metadata_1 = require("./build-metadata");
const build_secrets_1 = require("./build-secrets");
const contracts = require("./contracts");
const errors_1 = require("./errors");
const PathUtils = require("./path-utils");
exports.PathUtils = PathUtils;
const path_utils_1 = require("./path-utils");
const resolve_1 = require("./resolve");
const Utils = require("./utils");
var build_metadata_2 = require("./build-metadata");
Object.defineProperty(exports, "QEMU_BIN_NAME", { enumerable: true, get: function () { return build_metadata_2.QEMU_BIN_NAME; } });
__exportStar(require("./build-task"), exports);
__exportStar(require("./errors"), exports);
__exportStar(require("./local-image"), exports);
__exportStar(require("./registry-secrets"), exports);
function splitBuildStream(composition, buildStream) {
    const images = Compose.parse(composition);
    return fromImageDescriptors(images, buildStream);
}
exports.splitBuildStream = splitBuildStream;
function fromImageDescriptors(images, buildStream, metadataDirectories = ['.balena/', '.resin/']) {
    return __awaiter(this, void 0, void 0, function* () {
        const buildMetadata = new build_metadata_1.default(metadataDirectories);
        const newStream = yield buildMetadata.extractMetadata(buildStream);
        return new Promise((resolve, reject) => {
            const tasks = Utils.generateBuildTasks(images, buildMetadata);
            const extract = tar.extract();
            const entryFn = (header, stream, next) => {
                const matchingTasks = _.filter(tasks, task => {
                    if (task.external) {
                        return false;
                    }
                    return path_utils_1.posixContains(task.context, header.name);
                });
                if (matchingTasks.length > 0) {
                    TarUtils.streamToBuffer(stream)
                        .then(buf => {
                        matchingTasks.forEach(task => {
                            const relative = path.posix.relative(task.context, header.name);
                            if (contracts.isContractFile(relative)) {
                                if (task.contract != null) {
                                    throw new errors_1.MultipleContractsForService(task.serviceName);
                                }
                                task.contract = contracts.processContract(buf);
                            }
                            const newHeader = _.cloneDeep(header);
                            newHeader.name = relative;
                            task.buildStream.entry(newHeader, buf);
                        });
                    })
                        .then(() => {
                        next();
                        return null;
                    })
                        .catch(errors_1.ContractError, reject)
                        .catch(e => reject(new errors_1.TarError(e)));
                }
                else {
                    TarUtils.drainStream(stream)
                        .then(() => {
                        next();
                        return null;
                    })
                        .catch(e => reject(new errors_1.TarError(e)));
                }
            };
            extract.on('entry', entryFn);
            extract.on('finish', () => {
                _.each(tasks, task => {
                    if (!task.external) {
                        task.buildStream.finalize();
                    }
                });
                resolve(tasks);
            });
            extract.on('error', e => {
                reject(new errors_1.TarError(e));
            });
            newStream.pipe(extract);
        }).then(tasks => {
            contracts.checkContractNamesUnique(tasks);
            return tasks;
        });
    });
}
exports.fromImageDescriptors = fromImageDescriptors;
function buildHasSecrets(tasks) {
    if (tasks.length === 0) {
        return false;
    }
    return !_.isEmpty(build_secrets_1.generateSecretPopulationMap(_.map(tasks, 'serviceName'), tasks[0].buildMetadata, '/tmp'));
}
exports.buildHasSecrets = buildHasSecrets;
function performResolution(tasks, architecture, deviceType, resolveListeners, additionalTemplateVars, dockerfilePreprocessHook) {
    return tasks.map(task => {
        task.architecture = architecture;
        return resolve_1.resolveTask(task, architecture, deviceType, resolveListeners, additionalTemplateVars, dockerfilePreprocessHook);
    });
}
exports.performResolution = performResolution;
function performSingleResolution(task, architecture, deviceType, resolveListeners, additionalTemplateVars, dockerfilePreprocessHook) {
    task.architecture = architecture;
    return resolve_1.resolveTask(task, architecture, deviceType, resolveListeners, additionalTemplateVars, dockerfilePreprocessHook);
}
exports.performSingleResolution = performSingleResolution;
function performBuilds(tasks, docker, tmpDir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (tasks.length === 0) {
            return [];
        }
        const buildMetadata = tasks[0].buildMetadata;
        const { secrets: secretMap, regSecrets: registrySecrets, architecture, } = yield initializeBuildMetadata(tasks, docker, tmpDir);
        const images = yield Bluebird.map(tasks, (task) => {
            return performSingleBuild(task, docker, registrySecrets, secretMap, buildMetadata.getBuildVarsForService(task.serviceName));
        });
        if (!_.isEmpty(secretMap)) {
            try {
                yield build_secrets_1.removeSecrets(docker, secretMap, architecture, tmpDir);
            }
            catch (e) {
                throw new errors_1.SecretRemovalError(e);
            }
        }
        return images;
    });
}
exports.performBuilds = performBuilds;
function initializeBuildMetadata(tasks, docker, tmpDir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (tasks.length === 0) {
            return { secrets: {}, regSecrets: {}, architecture: '' };
        }
        const buildMetadata = tasks[0].buildMetadata;
        const architecture = (yield docker.version()).Arch;
        buildMetadata.parseMetadata();
        const registrySecrets = buildMetadata.registrySecrets;
        const secretMap = build_secrets_1.generateSecretPopulationMap(_.map(tasks, 'serviceName'), buildMetadata, tmpDir);
        const hasSecrets = !_.isEmpty(secretMap);
        if (hasSecrets) {
            yield build_secrets_1.populateSecrets(docker, secretMap, architecture, tmpDir);
        }
        return { secrets: secretMap, regSecrets: registrySecrets, architecture };
    });
}
exports.initializeBuildMetadata = initializeBuildMetadata;
function performSingleBuild(task, docker, registrySecrets, secretMap, buildArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield build_1.runBuildTask(task, docker, registrySecrets, secretMap, buildArgs);
        }
        catch (e) {
            throw new errors_1.BuildProcessError(e);
        }
    });
}
exports.performSingleBuild = performSingleBuild;
//# sourceMappingURL=index.js.map