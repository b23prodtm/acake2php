"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBuildTask = void 0;
const Promise = require("bluebird");
const _ = require("lodash");
const resin_docker_build_1 = require("resin-docker-build");
const errors_1 = require("./errors");
const external_1 = require("./external");
const local_image_1 = require("./local-image");
function taskHooks(task, docker, resolve) {
    let startTime;
    const setImageProperties = (image, layers, fromTags) => {
        image.layers = layers;
        image.baseImageTags = fromTags;
        image.startTime = startTime;
        image.endTime = Date.now();
        image.dockerfile = task.dockerfile;
        image.projectType = task.projectType;
    };
    return {
        buildSuccess: (imageId, layers, fromTags) => {
            const tag = task.tag != null ? task.tag : imageId;
            const image = new local_image_1.LocalImage(docker, tag, task.serviceName, {
                external: false,
                successful: true,
            });
            setImageProperties(image, layers, fromTags);
            resolve(image);
        },
        buildFailure: (error, layers, fromTags) => {
            const image = new local_image_1.LocalImage(docker, layers[layers.length - 1], task.serviceName, { external: false, successful: false });
            setImageProperties(image, layers, fromTags);
            image.error = error;
            resolve(image);
        },
        buildStream: (stream) => {
            startTime = Date.now();
            if (_.isFunction(task.streamHook)) {
                task.streamHook(stream);
            }
            task.buildStream.pipe(stream);
        },
    };
}
const generateBuildArgs = (task, userArgs) => {
    return {
        buildargs: Object.assign(Object.assign({}, task.args), userArgs),
    };
};
const generateLabels = (task) => {
    return {
        labels: task.labels,
    };
};
function runBuildTask(task, docker, registrySecrets, secrets, buildArgs) {
    task.dockerOpts = _.merge({ registryconfig: registrySecrets }, task.dockerOpts);
    if (task.external) {
        return external_1.pullExternal(task, docker);
    }
    const taskResolved = task.resolvedPromise || Promise.resolve();
    return new Promise((resolve, reject) => {
        taskResolved.then(() => {
            if (task.buildStream == null) {
                reject(new errors_1.BuildProcessError('Null build stream on non-external image'));
                return;
            }
            let dockerOpts = task.dockerOpts || {};
            dockerOpts = _.merge(dockerOpts, generateBuildArgs(task, buildArgs), generateLabels(task));
            if (secrets != null && task.serviceName in secrets) {
                if (dockerOpts.volumes == null) {
                    dockerOpts.volumes = [];
                }
                dockerOpts.volumes.push(`${secrets[task.serviceName].tmpDirectory}:/run/secrets:ro`);
            }
            if (task.tag != null) {
                dockerOpts = _.merge(dockerOpts, { t: task.tag });
            }
            if (task.dockerfilePath != null) {
                dockerOpts = _.merge(dockerOpts, {
                    dockerfile: task.dockerfilePath,
                });
            }
            const builder = resin_docker_build_1.Builder.fromDockerode(docker);
            const hooks = taskHooks(task, docker, resolve);
            builder.createBuildStream(dockerOpts, hooks, reject);
        });
    });
}
exports.runBuildTask = runBuildTask;
//# sourceMappingURL=build.js.map