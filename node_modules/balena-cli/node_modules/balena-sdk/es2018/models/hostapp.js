"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OsTypes = void 0;
const bSemver = require("balena-semver");
const cache_1 = require("../util/cache");
const RELEASE_POLICY_TAG_NAME = 'release-policy';
const ESR_NEXT_TAG_NAME = 'esr-next';
const ESR_CURRENT_TAG_NAME = 'esr-current';
const ESR_SUNSET_TAG_NAME = 'esr-sunset';
const VARIANT_TAG_NAME = 'variant';
const VERSION_TAG_NAME = 'version';
const BASED_ON_VERSION_TAG_NAME = 'meta-balena-base';
var OsTypes;
(function (OsTypes) {
    OsTypes["DEFAULT"] = "default";
    OsTypes["ESR"] = "esr";
})(OsTypes = exports.OsTypes || (exports.OsTypes = {}));
const getHostappModel = function (deps) {
    const { pine, pubsub } = deps;
    const sortVersions = (a, b) => {
        return bSemver.rcompare(a.rawVersion, b.rawVersion);
    };
    const getTagValue = (tags, tagKey) => {
        var _a;
        return (_a = tags.find((tag) => tag.tag_key === tagKey)) === null || _a === void 0 ? void 0 : _a.value;
    };
    const getOsAppTags = (applicationTag) => {
        var _a, _b, _c, _d;
        return {
            osType: (_a = getTagValue(applicationTag, RELEASE_POLICY_TAG_NAME)) !== null && _a !== void 0 ? _a : OsTypes.DEFAULT,
            nextLineVersionRange: (_b = getTagValue(applicationTag, ESR_NEXT_TAG_NAME)) !== null && _b !== void 0 ? _b : '',
            currentLineVersionRange: (_c = getTagValue(applicationTag, ESR_CURRENT_TAG_NAME)) !== null && _c !== void 0 ? _c : '',
            sunsetLineVersionRange: (_d = getTagValue(applicationTag, ESR_SUNSET_TAG_NAME)) !== null && _d !== void 0 ? _d : '',
        };
    };
    const getOsVersionReleaseLine = (version, appTags) => {
        var _a;
        // All patches belong to the same line.
        if (bSemver.satisfies(version, `^${appTags.nextLineVersionRange}`)) {
            return 'next';
        }
        if (bSemver.satisfies(version, `^${appTags.currentLineVersionRange}`)) {
            return 'current';
        }
        if (bSemver.satisfies(version, `^${appTags.sunsetLineVersionRange}`)) {
            return 'sunset';
        }
        if (((_a = appTags.osType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === OsTypes.ESR) {
            return 'outdated';
        }
    };
    const normalizeVariant = (variant) => {
        switch (variant) {
            case 'production':
                return 'prod';
            case 'development':
                return 'dev';
            default:
                return variant;
        }
    };
    const getOsVersionsFromReleases = (releases, appTags) => {
        return releases.map((release) => {
            var _a, _b, _c;
            // The variant in the tags is a full noun, such as `production` and `development`.
            const variant = (_a = getTagValue(release.release_tag, VARIANT_TAG_NAME)) !== null && _a !== void 0 ? _a : 'production';
            const normalizedVariant = normalizeVariant(variant);
            const version = (_b = getTagValue(release.release_tag, VERSION_TAG_NAME)) !== null && _b !== void 0 ? _b : '';
            const basedOnVersion = (_c = getTagValue(release.release_tag, BASED_ON_VERSION_TAG_NAME)) !== null && _c !== void 0 ? _c : version;
            const line = getOsVersionReleaseLine(version, appTags);
            const lineFormat = line ? ` (${line})` : '';
            // TODO: Don't append the variant and sent it as a separate parameter when requesting a download when we don't use /device-types anymore and the API and image maker can handle it. Also rename `rawVersion` -> `versionWithVariant` if it is needed (it might not be needed anymore).
            // The version coming from release tags doesn't contain the variant, so we append it here
            return {
                id: release.id,
                osType: appTags.osType,
                line,
                strippedVersion: version,
                rawVersion: `${version}.${normalizedVariant}`,
                basedOnVersion,
                variant: normalizedVariant,
                formattedVersion: `v${version}${lineFormat}`,
            };
        });
    };
    const transformHostApps = (apps) => {
        const res = apps.reduce((osVersionsByDeviceType, hostApp) => {
            var _a, _b;
            if (!hostApp) {
                return osVersionsByDeviceType;
            }
            const hostAppDeviceType = hostApp.is_for__device_type[0].slug;
            if (!hostAppDeviceType) {
                return osVersionsByDeviceType;
            }
            let osVersions = osVersionsByDeviceType[hostAppDeviceType];
            if (!osVersions) {
                osVersions = [];
            }
            const appTags = getOsAppTags((_a = hostApp.application_tag) !== null && _a !== void 0 ? _a : []);
            osVersions = osVersions.concat(getOsVersionsFromReleases((_b = hostApp.owns__release) !== null && _b !== void 0 ? _b : [], appTags));
            osVersionsByDeviceType[hostAppDeviceType] = osVersions;
            return osVersionsByDeviceType;
        }, {});
        return res;
    };
    // This mutates the passed object.
    const transformVersionSets = (osVersionsByDeviceType) => {
        Object.keys(osVersionsByDeviceType).forEach((deviceType) => {
            osVersionsByDeviceType[deviceType].sort(sortVersions);
            const recommendedPerOsType = {};
            // Note: the recommended version settings might come from the server in the future, for now we just set it to the latest version for each os type.
            osVersionsByDeviceType[deviceType].forEach((version) => {
                if (!recommendedPerOsType[version.osType]) {
                    if (version.variant !== 'dev' &&
                        !bSemver.prerelease(version.rawVersion)) {
                        const additionalFormat = version.line
                            ? ` (${version.line}, recommended)`
                            : ' (recommended)';
                        version.isRecommended = true;
                        version.formattedVersion = `v${version.strippedVersion}${additionalFormat}`;
                        recommendedPerOsType[version.osType] = true;
                    }
                }
            });
        });
        return osVersionsByDeviceType;
    };
    const getOsVersions = (deviceTypes) => {
        return pine.get({
            resource: 'application',
            options: {
                $filter: {
                    is_host: true,
                    is_for__device_type: {
                        $any: {
                            $alias: 'dt',
                            $expr: {
                                dt: {
                                    slug: { $in: deviceTypes },
                                },
                            },
                        },
                    },
                },
                $select: ['id', 'app_name'],
                $expand: {
                    application_tag: {
                        $select: ['id', 'tag_key', 'value'],
                    },
                    is_for__device_type: {
                        $select: ['slug'],
                    },
                    owns__release: {
                        $select: ['id'],
                        $expand: {
                            release_tag: {
                                $select: ['id', 'tag_key', 'value'],
                            },
                        },
                        $filter: {
                            is_invalidated: false,
                        },
                    },
                },
            },
        });
    };
    const getTransformedOsVersions = async (deviceTypes) => {
        const hostapps = await getOsVersions(deviceTypes);
        return transformVersionSets(transformHostApps(hostapps));
    };
    const memoizedGetTransformedOsVersions = cache_1.getAuthDependentMemoize(pubsub)(getTransformedOsVersions);
    /**
     * @summary Get all OS versions for the passed device types
     * @name getAllOsVersions
     * @public
     * @function
     * @memberof balena.models.hostapp
     *
     * @param {String[]} deviceTypes - device type slugs
     * @returns {Promise}
     *
     * @example
     * balena.models.hostapp.getAllOsVersions(['fincm3', 'raspberrypi3']);
     */
    const getAllOsVersions = async (deviceTypes) => {
        const sortedDeviceTypes = deviceTypes.sort();
        return memoizedGetTransformedOsVersions(sortedDeviceTypes);
    };
    return {
        OsTypes,
        getAllOsVersions,
    };
};
exports.default = getHostappModel;
