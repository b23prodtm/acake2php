"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergePineOptions = exports.treatAsMissingDevice = exports.treatAsMissingApplication = exports.treatAsMissingOrganization = exports.isNoApplicationForKeyResponse = exports.isNoDeviceForKeyResponse = exports.isNotFoundResponse = exports.isUnauthorizedResponse = exports.LOCKED_STATUS_CODE = exports.isId = exports.onlyIf = exports.notImplemented = void 0;
const errors = require("balena-errors");
const notImplemented = () => {
    throw new Error('The method is not implemented.');
};
exports.notImplemented = notImplemented;
const onlyIf = (condition) => (fn) => {
    if (condition) {
        return fn;
    }
    else {
        return exports.notImplemented;
    }
};
exports.onlyIf = onlyIf;
const isId = (v) => typeof v === 'number';
exports.isId = isId;
exports.LOCKED_STATUS_CODE = 423;
const isBalenaRequestErrorResponseWithCode = (error, statusCode) => error.code === 'BalenaRequestError' && error.statusCode === statusCode;
const isUnauthorizedResponse = (err) => isBalenaRequestErrorResponseWithCode(err, 401);
exports.isUnauthorizedResponse = isUnauthorizedResponse;
const isNotFoundResponse = (err) => isBalenaRequestErrorResponseWithCode(err, 404);
exports.isNotFoundResponse = isNotFoundResponse;
const isNoDeviceForKeyResponse = (err) => isBalenaRequestErrorResponseWithCode(err, 500) &&
    err.body === 'No device found to associate with the api key';
exports.isNoDeviceForKeyResponse = isNoDeviceForKeyResponse;
const isNoApplicationForKeyResponse = (err) => isBalenaRequestErrorResponseWithCode(err, 500) &&
    err.body === 'No application found to associate with the api key';
exports.isNoApplicationForKeyResponse = isNoApplicationForKeyResponse;
const treatAsMissingOrganization = (handleOrId, err) => {
    const replacementErr = new errors.BalenaOrganizationNotFound(handleOrId);
    replacementErr.stack = err.stack || '';
    throw replacementErr;
};
exports.treatAsMissingOrganization = treatAsMissingOrganization;
const treatAsMissingApplication = (nameOrId, err) => {
    const replacementErr = new errors.BalenaApplicationNotFound(nameOrId);
    replacementErr.stack = err.stack || '';
    throw replacementErr;
};
exports.treatAsMissingApplication = treatAsMissingApplication;
const treatAsMissingDevice = (uuidOrId, err) => {
    const replacementErr = new errors.BalenaDeviceNotFound(uuidOrId);
    replacementErr.stack = err.stack || '';
    throw replacementErr;
};
exports.treatAsMissingDevice = treatAsMissingDevice;
function mergePineOptions(defaults, extras) {
    if (!extras) {
        return defaults;
    }
    const result = { ...defaults };
    for (const option of Object.keys(extras)) {
        switch (option) {
            case '$select':
                let extraSelect = extras.$select;
                if (extraSelect != null) {
                    if (!Array.isArray(extraSelect) && extraSelect !== '*') {
                        extraSelect = [extraSelect];
                    }
                }
                result.$select = extraSelect;
                break;
            case '$orderby':
            case '$top':
            case '$skip':
                // @ts-ignore
                result[option] = extras[option];
                break;
            case '$filter':
                const extraFilter = extras.$filter;
                if (!extraFilter) {
                    // the result already holds the defaults
                    break;
                }
                const defaultFilter = defaults.$filter;
                if (!defaultFilter) {
                    result.$filter = extraFilter;
                }
                else {
                    result.$filter = {
                        $and: [defaultFilter, extraFilter],
                    };
                }
                break;
            case '$expand':
                result.$expand = mergeExpandOptions(defaults.$expand, extras.$expand);
                break;
            default:
                throw new Error(`Unknown pine option: ${option}`);
        }
    }
    return result;
}
exports.mergePineOptions = mergePineOptions;
const mergeExpandOptions = (defaultExpand, extraExpand) => {
    if (defaultExpand == null) {
        return extraExpand;
    }
    // We only need to clone the defaultExpand as it's the only one we mutate
    defaultExpand = convertExpandToObject(defaultExpand, true);
    extraExpand = convertExpandToObject(extraExpand);
    for (const expandKey of Object.keys(extraExpand || {})) {
        const extraExpandOptions = extraExpand[expandKey] || {};
        defaultExpand[expandKey] = defaultExpand[expandKey] || {};
        const expandOptions = defaultExpand[expandKey];
        if (extraExpandOptions.$select) {
            expandOptions.$select = extraExpandOptions.$select;
        }
        if (extraExpandOptions.$filter) {
            if (expandOptions.$filter) {
                expandOptions.$filter = {
                    $and: [expandOptions.$filter, extraExpandOptions.$filter],
                };
            }
            else {
                expandOptions.$filter = extraExpandOptions.$filter;
            }
        }
        if (extraExpandOptions.$expand) {
            expandOptions.$expand = mergeExpandOptions(expandOptions.$expand, extraExpandOptions.$expand);
        }
    }
    return defaultExpand;
};
// Converts a valid expand object in any format into a new object
// containing (at most) $expand, $filter and $select keys
const convertExpandToObject = (expandOption, cloneIfNeeded = false) => {
    if (expandOption == null) {
        return {};
    }
    if (typeof expandOption === 'string') {
        return {
            [expandOption]: {},
        };
    }
    if (Array.isArray(expandOption)) {
        // Reduce the array into a single object
        return expandOption.reduce((result, option) => Object.assign(result, typeof option === 'string' ? { [option]: {} } : option), {});
    }
    // Check the options in this object are the ones we know how to merge
    for (const expandKey of Object.keys(expandOption)) {
        const expandRelationshipOptions = expandOption[expandKey];
        const invalidKeys = Object.keys(expandRelationshipOptions || {}).filter((key) => key !== '$select' && key !== '$expand' && key !== '$filter');
        if (invalidKeys.length > 0) {
            throw new Error(`Unknown pine expand options: ${invalidKeys}`);
        }
    }
    if (cloneIfNeeded) {
        return { ...expandOption };
    }
    return expandOption;
};
