/**
 * @summary Merge objects into one
 * @function
 * @protected
 *
 * @description
 * The last passed objects have precedence over the first ones.
 *
 * @param {...Object} objects - input objects
 * @returns {Object} merged object
 *
 * @example
 * const first = { foo: 'bar' }
 * const second = { foo: 'baz' }
 * const third = { foo: 'qux' }
 *
 * console.log(utils.mergeObjects(first, second, third))
 * > { foo: 'qux' }
 */
export declare const mergeObjects: {
    <TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
    <TObject_1, TSource1, TSource2>(object: TObject_1, source1: TSource1, source2: TSource2): TObject_1 & TSource1 & TSource2;
    <TObject_2, TSource1_1, TSource2_1, TSource3>(object: TObject_2, source1: TSource1_1, source2: TSource2_1, source3: TSource3): TObject_2 & TSource1_1 & TSource2_1 & TSource3;
    <TObject_3, TSource1_2, TSource2_2, TSource3_1, TSource4>(object: TObject_3, source1: TSource1_2, source2: TSource2_2, source3: TSource3_1, source4: TSource4): TObject_3 & TSource1_2 & TSource2_2 & TSource3_1 & TSource4;
    (object: any, ...otherArgs: any[]): any;
};
/**
 * @summary Evaluate a setting property
 * @function
 * @protected
 *
 * @param {Object} [settings={}] - settings
 * @param {String} property - period separated property
 * @returns {*} setting value
 *
 * @throws Will throw if setting is not found.
 *
 * @example
 * console.log(utils.evaluateSetting({ foo: 'bar' }, 'foo'))
 * > 'bar'
 *
 * @example
 * console.log(utils.evaluateSetting({
 * 	foo: {
 * 		bar: 'baz'
 * 	}
 * }, 'foo.bar'))
 * > 'baz'
 *
 * @example
 * console.log(utils.evaluateSetting({
 * 	greeting: 'Hola',
 * 	message: function() {
 * 		return `${this.greeting} World`
 * 	}
 * }), 'message')
 * > Hola World
 */
export declare const evaluateSetting: <T>(settings: object | undefined | null, property: string) => T;
