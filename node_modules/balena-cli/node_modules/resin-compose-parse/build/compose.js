"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.normalize = exports.defaultComposition = void 0;
const _ = require("lodash");
const path = require("path");
const errors_1 = require("./errors");
const schemas_1 = require("./schemas");
const packageJson = require('../package.json');
const packageVersion = packageJson.version;
function defaultComposition(image, dockerfile) {
    let context;
    if (image) {
        context = `image: ${image}`;
    }
    else {
        if (dockerfile) {
            context = `build: {context: ".", dockerfile: "${dockerfile}"}`;
        }
        else {
            context = 'build: "."';
        }
    }
    return `# Auto-generated compose file by resin-compose-parse@v${packageVersion}
version: '2.1'
networks: {}
volumes:
  resin-data: {}
services:
  main:
    ${context}
    privileged: true
    tty: true
    restart: always
    network_mode: host
    volumes:
      - resin-data:/data
    labels:
      io.resin.features.kernel-modules: 1
      io.resin.features.firmware: 1
      io.resin.features.dbus: 1
      io.resin.features.supervisor-api: 1
      io.resin.features.resin-api: 1
`;
}
exports.defaultComposition = defaultComposition;
function normalize(o) {
    if (!_.isObject(o)) {
        throw new errors_1.ValidationError('Invalid composition format');
    }
    let version;
    let c = o;
    if (_.isUndefined(c.version)) {
        version = schemas_1.SchemaVersion.v1_0;
    }
    else {
        if (!_.isString(c.version)) {
            c.version = `${c.version}`;
        }
        switch (c.version) {
            case '2':
            case '2.0':
                version = schemas_1.SchemaVersion.v2_0;
                break;
            case '2.1':
                version = schemas_1.SchemaVersion.v2_1;
                break;
            default:
                throw new errors_1.ValidationError('Unsupported composition version');
        }
    }
    preflight(version, c);
    try {
        schemas_1.validate(version, c);
    }
    catch (e) {
        if (e instanceof schemas_1.SchemaError) {
            throw new errors_1.ValidationError(e);
        }
        throw e;
    }
    switch (version) {
        case schemas_1.SchemaVersion.v1_0:
            c = { version: schemas_1.SchemaVersion.v2_0, services: c };
        case schemas_1.SchemaVersion.v2_0:
            c.version = schemas_1.SchemaVersion.v2_1;
        case schemas_1.SchemaVersion.v2_1:
            if (c.volumes) {
                const volumes = c.volumes;
                c.volumes = _.mapValues(volumes, normalizeVolume);
            }
            const services = c.services || {};
            const serviceNames = _.keys(services);
            const volumeNames = _.keys(c.volumes);
            c.services = _.mapValues(services, (service) => {
                return normalizeService(service, serviceNames, volumeNames);
            });
            if (c.networks) {
                const networks = c.networks;
                c.networks = _.mapValues(networks, normalizeNetwork);
            }
            return c;
    }
}
exports.normalize = normalize;
function preflight(_version, data) {
    if (_.isObject(data.networks)) {
        data.networks = _.mapValues(data.networks, (n) => n || {});
    }
    if (_.isObject(data.volumes)) {
        data.volumes = _.mapValues(data.volumes, (v) => v || {});
    }
}
function normalizeService(service, serviceNames, volumeNames) {
    if (!service.image && !service.build) {
        throw new errors_1.ValidationError('You must specify either an image or a build');
    }
    if (service.build) {
        if (_.isString(service.build)) {
            service.build = { context: service.build };
        }
        if (service.build.args) {
            service.build.args = normalizeKeyValuePairs(service.build.args);
        }
        if (service.build.labels) {
            service.build.labels = normalizeKeyValuePairs(service.build.labels);
            validateLabels(service.build.labels);
        }
    }
    if (service.depends_on) {
        if (!_.isArray(service.depends_on)) {
            throw new errors_1.ValidationError('Service dependencies must be an array');
        }
        if (_.uniq(service.depends_on).length !== service.depends_on.length) {
            throw new errors_1.ValidationError('Service dependencies must be unique');
        }
        service.depends_on.forEach((dep) => {
            if (!_.includes(serviceNames, dep)) {
                throw new errors_1.ValidationError(`Unknown service dependency: ${dep}`);
            }
        });
    }
    if (service.environment) {
        service.environment = normalizeKeyValuePairs(service.environment);
    }
    if (service.extra_hosts) {
        if (!_.isArray(service.extra_hosts)) {
            service.extra_hosts = normalizeExtraHostObject(service.extra_hosts);
        }
    }
    if (service.labels) {
        service.labels = normalizeKeyValuePairs(service.labels);
        validateLabels(service.labels);
    }
    if (service.ports) {
        service.ports = normalizeArrayOfStrings(service.ports);
    }
    if (service.volumes) {
        service.volumes.forEach((volume) => {
            validateServiceVolume(volume, volumeNames);
        });
    }
    return service;
}
function normalizeArrayOfStrings(value) {
    return _.map(value, String);
}
function validateServiceVolume(serviceVolume, volumeNames) {
    const colonIndex = serviceVolume.indexOf(':');
    if (colonIndex === -1) {
        throw new errors_1.ValidationError(`Invalid volume: '${serviceVolume}'`);
    }
    const source = serviceVolume.slice(0, colonIndex);
    if (path.parse(source).dir !== '') {
        throw new errors_1.ValidationError('Bind mounts are not allowed');
    }
    if (volumeNames.indexOf(source) === -1) {
        throw new errors_1.ValidationError(`Missing volume definition for '${source}'`);
    }
}
function validateLabels(labels) {
    _.keys(labels).forEach((name) => {
        if (!/^[a-zA-Z0-9.-]+$/.test(name)) {
            throw new errors_1.ValidationError(`Invalid label name: "${name}". ` +
                'Label names must only contain alphanumeric ' +
                'characters, periods "." and dashes "-".');
        }
    });
}
function normalizeNetwork(network) {
    if (network.labels) {
        network.labels = normalizeKeyValuePairs(network.labels);
        validateLabels(network.labels);
    }
    return network;
}
function normalizeVolume(volume) {
    if (volume.labels) {
        volume.labels = normalizeKeyValuePairs(volume.labels);
        validateLabels(volume.labels);
    }
    return volume;
}
function normalizeExtraHostObject(extraHostsObject) {
    return _.map(extraHostsObject, (ip, host) => `${host}:${ip}`);
}
function parse(c) {
    if (c.version !== schemas_1.DEFAULT_SCHEMA_VERSION) {
        throw new Error('Unsupported composition version');
    }
    return _.toPairs(c.services).map(([name, service]) => {
        return createImageDescriptor(name, service);
    });
}
exports.parse = parse;
function createImageDescriptor(serviceName, service) {
    if (service.image && !service.build) {
        return { serviceName, image: service.image };
    }
    if (!service.build) {
        throw new errors_1.InternalInconsistencyError();
    }
    const build = {
        context: service.build.context,
    };
    if (service.build.dockerfile) {
        build.dockerfile = service.build.dockerfile;
    }
    if (service.build.args) {
        build.args = service.build.args;
    }
    if (service.build.labels) {
        build.labels = service.build.labels;
    }
    if (service.image) {
        build.tag = service.image;
    }
    return { serviceName, image: build };
}
function normalizeKeyValuePairs(obj, sep = '=') {
    if (!obj) {
        return {};
    }
    if (!_.isArray(obj)) {
        return _(obj)
            .toPairs()
            .map(([key, value]) => {
            return [key, value ? ('' + value).trim() : ''];
        })
            .fromPairs()
            .value();
    }
    return _(obj)
        .map((val) => {
        const parts = val.split(sep);
        return [parts.shift(), parts.join('=')];
    })
        .map(([key, value]) => {
        return [key.trim(), value ? value.trim() : ''];
    })
        .fromPairs()
        .value();
}
//# sourceMappingURL=compose.js.map