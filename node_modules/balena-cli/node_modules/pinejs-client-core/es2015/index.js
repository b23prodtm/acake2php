"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinejsClientCore = void 0;
const noop = () => {
};
const deprecated = {};
const addDeprecated = (name, message) => {
    deprecated[name] = () => {
        console.warn('pinejs-client deprecated:', message);
        deprecated[name] = noop;
    };
};
addDeprecated('expandFilter', '`$filter: a: b: ...` is deprecated, please use `$filter: a: $any: { $alias: "x", $expr: x: b: ... }` instead.');
addDeprecated('countInResource', "'`resource: 'a/$count'` is deprecated, please use `options: { $count: { ... } }` instead.");
addDeprecated('countInExpand', "'`$expand: { 'a/$count': {...} }` is deprecated, please use `$expand: { a: { $count: {...} } }` instead.");
const mapObj = (obj, fn) => Object.keys(obj).map((key) => fn(obj[key], key));
const NumberIsFinite = Number.isFinite || ((v) => typeof v === 'number' && isFinite(v));
const isString = (v) => typeof v === 'string';
const isBoolean = (v) => v === true || v === false;
const isDate = (v) => Object.prototype.toString.call(v) === '[object Date]';
const isObject = (v) => typeof v != null && typeof v === 'object';
const isValidOption = (key) => {
    return (key === '$filter' ||
        key === '$expand' ||
        key === '$orderby' ||
        key === '$top' ||
        key === '$skip' ||
        key === '$select');
};
const encodedSlash = encodeURIComponent('/');
const encodedCount = encodeURIComponent('$count');
const trailingCountRegex = new RegExp(`(?:(?:${encodedSlash})|/)${encodedCount}$`);
class Poll {
    constructor(requestFn, intervalTime = 10000) {
        this.intervalTime = intervalTime;
        this.subscribers = {
            error: [],
            data: [],
        };
        this.stopped = false;
        this.requestFn = requestFn;
        this.start();
    }
    setPollInterval(intervalTime) {
        this.intervalTime = intervalTime;
        this.restartTimeout();
    }
    runRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.stopped || this.requestFn == null) {
                return;
            }
            try {
                const response = yield this.requestFn();
                if (this.stopped) {
                    return;
                }
                this.restartTimeout();
                this.subscribers.data.forEach((fn) => {
                    try {
                        fn(response);
                    }
                    catch (error) {
                        console.error('pinejs-client error: Caught error in data event subscription:', error);
                    }
                });
            }
            catch (err) {
                if (this.stopped) {
                    return;
                }
                this.restartTimeout();
                this.subscribers.error.forEach((fn) => {
                    try {
                        fn(err);
                    }
                    catch (error) {
                        console.error('pinejs-client error: Caught error in error event subscription:', error);
                    }
                });
            }
        });
    }
    on(name, fn) {
        const subscribers = this.subscribers[name];
        const index = subscribers.push(fn) - 1;
        return {
            unsubscribe: () => delete this.subscribers[name][index],
        };
    }
    start() {
        this.stopped = false;
        this.runRequest();
    }
    stop() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        this.stopped = true;
    }
    destroy() {
        this.stop();
        this.requestFn = null;
        this.subscribers.error.length = 0;
        this.subscribers.data.length = 0;
    }
    restartTimeout() {
        if (this.stopped) {
            return;
        }
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        this.pollInterval = setTimeout(() => this.runRequest(), this.intervalTime);
    }
}
const isPrimitive = (value) => {
    return (value === null ||
        isString(value) ||
        NumberIsFinite(value) ||
        isBoolean(value) ||
        isDate(value));
};
const escapeResource = (resource) => {
    if (isString(resource)) {
        resource = encodeURIComponent(resource);
    }
    else if (Array.isArray(resource)) {
        resource = resource.map(encodeURIComponent).join('/');
    }
    else {
        throw new Error('Not a valid resource: ' + typeof resource);
    }
    return resource.replace(trailingCountRegex, '/$count');
};
const escapeValue = (value) => {
    if (isString(value)) {
        value = value.replace(/'/g, "''");
        return `'${encodeURIComponent(value)}'`;
    }
    else if (isDate(value)) {
        return `datetime'${value.toISOString()}'`;
    }
    else if (value === null || NumberIsFinite(value) || isBoolean(value)) {
        return value;
    }
    else {
        throw new Error('Not a valid value: ' + typeof value);
    }
};
const escapeParameterAlias = (value) => {
    if (!isString(value)) {
        throw new Error(`Parameter alias reference must be a string, got: ${typeof value}`);
    }
    return `@${encodeURIComponent(value)}`;
};
const join = (strOrArray, separator = ',') => {
    if (isString(strOrArray)) {
        return strOrArray;
    }
    else if (Array.isArray(strOrArray)) {
        return strOrArray.join(separator);
    }
    else {
        throw new Error('Expected a string or array, got: ' + typeof strOrArray);
    }
};
const bracketJoin = (arr, separator) => {
    if (arr.length === 1) {
        return arr[0];
    }
    const resultArr = [];
    arr
        .map((subArr) => {
        if (subArr.length > 1) {
            return `(${subArr.join('')})`;
        }
        return subArr[0];
    })
        .forEach((str, i) => {
        if (i !== 0) {
            resultArr.push(separator);
        }
        resultArr.push(str);
    });
    return resultArr;
};
const addParentKey = (filter, parentKey, operator = ' eq ') => {
    if (parentKey != null) {
        if (Array.isArray(filter)) {
            if (filter.length === 1) {
                filter = filter[0];
            }
            else {
                filter = `(${filter.join('')})`;
            }
        }
        else {
            filter = `${filter}`;
        }
        return [escapeResource(parentKey), operator, filter];
    }
    if (Array.isArray(filter)) {
        return filter;
    }
    return [`${filter}`];
};
const applyBinds = (filter, params, parentKey) => {
    for (const index of Object.keys(params)) {
        const param = params[index];
        let paramStr = `(${buildFilter(param).join('')})`;
        paramStr = paramStr.replace(/\$/g, '$$$$');
        filter = filter.replace(new RegExp(`\\$${index}([^a-zA-Z0-9]|$)`, 'g'), `${paramStr}$1`);
    }
    filter = `(${filter})`;
    return addParentKey(filter, parentKey);
};
const filterOperation = (filter, operator, parentKey) => {
    const op = ' ' + operator.slice(1) + ' ';
    if (isPrimitive(filter)) {
        const filterStr = escapeValue(filter);
        return addParentKey(filterStr, parentKey, op);
    }
    else if (Array.isArray(filter)) {
        const filterArr = handleFilterArray(filter);
        const filterStr = bracketJoin(filterArr, op);
        return addParentKey(filterStr, parentKey);
    }
    else if (isObject(filter)) {
        const result = handleFilterObject(filter);
        if (result.length < 1) {
            throw new Error(`${operator} objects must have at least 1 property, got: ${JSON.stringify(filter)}`);
        }
        if (result.length === 1) {
            return addParentKey(result[0], parentKey, op);
        }
        else {
            const filterStr = bracketJoin(result, op);
            return addParentKey(filterStr, parentKey);
        }
    }
    else {
        throw new Error('Expected null/string/number/bool/obj/array, got: ' + typeof filter);
    }
};
const filterFunction = (filter, fnIdentifier, parentKey) => {
    const fnName = fnIdentifier.slice(1);
    if (isPrimitive(filter)) {
        const operands = [];
        if (parentKey != null) {
            operands.push(escapeResource(parentKey));
        }
        operands.push(escapeValue(filter));
        return [`${fnName}(${operands.join()})`];
    }
    else if (Array.isArray(filter)) {
        const filterArr = handleFilterArray(filter);
        let filterStr = filterArr.map((subArr) => subArr.join('')).join(',');
        filterStr = `${fnName}(${filterStr})`;
        return addParentKey(filterStr, parentKey);
    }
    else if (isObject(filter)) {
        const filterArr = handleFilterObject(filter);
        let filterStr = filterArr.map((subArr) => subArr.join('')).join(',');
        filterStr = `${fnName}(${filterStr})`;
        return addParentKey(filterStr, parentKey);
    }
    else {
        throw new Error(`Expected null/string/number/obj/array, got: ${typeof filter}`);
    }
};
const handleFilterOperator = (filter, operator, parentKey) => {
    switch (operator) {
        case '$ne':
        case '$eq':
        case '$gt':
        case '$ge':
        case '$lt':
        case '$le':
        case '$add':
        case '$sub':
        case '$mul':
        case '$div':
        case '$mod':
            return filterOperation(filter, operator, parentKey);
        case '$contains':
        case '$endswith':
        case '$startswith':
        case '$length':
        case '$indexof':
        case '$substring':
        case '$tolower':
        case '$toupper':
        case '$trim':
        case '$concat':
        case '$year':
        case '$month':
        case '$day':
        case '$hour':
        case '$minute':
        case '$second':
        case '$fractionalseconds':
        case '$date':
        case '$time':
        case '$totaloffsetminutes':
        case '$now':
        case '$maxdatetime':
        case '$mindatetime':
        case '$totalseconds':
        case '$round':
        case '$floor':
        case '$ceiling':
        case '$isof':
        case '$cast':
            return filterFunction(filter, operator, parentKey);
        case '$raw': {
            filter = filter;
            if (isString(filter)) {
                filter = `(${filter})`;
                return addParentKey(filter, parentKey);
            }
            else if (!isPrimitive(filter)) {
                if (Array.isArray(filter)) {
                    const [rawFilter, ...params] = filter;
                    if (!isString(rawFilter)) {
                        throw new Error(`First element of array for ${operator} must be a string, got: ${typeof rawFilter}`);
                    }
                    const mappedParams = {};
                    for (let index = 0; index < params.length; index++) {
                        mappedParams[index + 1] = params[index];
                    }
                    return applyBinds(rawFilter, mappedParams, parentKey);
                }
                else if (isObject(filter)) {
                    const filterStr = filter.$string;
                    if (!isString(filterStr)) {
                        throw new Error(`$string element of object for ${operator} must be a string, got: ${typeof filterStr}`);
                    }
                    const mappedParams = {};
                    for (const index in filter) {
                        if (index !== '$string') {
                            if (!/^[a-zA-Z0-9]+$/.test(index)) {
                                throw new Error(`${operator} param names must contain only [a-zA-Z0-9], got: ${index}`);
                            }
                            mappedParams[index] = filter[index];
                        }
                    }
                    return applyBinds(filterStr, mappedParams, parentKey);
                }
            }
            throw new Error(`Expected string/array/object for ${operator}, got: ${typeof filter}`);
        }
        case '$': {
            const resource = escapeResource(filter);
            return addParentKey(resource, parentKey);
        }
        case '$count': {
            let keys = ['$count'];
            if (parentKey != null) {
                keys = parentKey.concat(keys);
            }
            return buildFilter(filter, keys);
        }
        case '$and':
        case '$or': {
            const filterStr = buildFilter(filter, undefined, ` ${operator.slice(1)} `);
            return addParentKey(filterStr, parentKey);
        }
        case '$in': {
            filter = filter;
            if (isPrimitive(filter)) {
                const filterStr = escapeValue(filter);
                return addParentKey(filterStr, parentKey, ' eq ');
            }
            else if (Array.isArray(filter)) {
                if (filter.every(isPrimitive)) {
                    const filterStr = handleFilterArray(filter, undefined, 1);
                    const inStr = bracketJoin(filterStr, ', ').join('');
                    return addParentKey(`(${inStr})`, parentKey, ' in ');
                }
                else {
                    const filterStr = handleFilterArray(filter, parentKey, 1);
                    return bracketJoin(filterStr, ' or ');
                }
            }
            else if (isObject(filter)) {
                const filterArr = handleFilterObject(filter, parentKey);
                if (filterArr.length < 1) {
                    throw new Error(`${operator} objects must have at least 1 property, got: ${JSON.stringify(filter)}`);
                }
                return bracketJoin(filterArr, ' or ');
            }
            else {
                throw new Error(`Expected null/string/number/bool/obj/array, got: ${typeof filter}`);
            }
        }
        case '$not': {
            const filterStr = `not(${buildFilter(filter).join('')})`;
            return addParentKey(filterStr, parentKey);
        }
        case '$any':
        case '$all': {
            filter = filter;
            const alias = filter.$alias;
            const expr = filter.$expr;
            if (alias == null) {
                throw new Error(`Lambda expression (${operator}) has no alias defined.`);
            }
            if (expr == null) {
                throw new Error(`Lambda expression (${operator}) has no expr defined.`);
            }
            const deprecatedFn = (deprecated.expandFilter = noop);
            let filterStr;
            try {
                filterStr = buildFilter(expr).join('');
            }
            finally {
                deprecated.expandFilter = deprecatedFn;
            }
            filterStr = `${operator.slice(1)}(${alias}:${filterStr})`;
            return addParentKey(filterStr, parentKey, '/');
        }
        default:
            throw new Error(`Unrecognised operator: '${operator}'`);
    }
};
const handleFilterObject = (filter, parentKey) => {
    return mapObj(filter, (value, key) => {
        if (value === undefined) {
            throw new Error(`'${key}' was present on a filter object but undefined, did you mean to use null instead?`);
        }
        if (key[0] === '$') {
            return handleFilterOperator(value, key, parentKey);
        }
        else if (key[0] === '@') {
            const parameterAlias = escapeParameterAlias(value);
            return addParentKey(parameterAlias, parentKey);
        }
        else {
            let keys = [key];
            if (parentKey != null) {
                if (parentKey.length > 0) {
                    deprecated.expandFilter();
                }
                keys = parentKey.concat(keys);
            }
            return buildFilter(value, keys);
        }
    });
};
const handleFilterArray = (filter, parentKey, minElements = 2) => {
    if (filter.length < minElements) {
        throw new Error(`Filter arrays must have at least ${minElements} elements, got: ${JSON.stringify(filter)}`);
    }
    return filter.map((value) => {
        return buildFilter(value, parentKey);
    });
};
const buildFilter = (filter, parentKey, joinStr) => {
    if (isPrimitive(filter)) {
        const filterStr = escapeValue(filter);
        return addParentKey(filterStr, parentKey);
    }
    else if (Array.isArray(filter)) {
        const filterArr = handleFilterArray(filter);
        const filterStr = bracketJoin(filterArr, joinStr !== null && joinStr !== void 0 ? joinStr : ' or ');
        return addParentKey(filterStr, parentKey);
    }
    else if (isObject(filter)) {
        const filterArr = handleFilterObject(filter, parentKey);
        return bracketJoin(filterArr, joinStr !== null && joinStr !== void 0 ? joinStr : ' and ');
    }
    else {
        throw new Error(`Expected null/string/number/obj/array, got: ${typeof filter}`);
    }
};
const buildOrderBy = (orderby) => {
    if (isString(orderby)) {
        return orderby;
    }
    else if (Array.isArray(orderby)) {
        if (orderby.length === 0) {
            throw new Error(`'$orderby' arrays have to have at least 1 element`);
        }
        const result = orderby.map((value) => {
            if (Array.isArray(value)) {
                throw new Error(`'$orderby' cannot have nested arrays`);
            }
            return buildOrderBy(value);
        });
        return join(result);
    }
    else if (isObject(orderby)) {
        const result = mapObj(orderby, (dir, key) => {
            if (dir !== 'asc' && dir !== 'desc') {
                throw new Error(`'$orderby' direction must be 'asc' or 'desc'`);
            }
            return `${key} ${dir}`;
        });
        if (result.length !== 1) {
            throw new Error(`'$orderby' objects must have exactly one element, got ${result.length} elements`);
        }
        return result[0];
    }
    else {
        throw new Error(`'$orderby' option has to be either a string, array, or object`);
    }
};
const buildOption = (option, value) => {
    let compiledValue = '';
    switch (option) {
        case '$filter':
            compiledValue = buildFilter(value).join('');
            break;
        case '$expand':
            compiledValue = buildExpand(value);
            break;
        case '$orderby':
            compiledValue = buildOrderBy(value);
            break;
        case '$top':
        case '$skip':
            const num = value;
            if (!NumberIsFinite(num)) {
                throw new Error(`'${option}' option has to be a number`);
            }
            compiledValue = '' + num;
            break;
        case '$select':
            const select = value;
            if (isString(select)) {
                compiledValue = join(select);
            }
            else if (Array.isArray(select)) {
                if (select.length === 0) {
                    throw new Error(`'${option}' arrays have to have at least 1 element`);
                }
                compiledValue = join(select);
            }
            else {
                throw new Error(`'${option}' option has to be either a string or array`);
            }
            break;
        default:
            if (option[0] === '@') {
                if (!isPrimitive(value)) {
                    throw new Error(`Unknown type for parameter alias option '${option}': ${typeof value}`);
                }
                compiledValue = '' + escapeValue(value);
            }
            else if (Array.isArray(value)) {
                compiledValue = join(value);
            }
            else if (isString(value)) {
                compiledValue = value;
            }
            else if (isBoolean(value) || NumberIsFinite(value)) {
                compiledValue = value.toString();
            }
            else {
                throw new Error(`Unknown type for option ${typeof value}`);
            }
    }
    return `${option}=${compiledValue}`;
};
const handleExpandOptions = (expand, parentKey) => {
    if (parentKey.endsWith('/$count')) {
        deprecated.countInExpand();
    }
    if (expand.hasOwnProperty('$count')) {
        const keys = Object.keys(expand);
        if (keys.length > 1) {
            throw new Error(`When using '$expand: a: $count: ...' you can only specify $count, got: '${JSON.stringify(keys)}'`);
        }
        expand = expand.$count;
        parentKey += '/$count';
    }
    const expandOptions = mapObj(expand, (value, key) => {
        if (key[0] === '$') {
            if (!isValidOption(key)) {
                throw new Error(`Unknown key option '${key}'`);
            }
            return buildOption(key, value);
        }
        else {
            throw new Error(`'$expand: ${parentKey}: ${key}: ...' is invalid, use '$expand: ${parentKey}: $expand: ${key}: ...' instead.`);
        }
    });
    let expandStr = expandOptions.join(';');
    if (expandStr.length > 0) {
        expandStr = `(${expandStr})`;
    }
    expandStr = escapeResource(parentKey) + expandStr;
    return expandStr;
};
const handleExpandObject = (expand) => {
    const expands = mapObj(expand, (value, key) => {
        if (key[0] === '$') {
            throw new Error('Cannot have expand options without first expanding something!');
        }
        if (isPrimitive(value)) {
            const jsonValue = JSON.stringify(value);
            throw new Error(`'$expand: ${key}: ${jsonValue}' is invalid, use '$expand: ${key}: $expand: ${jsonValue}' instead.`);
        }
        if (Array.isArray(value)) {
            throw new Error(`'$expand: ${key}: [...]' is invalid, use '$expand: ${key}: {...}' instead.`);
        }
        return handleExpandOptions(value, key);
    });
    return expands;
};
const handleExpandArray = (expands) => {
    if (expands.length < 1) {
        throw new Error(`Expand arrays must have at least 1 elements, got: ${JSON.stringify(expands)}`);
    }
    return expands.map((expand) => {
        return buildExpand(expand);
    });
};
const buildExpand = (expand) => {
    if (isPrimitive(expand)) {
        return escapeResource(expand);
    }
    else if (Array.isArray(expand)) {
        const expandStr = handleExpandArray(expand);
        return join(expandStr);
    }
    else if (isObject(expand)) {
        const expandStr = handleExpandObject(expand);
        return join(expandStr);
    }
    else {
        throw new Error(`Unknown type for expand '${typeof expand}'`);
    }
};
const validParams = [
    'apiPrefix',
    'passthrough',
    'passthroughByMethod',
];
class PinejsClientCore {
    constructor(params) {
        this.apiPrefix = '/';
        this.passthrough = {};
        this.passthroughByMethod = {};
        if (isString(params)) {
            params = { apiPrefix: params };
        }
        if (isObject(params)) {
            for (const validParam of validParams) {
                const value = params[validParam];
                if (value != null) {
                    this[validParam] = value;
                }
            }
        }
    }
    clone(params, backendParams) {
        if (isString(params)) {
            params = { apiPrefix: params };
        }
        const cloneParams = {};
        for (const validParam of validParams) {
            if (this[validParam] != null) {
                cloneParams[validParam] = this[validParam];
            }
            const paramValue = params === null || params === void 0 ? void 0 : params[validParam];
            if (paramValue != null) {
                cloneParams[validParam] = paramValue;
            }
        }
        let cloneBackendParams = {};
        if (isObject(this.backendParams)) {
            cloneBackendParams = Object.assign({}, this.backendParams);
        }
        if (isObject(backendParams)) {
            cloneBackendParams = Object.assign(Object.assign({}, cloneBackendParams), backendParams);
        }
        return new this.constructor(cloneParams, cloneBackendParams);
    }
    get(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isString(params)) {
                throw new Error('`get(url)` is no longer supported, please use `get({ url })` instead.');
            }
            const result = yield this.request(Object.assign(Object.assign({}, params), { method: 'GET' }));
            return this.transformGetResult(params)(result);
        });
    }
    transformGetResult(params) {
        const singular = params.id != null;
        return (data) => {
            if (!isObject(data)) {
                throw new Error(`Response was not a JSON object: '${typeof data}'`);
            }
            if (data.d == null) {
                throw new Error("Invalid response received, the 'd' property is missing.");
            }
            if (singular) {
                if (data.d.length > 1) {
                    throw new Error('Returned multiple results when only one was expected.');
                }
                return data.d[0];
            }
            return data.d;
        };
    }
    subscribe(params) {
        if (isString(params)) {
            throw new Error('`subscribe(url)` is no longer supported, please use `subscribe({ url })` instead.');
        }
        const { pollInterval } = params;
        const requestFn = this.prepare(params);
        return new Poll(requestFn, pollInterval);
    }
    put(params) {
        if (isString(params)) {
            throw new Error('`put(url)` is no longer supported, please use `put({ url })` instead.');
        }
        return this.request(Object.assign(Object.assign({}, params), { method: 'PUT' }));
    }
    patch(params) {
        if (isString(params)) {
            throw new Error('`patch(url)` is no longer supported, please use `patch({ url })` instead.');
        }
        return this.request(Object.assign(Object.assign({}, params), { method: 'PATCH' }));
    }
    post(params) {
        if (isString(params)) {
            throw new Error('`post(url)` is no longer supported, please use `post({ url })` instead.');
        }
        return this.request(Object.assign(Object.assign({}, params), { method: 'POST' }));
    }
    delete(params) {
        if (isString(params)) {
            throw new Error('`delete(url)` is no longer supported, please use `delete({ url })` instead.');
        }
        params.method = 'DELETE';
        return this.request(Object.assign(Object.assign({}, params), { method: 'DELETE' }));
    }
    upsert(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id, body } = params, restParams = __rest(params, ["id", "body"]);
            if (!isObject(id)) {
                throw new Error('The id property must be an object');
            }
            const naturalKeyProps = Object.keys(params.id);
            if (naturalKeyProps.length === 0) {
                throw new Error('The id property must be an object with the natural key of the model');
            }
            if (body == null) {
                throw new Error('The body property is missing');
            }
            const postParams = Object.assign(Object.assign({}, restParams), { body: Object.assign(Object.assign({}, body), id) });
            try {
                return yield this.post(postParams);
            }
            catch (err) {
                const isUniqueKeyViolationResponse = err.statusCode === 409 && /unique/i.test(err.body);
                if (!isUniqueKeyViolationResponse) {
                    throw err;
                }
                const { options } = restParams;
                const $filter = (options === null || options === void 0 ? void 0 : options.$filter) == null ? id : { $and: [options.$filter, id] };
                const patchParams = Object.assign(Object.assign({}, restParams), { options: Object.assign(Object.assign({}, options), { $filter }), body });
                yield this.patch(patchParams);
            }
        });
    }
    prepare(params) {
        if (isString(params)) {
            throw new Error('`prepare(url)` is no longer supported, please use `prepare({ url })` instead.');
        }
        const compiledUrl = this.compile(params);
        const urlQueryParamsStr = compiledUrl.indexOf('?') === -1 ? '?' : '&';
        if (params.method == null) {
            params.method = 'GET';
        }
        else {
            params.method = params.method.toUpperCase();
        }
        const { body: defaultBody } = params;
        const { passthrough: defaultPassthrough } = params;
        const transformFn = params.method === 'GET' ? this.transformGetResult(params) : undefined;
        return (parameterAliases, body, passthrough) => __awaiter(this, void 0, void 0, function* () {
            if (body != null) {
                params.body = Object.assign(Object.assign({}, defaultBody), body);
            }
            else if (defaultBody != null) {
                params.body = Object.assign({}, defaultBody);
            }
            if (passthrough != null) {
                params.passthrough = Object.assign(Object.assign({}, defaultPassthrough), passthrough);
            }
            else if (defaultPassthrough != null) {
                params.passthrough = Object.assign({}, defaultPassthrough);
            }
            if (parameterAliases != null) {
                params.url =
                    compiledUrl +
                        urlQueryParamsStr +
                        mapObj(parameterAliases, (value, option) => {
                            if (!isPrimitive(value)) {
                                throw new Error(`Unknown type for parameter alias option '${option}': ${typeof value}`);
                            }
                            return `@${option}=${escapeValue(value)}`;
                        }).join('&');
            }
            else {
                params.url = compiledUrl;
            }
            const result = yield this.request(params);
            if (transformFn != null) {
                return transformFn(result);
            }
            return result;
        });
    }
    compile(params) {
        if (isString(params)) {
            throw new Error('Params must be an object not a string');
        }
        if (params.url != null) {
            return params.url;
        }
        else {
            if (params.resource == null) {
                throw new Error('Either the url or resource must be specified.');
            }
            if (params.resource.endsWith('/$count')) {
                deprecated.countInResource();
            }
            let url = escapeResource(params.resource);
            let { options } = params;
            if (options === null || options === void 0 ? void 0 : options.hasOwnProperty('$count')) {
                const keys = Object.keys(options);
                if (keys.length > 1) {
                    throw new Error(`When using '$expand: a: $count: ...' you can only specify $count, got: '${JSON.stringify(keys)}'`);
                }
                url += '/$count';
                options = options.$count;
            }
            if (params.hasOwnProperty('id')) {
                const { id } = params;
                if (id == null) {
                    throw new Error('If the id property is set it must be non-null');
                }
                let value;
                if (isObject(id) && !isDate(id)) {
                    if ('@' in id) {
                        value = escapeParameterAlias(id['@']);
                    }
                    else {
                        value = mapObj(id, (v, k) => {
                            const escapedValue = isObject(v) && '@' in v
                                ? escapeParameterAlias(v['@'])
                                : escapeValue(v);
                            return `${k}=${escapedValue}`;
                        }).join(',');
                    }
                }
                else {
                    value = '' + escapeValue(id);
                }
                url += `(${value})`;
            }
            let queryOptions = [];
            if (options != null) {
                queryOptions = mapObj(options, (value, option) => {
                    if (option[0] === '$' && !isValidOption(option)) {
                        throw new Error(`Unknown odata option '${option}'`);
                    }
                    return buildOption(option, value);
                });
            }
            if (params.customOptions != null) {
                throw new Error('`customOptions` has been removed, use `options` instead.');
            }
            if (queryOptions.length > 0) {
                url += '?' + queryOptions.join('&');
            }
            return url;
        }
    }
    request(params, overrides) {
        var _a;
        if (overrides !== undefined) {
            throw new Error('request(params, overrides)` is unsupported, please use `request({ ...params, ...overrides })` instead.');
        }
        if (isString(params)) {
            throw new Error('`request(url)` is no longer supported, please use `request({ url })` instead.');
        }
        let { method, apiPrefix } = params;
        const { body, passthrough = {} } = params;
        apiPrefix = apiPrefix !== null && apiPrefix !== void 0 ? apiPrefix : this.apiPrefix;
        const url = apiPrefix + this.compile(params);
        method = method !== null && method !== void 0 ? method : 'GET';
        method = method.toUpperCase();
        const opts = Object.assign(Object.assign(Object.assign(Object.assign({}, this.passthrough), ((_a = this.passthroughByMethod[method]) !== null && _a !== void 0 ? _a : {})), passthrough), { url,
            body,
            method });
        return this._request(opts);
    }
}
exports.PinejsClientCore = PinejsClientCore;
//# sourceMappingURL=index.js.map