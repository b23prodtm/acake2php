'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require('path');

module.exports = function () {
  return new IgnoreBase();
};

// A simple implementation of make-array
function make_array(subject) {
  return Array.isArray(subject) ? subject : [subject];
}

var REGEX_TRAILING_SLASH = /\/$/;
var SLASH = '/';
var KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('dockerignore') : 'dockerignore';

// An implementation of Go's filepath.Clean
function cleanPath(file) {
  return path.normalize(file).replace(REGEX_TRAILING_SLASH, '');
}

var IgnoreBase = function () {
  function IgnoreBase() {
    _classCallCheck(this, IgnoreBase);

    this._rules = [];
    this[KEY_IGNORE] = true;
    this._initCache();
  }

  _createClass(IgnoreBase, [{
    key: '_initCache',
    value: function _initCache() {
      this._cache = {};
    }

    // @param {Array.<string>|string|Ignore} pattern

  }, {
    key: 'add',
    value: function add(pattern) {
      this._added = false;

      if (typeof pattern === 'string') {
        pattern = pattern.split(/\r?\n/g);
      }

      make_array(pattern).forEach(this._addPattern, this);

      // Some rules have just added to the ignore,
      // making the behavior changed.
      if (this._added) {
        this._initCache();
      }

      return this;
    }

    // legacy

  }, {
    key: 'addPattern',
    value: function addPattern(pattern) {
      return this.add(pattern);
    }
  }, {
    key: '_addPattern',
    value: function _addPattern(pattern) {
      // https://github.com/kaelzhang/node-ignore/issues/32
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }

      if (this._checkPattern(pattern)) {
        var rule = this._createRule(pattern.trim());
        if (rule !== null) {
          this._added = true;
          this._rules.push(rule);
        }
      }
    }
  }, {
    key: '_checkPattern',
    value: function _checkPattern(pattern) {
      // https://github.com/moby/moby/blob/4f0d95fa6ee7f865597c03b9e63702cdcb0f7067/builder/dockerignore/dockerignore.go#L33-L40
      return pattern && typeof pattern === 'string' && pattern.indexOf('#') !== 0 && pattern.trim() !== "";
    }
  }, {
    key: 'filter',
    value: function filter(paths) {
      var _this = this;

      return make_array(paths).filter(function (path) {
        return _this._filter(path);
      });
    }
  }, {
    key: 'createFilter',
    value: function createFilter() {
      var _this2 = this;

      return function (path) {
        return _this2._filter(path);
      };
    }
  }, {
    key: 'ignores',
    value: function ignores(path) {
      return !this._filter(path);
    }
  }, {
    key: '_createRule',
    value: function _createRule(pattern) {
      // https://github.com/moby/moby/blob/4f0d95fa6ee7f865597c03b9e63702cdcb0f7067/builder/dockerignore/dockerignore.go#L34-L40
      // TODO: Add link to github for dockerignore
      var origin = pattern;
      var negative = false;

      // > An optional prefix "!" which negates the pattern;
      if (pattern.indexOf('!') === 0) {
        negative = true;
        pattern = pattern.substr(1).trim();
      }

      if (pattern.length > 0) {
        pattern = cleanPath(pattern);
        pattern = pattern.split(path.sep).join(SLASH);
        if (pattern.length > 1 && pattern[0] === SLASH) {
          pattern = pattern.slice(1);
        }
      }

      pattern = pattern.trim();
      if (pattern === "") {
        return null;
      }

      return {
        origin: origin,
        pattern: pattern,
        dirs: pattern.split(path.sep),
        negative: negative
      };
    }

    // @returns `Boolean` true if the `path` is NOT ignored

  }, {
    key: '_filter',
    value: function _filter(path) {
      if (!path) {
        return false;
      }

      if (path in this._cache) {
        return this._cache[path];
      }

      return this._cache[path] = this._test(path);
    }

    // @returns {Boolean} true if a file is NOT ignored

  }, {
    key: '_test',
    value: function _test(file) {
      var _this3 = this;

      file = file.split(SLASH).join(path.sep);
      var parentPath = cleanPath(path.dirname(file));
      var parentPathDirs = parentPath.split(path.sep);

      var matched = false;

      this._rules.forEach(function (rule) {
        var match = _this3._match(file, rule);

        if (!match && parentPath !== ".") {
          // Check to see if the pattern matches one of our parent dirs.
          if (rule.dirs.includes('**')) {
            // Ah shucks! We have to test every possible parent path that has 
            // a number of dirs _n_ where 
            // `rule.dirs.filter(doubleStar).length <= _n_ <= parentPathDirs.length`
            // since the ** can imply any number of directories including 0
            for (var i = rule.dirs.filter(function (x) {
              return x !== '**';
            }).length; i <= parentPathDirs.length; i++) {
              match = match || _this3._match(parentPathDirs.slice(0, i).join(path.sep), rule);
            }
          } else if (rule.dirs.length <= parentPathDirs.length) {
            // We can just test the parent path with the correct number of dirs
            // in the rule since, for a match to happen, rule.dirs.length HAS TO BE
            // EQUAL to the number of first in the parent path :D
            match = _this3._match(parentPathDirs.slice(0, rule.dirs.length).join(path.sep), rule);
          }
        }

        if (match) {
          matched = !rule.negative;
        }
      });

      return !matched;
    }

    // @returns {Boolean} true if a file is matched by a rule

  }, {
    key: '_match',
    value: function _match(file, rule) {
      return this._compile(rule).regexp.test(file);
    }
  }, {
    key: '_compile',
    value: function _compile(rule) {
      if (rule.regexp) {
        return rule;
      }

      var regStr = '^';

      // Go through the pattern and convert it to a regexp.
      var escapedSlash = path.sep === '\\' ? '\\\\' : path.sep;
      for (var i = 0; i < rule.pattern.length; i++) {
        var ch = rule.pattern[i];

        if (ch === '*') {
          if (rule.pattern[i + 1] === '*') {
            // is some flavor of "**"
            i++;

            // Treat **/ as ** so eat the "/"
            if (rule.pattern[i + 1] === escapedSlash) {
              i++;
            }

            if (rule.pattern[i + 1] === undefined) {
              // is "**EOF" - to align with .gitignore just accept all
              regStr += ".*";
            } else {
              // is "**"
              // Note that this allows for any # of /'s (even 0) because
              // the .* will eat everything, even /'s
              regStr += '(.*' + escapedSlash + ')?';
            }
          } else {
            // is "*" so map it to anything but "/"
            regStr += '[^' + escapedSlash + ']*';
          }
        } else if (ch === '?') {
          // "?" is any char except "/"
          regStr += '[^' + escapedSlash + ']';
        } else if (ch === '.' || ch === '$') {
          // Escape some regexp special chars that have no meaning
          // in golang's filepath.Match
          regStr += '\\' + ch;
        } else if (ch === '\\') {
          // escape next char. Note that a trailing \ in the pattern
          // will be left alone (but need to escape it)
          if (path.sep === '\\') {
            // On windows map "\" to "\\", meaning an escaped backslash,
            // and then just continue because filepath.Match on
            // Windows doesn't allow escaping at all
            regStr += escapedSlash;
            continue;
          }
          if (rule.pattern[i + 1] !== undefined) {
            regStr += '\\' + rule.pattern[i + 1];
            i++;
          } else {
            regStr += '\\';
          }
        } else {
          regStr += ch;
        }
      }

      regStr += "$";

      rule.regexp = new RegExp(regStr, 'i');
      return rule;
    }
  }]);

  return IgnoreBase;
}();

// A simple cache, because an ignore rule only has only one certain meaning


var cache = {};

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
// Detect `process` so that it can run in browsers.
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {

  var filter = IgnoreBase.prototype._filter;
  var make_posix = function make_posix(str) {
    return (/^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/')
    );
  };

  IgnoreBase.prototype._filter = function (path) {
    path = make_posix(path);
    return filter.call(this, path);
  };
}
