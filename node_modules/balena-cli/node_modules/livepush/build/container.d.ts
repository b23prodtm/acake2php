/// <reference types="node" />
import * as Docker from 'dockerode';
import { EventEmitter } from 'events';
import * as _ from 'lodash';
import * as Stream from 'stream';
import StrictEventEmitter from 'strict-event-emitter-types';
import ActionGroup from './action-group';
export interface StageContainers {
    [stageIdx: number]: Container;
}
export interface CommandExecutionContext {
    stdout: Stream.Readable;
    stderr: Stream.Readable;
    exec: Docker.Exec;
}
export interface CommandOutput {
    data: Buffer;
    isStderr: boolean;
}
export interface ContainerEvents {
    commandExecute: string;
    commandOutput: CommandOutput;
    commandReturn: {
        returnCode: number;
        command: string;
    };
    containerRestart: void;
}
declare type ContainerEventEmitter = StrictEventEmitter<EventEmitter, ContainerEvents>;
export interface ContainerConstructOpts {
    skipRestart?: boolean;
}
declare const Container_base: new () => ContainerEventEmitter;
export declare class Container extends Container_base {
    private buildContext;
    private docker;
    containerId: string;
    private cancelled;
    private buildArguments;
    private skipRestart;
    private constructor();
    static fromContainerId(buildContext: string, docker: Docker, containerId: string, opts?: ContainerConstructOpts): Container;
    static fromImage(buildContext: string, docker: Docker, imageId: string, opts?: ContainerConstructOpts): Promise<Container>;
    checkRunning(): Promise<boolean>;
    restartContainer(): Promise<void>;
    fetchPathFromContainer(path: string): Promise<Stream.Readable>;
    pathIsDirectory: ((path: string) => Promise<boolean>) & _.MemoizedFunction;
    executeActionGroups(actionGroups: ActionGroup[], addedOrUpdated: string[], deleted: string[], containers: StageContainers): Promise<void>;
    executeCommand(command: string[]): Promise<CommandExecutionContext>;
    cleanup(): Promise<void>;
    markCancelled(cancelled: boolean): void;
    setBuildArguments(buildArgs: Dictionary<string>): void;
    private requiresRestart;
    private runActionGroupCommand;
    private performStagedCopy;
    private addFiles;
    private deleteFiles;
    private getLocalOperations;
    private executeCommandDetached;
    static generateContainerCommand(command: string): string[];
    addFilesToContainer(tarStream: Stream.Readable, destination: string): Promise<void>;
    private getBuildArgsForDockerApi;
}
export default Container;
