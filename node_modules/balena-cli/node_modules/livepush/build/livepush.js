"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Livepush = void 0;
const bluebird_1 = require("bluebird");
const events_1 = require("events");
const _ = require("lodash");
const container_1 = require("./container");
const dockerfile_1 = require("./dockerfile");
const errors_1 = require("./errors");
class Livepush extends events_1.EventEmitter {
    constructor(dockerfile, containers) {
        super();
        this.dockerfile = dockerfile;
        this.containers = containers;
        this.livepushRunning = false;
        this.cancelRun = false;
        this.assignEventHandlers();
    }
    static init(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const dockerfile = 'dockerfileContent' in opts
                ? new dockerfile_1.default(opts.dockerfileContent)
                : opts.dockerfile;
            if (dockerfile == null) {
                throw new errors_1.InvalidArgumentError(`A Dockerfile instance or a Dockerfile content must be supplied`);
            }
            if (dockerfile.stages.length - 1 !== opts.stageImages.length) {
                const dStages = dockerfile.stages.length;
                const argStages = opts.stageImages.length;
                throw new errors_1.InvalidArgumentError(`Dockerfile with ${dStages} stages provided,` +
                    ` but ${argStages} image IDs passed to livepush constructor (there should be ${dStages -
                        1})`);
            }
            const containers = {};
            for (const [idx, stageImage] of opts.stageImages.entries()) {
                containers[idx] = yield container_1.default.fromImage(opts.context, opts.docker, stageImage, { skipRestart: true });
            }
            containers[dockerfile.stages.length - 1] = container_1.default.fromContainerId(opts.context, opts.docker, opts.containerId, {
                skipRestart: opts.skipContainerRestart || false,
            });
            return new Livepush(dockerfile, containers);
        });
    }
    performLivepush(addedOrUpdated, deleted) {
        return __awaiter(this, void 0, void 0, function* () {
            const tasks = this.dockerfile.getActionGroupsFromChangedFiles([
                ...addedOrUpdated,
                ...deleted,
            ]);
            if (this.livepushRunning) {
                yield this.cancel();
                while (this.cancelRun) {
                    yield bluebird_1.delay(1000);
                }
                _.each(this.containers, container => {
                    container.markCancelled(false);
                });
            }
            this.livepushRunning = true;
            try {
                const keys = _.keys(tasks).sort();
                for (const stageIdxStr of keys) {
                    const stageIdx = parseInt(stageIdxStr, 10);
                    const stageTasks = tasks[stageIdx];
                    if (this.cancelRun) {
                        break;
                    }
                    yield this.containers[stageIdx].executeActionGroups(stageTasks, addedOrUpdated, deleted, this.containers);
                }
            }
            finally {
                this.livepushRunning = false;
                this.cancelRun = false;
            }
        });
    }
    livepushNeeded(addedOrUpdated, deleted) {
        return !_.isEmpty(this.dockerfile.getActionGroupsFromChangedFiles([
            ...addedOrUpdated,
            ...deleted,
        ]));
    }
    cleanupIntermediateContainers() {
        return __awaiter(this, void 0, void 0, function* () {
            const stages = _.keys(this.containers);
            stages.pop();
            for (const stage of stages) {
                const stageIdx = parseInt(stage, 10);
                const container = this.containers[stageIdx];
                yield container.cleanup();
            }
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('cancel');
            this.cancelRun = true;
            _.each(this.containers, container => {
                container.markCancelled(true);
            });
        });
    }
    setBuildArgs(buildArgs) {
        _.each(this.containers, container => container.setBuildArguments(buildArgs));
    }
    assignEventHandlers() {
        _.each(this.containers, (container, stageIdxStr) => {
            const stageIdx = parseInt(stageIdxStr, 10);
            container.on('commandExecute', command => this.emit('commandExecute', { stageIdx, command }));
            container.on('commandOutput', output => this.emit('commandOutput', { stageIdx, output }));
            container.on('commandReturn', returnInfo => this.emit('commandReturn', Object.assign({ stageIdx }, returnInfo)));
        });
        const lastContainer = this.containers[this.dockerfile.stages.length - 1];
        lastContainer.on('containerRestart', () => this.emit('containerRestart', { containerId: lastContainer.containerId }));
    }
}
exports.Livepush = Livepush;
exports.default = Livepush;
//# sourceMappingURL=livepush.js.map