"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Bluebird = require("bluebird");
const events_1 = require("events");
const _ = require("lodash");
const mz_1 = require("mz");
const Path = require("path");
const escape = require("shell-escape");
const shell = require("shell-quote");
const Stream = require("stream");
const tar = require("tar-stream");
const action_group_1 = require("./action-group");
const errors_1 = require("./errors");
const stage_copy_1 = require("./stage-copy");
const util_1 = require("./util");
class Container extends events_1.EventEmitter {
    constructor(buildContext, docker, containerId, opts) {
        super();
        this.buildContext = buildContext;
        this.docker = docker;
        this.containerId = containerId;
        this.cancelled = false;
        this.buildArguments = {};
        this.skipRestart = false;
        this.pathIsDirectory = _.memoize((path) => __awaiter(this, void 0, void 0, function* () {
            const output = yield this.executeCommandDetached([
                '/usr/bin/test',
                '-d',
                path,
            ]);
            return output === 0;
        }));
        if (opts.skipRestart != null) {
            this.skipRestart = opts.skipRestart;
        }
    }
    static fromContainerId(buildContext, docker, containerId, opts = {}) {
        return new Container(buildContext, docker, containerId, opts);
    }
    static fromImage(buildContext, docker, imageId, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const container = yield docker.createContainer({
                Image: imageId,
                Entrypoint: ['/bin/sh', '-c', 'while true; do sleep 3600; done'],
            });
            yield container.start();
            return new Container(buildContext, docker, container.id, opts);
        });
    }
    checkRunning() {
        return __awaiter(this, void 0, void 0, function* () {
            const inspect = yield this.docker.getContainer(this.containerId).inspect();
            return inspect.State.Running === true;
        });
    }
    restartContainer() {
        return __awaiter(this, void 0, void 0, function* () {
            const container = this.docker.getContainer(this.containerId);
            yield container.kill();
            yield container.start();
        });
    }
    fetchPathFromContainer(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = yield this.docker
                .getContainer(this.containerId)
                .getArchive({ path });
            return stream;
        });
    }
    executeActionGroups(actionGroups, addedOrUpdated, deleted, containers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.checkRunning())) {
                throw new errors_1.ContainerNotRunningError();
            }
            for (const actionGroup of actionGroups) {
                if (actionGroup.dependentOnStage) {
                    yield this.performStagedCopy(actionGroup, containers);
                }
                else {
                    const toAdd = yield this.getLocalOperations(addedOrUpdated, actionGroup);
                    const toDelete = _.map(yield this.getLocalOperations(deleted, actionGroup), 'toPath');
                    yield this.addFiles(toAdd);
                    yield this.deleteFiles(toDelete);
                }
                for (const command of actionGroup.commands) {
                    if (this.cancelled) {
                        return;
                    }
                    const returnCode = yield this.runActionGroupCommand(command);
                    if (returnCode !== 0) {
                        return;
                    }
                }
            }
            if (!this.skipRestart && this.requiresRestart(actionGroups)) {
                this.emit('containerRestart');
                yield this.restartContainer();
            }
        });
    }
    executeCommand(command) {
        return __awaiter(this, void 0, void 0, function* () {
            const exec = yield this.docker.getContainer(this.containerId).exec({
                Cmd: command,
                Env: this.getBuildArgsForDockerApi(),
                AttachStderr: true,
                AttachStdout: true,
            });
            return yield new Promise((resolve, reject) => {
                exec.start({}, (err, stream) => {
                    if (err) {
                        return reject(err);
                    }
                    if (!stream) {
                        return reject(new Error('Stream is not provided'));
                    }
                    const stdout = new Stream.PassThrough();
                    const stderr = new Stream.PassThrough();
                    stream.on('error', reject);
                    stream.on('end', () => __awaiter(this, void 0, void 0, function* () {
                        stdout.end();
                        stderr.end();
                    }));
                    this.docker.modem.demuxStream(stream, stdout, stderr);
                    resolve({
                        exec,
                        stderr,
                        stdout,
                    });
                });
            });
        });
    }
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.docker.getContainer(this.containerId).remove({ force: true });
        });
    }
    markCancelled(cancelled) {
        this.cancelled = cancelled;
    }
    setBuildArguments(buildArgs) {
        this.buildArguments = buildArgs;
    }
    requiresRestart(actionGroups) {
        return _.some(actionGroups, 'restart');
    }
    runActionGroupCommand(command) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('commandExecute', command);
            const dockerCommand = Container.generateContainerCommand(command);
            const exe = yield this.executeCommand(dockerCommand);
            let exitCode;
            yield util_1.waitForCommandCompletion(exe, ev => {
                switch (ev.type) {
                    case util_1.CommandExecutionArtifactType.EXIT_CODE:
                        exitCode = ev.code;
                        this.emit('commandReturn', { returnCode: exitCode, command });
                        break;
                    case util_1.CommandExecutionArtifactType.STDERR_DATA:
                    case util_1.CommandExecutionArtifactType.STDOUT_DATA:
                        this.emit('commandOutput', {
                            data: ev.data,
                            isStderr: ev.type === util_1.CommandExecutionArtifactType.STDERR_DATA,
                        });
                        break;
                }
            });
            return exitCode;
        });
    }
    performStagedCopy(stage, containers) {
        return __awaiter(this, void 0, void 0, function* () {
            const container = containers[stage.stageDependency];
            if (container == null) {
                throw new errors_1.InternalInconsistencyError(`Attempt to copy from stage without a container given. StageIdx: ${stage.stageDependency}`);
            }
            for (const copy of stage.copies) {
                yield stage_copy_1.copyToStage(container, this, copy);
            }
        });
    }
    addFiles(operations) {
        return __awaiter(this, void 0, void 0, function* () {
            const pack = tar.pack();
            for (const operation of operations) {
                yield util_1.addFileToTarPack(pack, Path.join(this.buildContext, operation.fromPath), operation.toPath);
            }
            pack.finalize();
            yield this.addFilesToContainer(pack, '/');
        });
    }
    deleteFiles(files) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Bluebird.map(files, (f) => __awaiter(this, void 0, void 0, function* () {
                const command = ['/bin/rm', '-f', f];
                yield this.executeCommandDetached(command);
            }));
        });
    }
    getLocalOperations(files, actionGroup) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = action_group_1.getActionGroupFileFilter(actionGroup);
            const taskPromises = _(files)
                .filter(filter)
                .flatMap(f => {
                const copies = action_group_1.getAffectedLocalCopies(actionGroup, f);
                return copies.map(({ file, copy }) => __awaiter(this, void 0, void 0, function* () {
                    const destinationIsDirectory = _.endsWith(copy.dest, '/') ||
                        (yield this.pathIsDirectory(copy.dest));
                    const sourceIsDirectory = yield util_1.hostPathIsDirectory(Path.join(this.buildContext, file));
                    const realSource = Path.join(this.buildContext, copy.source);
                    let filepath = process.platform === 'win32' ? file.replace(/\\/g, '/') : file;
                    if (!sourceIsDirectory &&
                        copy.source !== filepath &&
                        (yield mz_1.fs.exists(realSource))) {
                        filepath = Path.posix.relative(copy.source, filepath);
                    }
                    const toPath = destinationIsDirectory
                        ? Path.posix.join(copy.dest, filepath)
                        : copy.dest;
                    return {
                        fromPath: file,
                        toPath,
                    };
                }));
            })
                .value();
            return Promise.all(taskPromises);
        });
    }
    executeCommandDetached(command) {
        return __awaiter(this, void 0, void 0, function* () {
            const exec = yield this.docker.getContainer(this.containerId).exec({
                Cmd: command,
                AttachStderr: true,
                AttachStdout: true,
            });
            return yield new Promise((resolve, reject) => {
                exec.start({}, (err, stream) => {
                    if (err) {
                        return reject(err);
                    }
                    if (!stream) {
                        return reject(new Error('Stream is not provided'));
                    }
                    stream.on('error', reject);
                    stream.on('end', () => __awaiter(this, void 0, void 0, function* () {
                        const inspect = yield exec.inspect();
                        resolve(inspect.ExitCode);
                    }));
                    stream.resume();
                });
            });
        });
    }
    static generateContainerCommand(command) {
        return shell.parse(escape(['/bin/sh', '-c', command])).map(entry => {
            if (!_.isString(entry)) {
                const entryObj = entry;
                if (entryObj.op != null) {
                    if (entryObj.op === 'glob') {
                        return entryObj.pattern;
                    }
                    else {
                        return entryObj.op;
                    }
                }
                return '';
            }
            return entry;
        });
    }
    addFilesToContainer(tarStream, destination) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                this.docker
                    .getContainer(this.containerId)
                    .putArchive(tarStream, { path: destination }, err => {
                    if (err) {
                        return reject(err);
                    }
                    resolve();
                });
            });
        });
    }
    getBuildArgsForDockerApi() {
        return _.map(this.buildArguments, (v, k) => `${k}=${v}`);
    }
}
exports.Container = Container;
exports.default = Container;
//# sourceMappingURL=container.js.map