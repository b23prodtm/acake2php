"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dockerfile = void 0;
const _ = require("lodash");
const path = require("path");
const dockerfile_parser_1 = require("./dockerfile-parser");
const errors_1 = require("./errors");
const stage_1 = require("./stage");
class Dockerfile {
    constructor(dockerfileContent, autoGenerateLiveDockerfile = true) {
        this.autoGenerateLiveDockerfile = autoGenerateLiveDockerfile;
        this.liveCmd = null;
        this.hasLiveAction = false;
        if (Buffer.isBuffer(dockerfileContent)) {
            dockerfileContent = dockerfileContent.toString();
        }
        this.parse(dockerfileContent);
    }
    getActionGroupsFromChangedFiles(files) {
        files = files.map(path.normalize);
        const stagedGroups = {};
        for (const [idx, stage] of this.stages.entries()) {
            const actionGroups = stage.getActionGroupsForChangedFiles(files);
            if (actionGroups.length > 0) {
                stagedGroups[idx] = actionGroups;
            }
        }
        const buildDependencyGraph = ([stageIdx, ...tail]) => {
            for (const stage of this.stages) {
                if (stage.index === stageIdx) {
                    continue;
                }
                if (_.includes(stage.dependentOnStages, stageIdx)) {
                    const invalidatedByStage = stage.getActionGroupsForChangedStage(stageIdx);
                    if (stagedGroups[stage.index] == null ||
                        stagedGroups[stage.index].length < invalidatedByStage.length) {
                        stagedGroups[stage.index] = invalidatedByStage;
                    }
                    tail = tail.concat(stage.index);
                }
            }
            if (tail.length === 0) {
                return;
            }
            buildDependencyGraph(tail);
        };
        buildDependencyGraph(_.map(stagedGroups, (_v, k) => parseInt(k, 10)));
        return stagedGroups;
    }
    generateLiveDockerfile() {
        if (!this.hasLiveAction) {
            return this.dockerfileContent;
        }
        if (this.liveDockerfile != null) {
            return this.liveDockerfile;
        }
        let foundLiveCmd = false;
        let liveDockerfile = '';
        for (const entry of this.parsedDockerfile) {
            if (entry.name === 'FROM') {
                if (!foundLiveCmd) {
                    liveDockerfile += `${entry.raw}\n`;
                }
                else {
                    break;
                }
            }
            else if (entry.name === 'RUN') {
                if (!foundLiveCmd) {
                    liveDockerfile += `${entry.raw}\n`;
                }
            }
            else if (entry.name === 'LIVECMD') {
                foundLiveCmd = true;
                liveDockerfile += '#livecmd-marker=1\n';
                liveDockerfile += `CMD ${entry.args}\n`;
            }
            else if (entry.name === 'LIVERUN') {
                liveDockerfile += `RUN ${entry.args}\n`;
            }
            else if (entry.name === 'LIVECOPY') {
                liveDockerfile += `COPY ${entry.args}\n`;
            }
            else if (entry.name === 'LIVEENV') {
                liveDockerfile += `ENV ${entry.args}\n`;
            }
            else if (entry.name === 'CMD') {
                if (!this.liveCmd) {
                    liveDockerfile += `${entry.raw}\n`;
                }
            }
            else {
                liveDockerfile += `${entry.raw}\n`;
            }
        }
        this.liveDockerfile = liveDockerfile;
        this.parse(liveDockerfile);
        return liveDockerfile;
    }
    parse(dockerfileContent) {
        this.dockerfileContent = dockerfileContent;
        const entries = dockerfile_parser_1.parseDockerfile(dockerfileContent).map(e => (Object.assign(Object.assign({}, e), { name: e.name.toUpperCase() })));
        this.parsedDockerfile = entries;
        this.stages = [];
        let currentStage = null;
        let stageIdx = 0;
        let causesRestart = true;
        for (const entry of entries) {
            switch (entry.name) {
                case 'FROM':
                    const args = entry.args;
                    const parts = args.split(' ');
                    if (parts.length === 1) {
                        currentStage = new stage_1.default(stageIdx);
                    }
                    else if (parts.length === 3 && parts[1].toUpperCase() === 'AS') {
                        currentStage = new stage_1.default(stageIdx, parts[2]);
                    }
                    else {
                        throw new errors_1.DockerfileParseError(`Could not parse FROM command on line ${entry.lineno}`);
                    }
                    this.stages.push(currentStage);
                    stageIdx++;
                    break;
                case 'COPY':
                    if (currentStage == null) {
                        throw new errors_1.DockerfileParseError('COPY outside of stage! (currentStage is not set)');
                    }
                    if (!_.isArray(entry.args)) {
                        throw new errors_1.DockerfileParseError(`Non-array arguments passed to COPY on line ${entry.lineno}`);
                    }
                    const [flags, copyArgs] = Dockerfile.removeFlags(entry.args);
                    if ('from' in flags) {
                        currentStage.addStageCopyStep(copyArgs, this.stageNameToIndex(flags.from), causesRestart);
                    }
                    else {
                        currentStage.addLocalCopyStep(copyArgs, causesRestart);
                    }
                    break;
                case 'ADD':
                    throw new errors_1.UnsupportedError('Dockerfiles containing the ADD instruction are not supported. Please use COPY.');
                case 'WORKDIR':
                    if (currentStage == null) {
                        throw new errors_1.DockerfileParseError('COPY outside of stage! (currentStage is not set)');
                    }
                    if (!_.isString(entry.args)) {
                        throw new errors_1.DockerfileParseError(`Non-string argument passed to WORKDIR on line ${entry.lineno}`);
                    }
                    currentStage.addWorkdirStep(entry.args, causesRestart);
                    break;
                case 'RUN':
                    if (currentStage == null) {
                        throw new errors_1.DockerfileParseError('COPY outside of stage! (currentStage is not set)');
                    }
                    currentStage.addCommandStep(Dockerfile.processRunArgs(entry.args));
                    break;
                case 'LIVECMD':
                    this.hasLiveAction = true;
                    if (this.liveCmd != null) {
                        throw new errors_1.DockerfileParseError('Only a single live cmd should be specified');
                    }
                    this.liveCmd = entry.args;
                    break;
                case 'LIVERUN':
                    this.hasLiveAction = true;
                    break;
                case 'LIVECOPY':
                    this.hasLiveAction = true;
                    break;
                case 'LIVECMD_MARKER':
                    this.hasLiveAction = true;
                    causesRestart = false;
                    currentStage === null || currentStage === void 0 ? void 0 : currentStage.liveCmdFound();
            }
        }
        this.stages.forEach(stage => {
            stage.finalize(causesRestart);
        });
        if (currentStage != null) {
            currentStage.isLast = true;
        }
        if (this.liveDockerfile == null && this.autoGenerateLiveDockerfile) {
            this.generateLiveDockerfile();
        }
    }
    stageNameToIndex(name) {
        const found = _.find(this.stages, { name });
        if (found != null) {
            return found.index;
        }
        const idx = parseInt(name, 10);
        if (isNaN(idx)) {
            throw new errors_1.DockerfileParseError(`Could not find stage with name: ${name}`);
        }
        return idx;
    }
    static processRunArgs(command) {
        if (_.isString(command)) {
            return command;
        }
        if (_.isArray(command)) {
            return command.join(' ');
        }
        throw new errors_1.DockerfileParseError('Object arguments not supported for RUN commands');
    }
    static removeFlags(args) {
        const [unparsedFlags, nonFlags] = _.partition(args, a => _.startsWith(a, '--'));
        return [
            _(unparsedFlags)
                .map(f => {
                const parts = f.split('=').filter(str => str.length > 0);
                if (parts.length < 2) {
                    throw new errors_1.DockerfileParseError(`Could not parse flag: ${f}`);
                }
                return [_.trimStart(parts[0], '-'), parts.slice(1).join('=')];
            })
                .fromPairs()
                .value(),
            nonFlags,
        ];
    }
}
exports.Dockerfile = Dockerfile;
exports.default = Dockerfile;
//# sourceMappingURL=dockerfile.js.map