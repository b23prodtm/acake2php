"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForCommandCompletion = exports.CommandExecutionArtifactType = exports.addFileToTarPack = exports.hostPathIsDirectory = exports.resolveFileLocations = exports.streamToBuffer = void 0;
const _ = require("lodash");
const mz_1 = require("mz");
const Path = require("path");
const errors_1 = require("./errors");
function streamToBuffer(stream) {
    return new Promise((resolve, reject) => {
        const bufs = [];
        stream.on('data', d => bufs.push(d));
        stream.on('error', reject);
        stream.on('end', () => resolve(Buffer.concat(bufs)));
    });
}
exports.streamToBuffer = streamToBuffer;
function resolveFileLocations(files, destination, container) {
    return __awaiter(this, void 0, void 0, function* () {
        const isDir = yield container.pathIsDirectory(destination);
        if (!isDir) {
            if (files.length > 1) {
                throw new errors_1.RuntimeError(`Unable to copy multiple files to a single file location`);
            }
            return [
                {
                    localSource: files[0],
                    containerPath: destination,
                },
            ];
        }
        return files.map(f => {
            const name = Path.basename(f);
            const containerPath = Path.join(destination, name);
            return {
                localSource: f,
                containerPath,
            };
        });
    });
}
exports.resolveFileLocations = resolveFileLocations;
exports.hostPathIsDirectory = _.memoize((path) => __awaiter(void 0, void 0, void 0, function* () {
    const stat = yield mz_1.fs.lstat(path);
    return stat.isDirectory();
}));
function addFileToTarPack(pack, path, destination) {
    return __awaiter(this, void 0, void 0, function* () {
        const stat = yield mz_1.fs.stat(path);
        pack.entry({ name: destination, size: stat.size, mode: stat.mode }, yield mz_1.fs.readFile(path));
    });
}
exports.addFileToTarPack = addFileToTarPack;
var CommandExecutionArtifactType;
(function (CommandExecutionArtifactType) {
    CommandExecutionArtifactType[CommandExecutionArtifactType["EXIT_CODE"] = 0] = "EXIT_CODE";
    CommandExecutionArtifactType[CommandExecutionArtifactType["STDOUT_DATA"] = 1] = "STDOUT_DATA";
    CommandExecutionArtifactType[CommandExecutionArtifactType["STDERR_DATA"] = 2] = "STDERR_DATA";
})(CommandExecutionArtifactType = exports.CommandExecutionArtifactType || (exports.CommandExecutionArtifactType = {}));
function waitForCommandCompletion(executionContext, cb) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            executionContext.stdout.on('data', data => cb({ type: CommandExecutionArtifactType.STDOUT_DATA, data }));
            executionContext.stderr.on('data', data => cb({ type: CommandExecutionArtifactType.STDERR_DATA, data }));
            executionContext.stdout.on('end', () => __awaiter(this, void 0, void 0, function* () {
                const inspect = yield executionContext.exec.inspect();
                cb({
                    type: CommandExecutionArtifactType.EXIT_CODE,
                    code: inspect.ExitCode,
                });
                resolve();
            }));
            executionContext.stderr.on('error', reject);
            executionContext.stdout.on('error', reject);
        });
    });
}
exports.waitForCommandCompletion = waitForCommandCompletion;
//# sourceMappingURL=util.js.map