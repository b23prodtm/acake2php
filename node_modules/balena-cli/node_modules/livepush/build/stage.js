"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stage = void 0;
const _ = require("lodash");
const path = require("path");
const action_group_1 = require("./action-group");
const errors_1 = require("./errors");
class Stage {
    constructor(index, name = index.toString()) {
        this.index = index;
        this.name = name;
        this.dependentOnStages = [];
        this.isLast = false;
        this.actionGroups = [
            {
                dependentOnStage: false,
                commands: [],
                copies: [],
                workdir: '/',
                restart: true,
            },
        ];
        this.lastStepWasCopy = false;
        this.lastWorkdir = '/';
        this.ungroupedCommands = [];
    }
    addLocalCopyStep(args, restartRequired) {
        const lastActionGroup = _.last(this.actionGroups);
        if (args.length < 2) {
            throw new errors_1.DockerfileParseError('Minimum two arguments to COPY instruction!');
        }
        const checkedArgs = args;
        if (this.canAddCopyToGroup(false)) {
            if (lastActionGroup.dependentOnStage) {
                throw new errors_1.InternalInconsistencyError('Attempt to add stage copy to local copy action group!');
            }
            const localActionGroup = lastActionGroup;
            localActionGroup.copies = localActionGroup.copies.concat(this.copyArgsToCopies(checkedArgs, localActionGroup));
        }
        else {
            lastActionGroup.commands = lastActionGroup.commands.concat(this.ungroupedCommands);
            const actionGroup = {
                dependentOnStage: false,
                commands: [],
                copies: [],
                workdir: this.lastWorkdir,
                restart: restartRequired,
            };
            actionGroup.copies = this.copyArgsToCopies(checkedArgs, actionGroup);
            this.actionGroups.push(actionGroup);
            this.ungroupedCommands = [];
        }
        this.lastStepWasCopy = true;
    }
    addStageCopyStep(args, stageIdx, restartRequired) {
        const lastActionGroup = _.last(this.actionGroups);
        if (args.length < 2) {
            throw new errors_1.DockerfileParseError('Minimum two arguments to COPY instruction!');
        }
        const checkedArgs = args;
        if (this.canAddCopyToGroup(true, stageIdx)) {
            if (!lastActionGroup.dependentOnStage) {
                throw new Error('Attempt to add local copy to stage copy action group!');
            }
            lastActionGroup.copies = lastActionGroup.copies.concat(this.copyArgsToCopies(checkedArgs, lastActionGroup).map(copy => (Object.assign({ sourceStage: stageIdx }, copy))));
        }
        else {
            lastActionGroup.commands = lastActionGroup.commands.concat(this.ungroupedCommands);
            const actionGroup = {
                dependentOnStage: true,
                commands: [],
                stageDependency: stageIdx,
                copies: [],
                workdir: this.lastWorkdir,
                restart: restartRequired,
            };
            actionGroup.copies = this.copyArgsToCopies(checkedArgs, actionGroup).map(copy => (Object.assign({ sourceStage: stageIdx }, copy)));
            this.actionGroups.push(actionGroup);
            this.ungroupedCommands = [];
        }
        this.lastStepWasCopy = true;
        this.dependentOnStages = _.uniq(this.dependentOnStages.concat(stageIdx));
    }
    addCommandStep(command) {
        this.ungroupedCommands.push(command);
        this.lastStepWasCopy = false;
    }
    addWorkdirStep(workdir, restartRequired) {
        const actionGroup = _.last(this.actionGroups);
        actionGroup.commands = actionGroup.commands.concat(this.ungroupedCommands);
        this.actionGroups.push({
            copies: [],
            dependentOnStage: false,
            commands: [],
            workdir,
            restart: restartRequired,
        });
        this.lastWorkdir = workdir;
        this.ungroupedCommands = [];
        this.lastStepWasCopy = false;
    }
    finalize(restart) {
        const actionGroup = _.last(this.actionGroups);
        if (actionGroup.restart !== restart) {
            this.actionGroups.push({
                dependentOnStage: false,
                commands: this.ungroupedCommands,
                copies: [],
                restart,
                workdir: this.lastWorkdir,
            });
        }
        else {
            actionGroup.commands = actionGroup.commands.concat(this.ungroupedCommands);
        }
        this.actionGroups = _.reject(this.actionGroups, ag => ag.commands.length === 0 && ag.copies.length === 0);
    }
    getActionGroupsForChangedFiles(files) {
        for (const [idx, actionGroup] of this.actionGroups.entries()) {
            if (actionGroup.dependentOnStage) {
                continue;
            }
            const matches = action_group_1.fileMatchesForActionGroup(files, actionGroup);
            if (matches.length > 0) {
                return this.actionGroups.slice(idx);
            }
        }
        return [];
    }
    getActionGroupsForChangedStage(stageIdx) {
        for (const [idx, actionGroup] of this.actionGroups.entries()) {
            if (!actionGroup.dependentOnStage) {
                continue;
            }
            if (actionGroup.stageDependency === stageIdx) {
                return this.actionGroups.slice(idx);
            }
        }
        return [];
    }
    liveCmdFound() {
        this.lastStepWasCopy = false;
    }
    canAddCopyToGroup(dependentOnStage, stageIdx) {
        if (this.lastStepWasCopy) {
            const actionGroup = _.last(this.actionGroups);
            if (dependentOnStage) {
                return (actionGroup.dependentOnStage &&
                    actionGroup.stageDependency === stageIdx);
            }
            return !actionGroup.dependentOnStage;
        }
        return false;
    }
    copyArgsToCopies(args, actionGroup) {
        let dest = args.pop();
        if (!path.isAbsolute(dest)) {
            dest = path.posix.join(actionGroup.workdir, dest);
        }
        return args.map(source => {
            const normalized = path.posix.normalize(source);
            return {
                source: normalized,
                dest,
            };
        });
    }
}
exports.Stage = Stage;
exports.default = Stage;
//# sourceMappingURL=stage.js.map