"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveFileDestination = exports.copyToStage = void 0;
const _ = require("lodash");
const path = require("path");
const tar = require("tar-stream");
const container_1 = require("./container");
const errors_1 = require("./errors");
const util_1 = require("./util");
function copyToStage(source, dest, copy) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield source.pathIsDirectory(copy.source)) {
            yield copyDirToStage(source, dest, copy);
        }
        else {
            yield copyFileToStage(source, dest, copy);
        }
    });
}
exports.copyToStage = copyToStage;
function copyDirToStage(source, dest, copy) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(yield dest.pathIsDirectory(copy.dest))) {
            throw new errors_1.InternalInconsistencyError(`Attempt to copy directory into non-directory destination from stage copy: destination: ${copy.dest}`);
        }
        const sourceStream = yield source.fetchPathFromContainer(copy.source);
        const extract = tar.extract();
        const pack = tar.pack();
        yield new Promise((resolve, reject) => {
            extract.on('entry', (headers, stream, next) => __awaiter(this, void 0, void 0, function* () {
                if (headers.type !== 'file' && headers.type !== 'directory') {
                    stream.on('end', next);
                    stream.resume();
                }
                else {
                    const name = resolveFileDestination(copy.source, copy.dest, headers.name);
                    pack.entry(Object.assign(Object.assign({}, headers), { name }), yield util_1.streamToBuffer(stream), err => {
                        if (err) {
                            reject(err);
                        }
                        next();
                    });
                }
            }));
            extract.on('finish', () => {
                pack.finalize();
                resolve();
            });
            sourceStream.pipe(extract);
        });
        yield dest.addFilesToContainer(pack, '/');
    });
}
function copyFileToStage(source, dest, copy) {
    return __awaiter(this, void 0, void 0, function* () {
        const context = yield source.executeCommand(container_1.Container.generateContainerCommand(`cat ${copy.source}`));
        const permissionContext = yield source.executeCommand(container_1.Container.generateContainerCommand(`stat -c %a ${copy.source}`));
        const buf = yield util_1.streamToBuffer(context.stdout);
        const permissions = (yield util_1.streamToBuffer(permissionContext.stdout))
            .toString()
            .trim();
        let destination = (yield dest.pathIsDirectory(copy.dest))
            ? `${copy.dest}/${path.basename(copy.source)}`
            : copy.dest;
        if (!_.startsWith(destination, '/')) {
            throw new errors_1.InternalInconsistencyError(`Attempt to copy non-absolute file from stage: destination: ${destination}`);
        }
        destination = destination.replace('/', '');
        const pack = tar.pack();
        yield new Promise((resolve, reject) => {
            pack.entry({ name: destination, mode: parseInt(permissions, 8) }, buf, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
        pack.finalize();
        yield dest.addFilesToContainer(pack, '/');
    });
}
function resolveFileDestination(source, dest, pathInTar) {
    const sourceParts = source.split('/').filter(p => p !== '');
    let pathParts = pathInTar.split('/').filter(p => p !== '');
    if (sourceParts[sourceParts.length - 1] === pathParts[0]) {
        pathParts = pathParts.slice(1);
    }
    return path.join(dest, pathParts.join('/'));
}
exports.resolveFileDestination = resolveFileDestination;
//# sourceMappingURL=stage-copy.js.map