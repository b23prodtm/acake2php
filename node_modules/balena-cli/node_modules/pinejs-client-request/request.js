"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinejsClientRequest = exports.StatusError = void 0;
const pinejs_client_core_1 = require("pinejs-client-core");
const request = require("request");
const typed_error_1 = require("typed-error");
const requestAsync = (opts) => new Promise((resolve, reject) => {
    request(opts, (err, response) => {
        if (err) {
            reject(err);
            return;
        }
        resolve(response);
    });
});
class StatusError extends typed_error_1.TypedError {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
    }
}
exports.StatusError = StatusError;
const validParams = ['cache'];
class PinejsClientRequest extends pinejs_client_core_1.PinejsClientCore {
    constructor(params, backendParams) {
        super(params);
        this.backendParams = {};
        if (backendParams != null && typeof backendParams === 'object') {
            for (const validParam of validParams) {
                if (backendParams.hasOwnProperty(validParam)) {
                    this.backendParams[validParam] = backendParams[validParam];
                }
            }
        }
        if (this.backendParams.cache != null) {
            const LRU = require('lru-cache');
            this.cache = new LRU(this.backendParams.cache);
        }
    }
    async _request(params) {
        if (params.gzip == null) {
            params.gzip = true;
        }
        if (params.timeout == null) {
            params.timeout = 59000;
        }
        if (params.strictSSL == null) {
            params.strictSSL = true;
        }
        params.json = true;
        if (this.cache != null && params.method === 'GET') {
            let cached = this.cache.get(params.url);
            if (cached != null) {
                if (params.headers == null) {
                    params.headers = {};
                }
                params.headers['If-None-Match'] = cached.etag;
            }
            const { statusCode, body, headers } = await requestAsync(params);
            if (statusCode === 304 && cached != null) {
            }
            else if (200 <= statusCode && statusCode < 300) {
                cached = {
                    etag: headers.etag,
                    body,
                };
            }
            else {
                throw new StatusError(body, statusCode);
            }
            this.cache.set(params.url, cached);
            const { cloneDeep } = require('lodash');
            return cloneDeep(cached.body);
        }
        else {
            const { statusCode, body } = await requestAsync(params);
            if (200 <= statusCode && statusCode < 300) {
                return body;
            }
            throw new StatusError(body, statusCode);
        }
    }
}
exports.PinejsClientRequest = PinejsClientRequest;
//# sourceMappingURL=request.js.map