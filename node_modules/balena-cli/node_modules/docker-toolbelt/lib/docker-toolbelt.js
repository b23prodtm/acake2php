// Generated by CoffeeScript 1.12.7
(function() {
  var Docker, DockerToolbelt, EEXIST, MIN_PAGE_SIZE, Promise, aufsMountWithDisposer, createChainId, createChainIdFromParent, crypto, es, execAsync, fs, getAllChainIds, getCacheId, getDiffIds, getDigest, getRandomFileName, ignore, overlay2MountWithDisposer, path, pathPrefixRemover, randomstring, semver, sha256sum, tar, usesContentAddressableFormat,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  crypto = require('crypto');

  Promise = require('bluebird');

  Docker = require('dockerode');

  semver = require('balena-semver');

  tar = require('tar-stream');

  es = require('event-stream');

  fs = Promise.promisifyAll(require('fs'));

  path = require('path');

  randomstring = require('randomstring');

  execAsync = Promise.promisify(require('child_process').exec);

  module.exports = DockerToolbelt = (function(superClass) {
    extend(DockerToolbelt, superClass);

    function DockerToolbelt(opts) {
      if (opts == null) {
        opts = {};
      }
      opts.Promise = Promise;
      DockerToolbelt.__super__.constructor.call(this, opts);
    }

    return DockerToolbelt;

  })(Docker);

  sha256sum = function(data) {
    var hash;
    hash = crypto.createHash('sha256');
    hash.update(data);
    return hash.digest('hex');
  };

  getDigest = function(data) {
    return 'sha256:' + sha256sum(data);
  };

  createChainId = function(diffIds) {
    return createChainIdFromParent('', diffIds);
  };

  getAllChainIds = function(diffIds) {
    var chainIds, i, j, ref;
    chainIds = [diffIds[0]];
    for (i = j = 0, ref = diffIds.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      chainIds.push(createChainIdFromParent(chainIds[i], [diffIds[i + 1]]));
    }
    return chainIds;
  };

  createChainIdFromParent = function(parent, dgsts) {
    var dgst;
    if (dgsts.length === 0) {
      return parent;
    }
    if (parent === '') {
      return createChainIdFromParent(dgsts[0], dgsts.slice(1));
    }
    dgst = getDigest(parent + ' ' + dgsts[0]);
    return createChainIdFromParent(dgst, dgsts.slice(1));
  };

  getDiffIds = Promise.method(function(dkroot, driver, imageId) {
    var hash, hashType, ref;
    ref = imageId.split(':'), hashType = ref[0], hash = ref[1];
    return fs.readFileAsync(path.join(dkroot, "image/" + driver + "/imagedb/content", hashType, hash)).then(JSON.parse).get('rootfs').get('diff_ids');
  });

  getCacheId = Promise.method(function(dkroot, driver, layerId) {
    var cacheIdPath, hash, hashType, ref;
    ref = layerId.split(':'), hashType = ref[0], hash = ref[1];
    cacheIdPath = path.join(dkroot, "image/" + driver + "/layerdb", hashType, hash, 'cache-id');
    return fs.readFileAsync(cacheIdPath, {
      encoding: 'utf8'
    });
  });

  getRandomFileName = function(imageId) {
    return "tmp-" + (imageId.split(':')[1]) + "-" + (randomstring.generate(8));
  };

  usesContentAddressableFormat = function(version) {
    return !(semver.valid(version) && semver.lt(version, '1.10.0'));
  };

  DockerToolbelt.prototype.imageRootDir = function(image) {
    return Promise.join(this.info(), this.version().get('Version'), this.getImage(image).inspect(), function(dockerInfo, dockerVersion, imageInfo) {
      var dkroot, imageId;
      dkroot = dockerInfo.DockerRootDir;
      imageId = imageInfo.Id;
      return Promise["try"](function() {
        if (!usesContentAddressableFormat(dockerVersion)) {
          return imageId;
        }
        return getDiffIds(dkroot, dockerInfo.Driver, imageId).then(function(diffIds) {
          var layerId;
          layerId = createChainId(diffIds);
          return getCacheId(dkroot, dockerInfo.Driver, layerId);
        });
      }).then(function(destId) {
        switch (dockerInfo.Driver) {
          case 'btrfs':
            return path.join(dkroot, 'btrfs/subvolumes', destId);
          case 'overlay':
            return imageInfo.GraphDriver.Data.RootDir;
          case 'overlay2':
            return imageInfo.GraphDriver.Data.UpperDir;
          case 'vfs':
            return path.join(dkroot, 'vfs/dir', destId);
          case 'aufs':
            return path.join(dkroot, 'aufs/diff', destId);
          default:
            throw new Error("Unsupported driver: " + dockerInfo.Driver + "/");
        }
      });
    });
  };

  EEXIST = {
    code: 'EEXIST'
  };

  ignore = function() {};

  MIN_PAGE_SIZE = 4096;

  pathPrefixRemover = function(prefix) {
    return function(path) {
      var slice;
      slice = path.substr(prefix.length);
      if (("" + prefix + slice) === path) {
        return slice;
      } else {
        return path;
      }
    };
  };

  overlay2MountWithDisposer = function(fsRoot, target, lowers, diffDir, workDir) {
    if (!lowers) {
      return Promise.resolve(diffDir);
    }
    return fs.mkdirAsync(target)["catch"](EEXIST, ignore).then(function() {
      var makeRelative, options;
      options = "lowerdir=" + lowers + ",upperdir=" + diffDir + ",workdir=" + workDir;
      if (options.length < MIN_PAGE_SIZE) {
        return [void 0, lowers, diffDir, workDir];
      }
      makeRelative = pathPrefixRemover(path.join(fsRoot, path.sep));
      return Promise.map(lowers.split(':'), function(lower) {
        var layerId, linkPath;
        layerId = makeRelative(lower).replace(/\/diff$/, '');
        linkPath = path.join(fsRoot, layerId, 'link');
        return fs.readFileAsync(linkPath).then(function(link) {
          return path.join('l', link.toString());
        });
      }).then(function(lowers) {
        return [fsRoot, lowers.join(':'), makeRelative(diffDir), makeRelative(workDir)];
      });
    }).then(function(arg) {
      var diffDir, fsRoot, lowers, options, workDir;
      fsRoot = arg[0], lowers = arg[1], diffDir = arg[2], workDir = arg[3];
      options = "lowerdir=" + lowers + ",upperdir=" + diffDir + ",workdir=" + workDir;
      return execAsync("mount -t overlay overlay -o '" + options + "' " + target, {
        cwd: fsRoot
      });
    })["return"](target).disposer(function(target) {
      return execAsync("umount " + target).then(function() {
        return fs.rmdirAsync(target);
      })["catch"](function(err) {
        console.error('Failed to clean up after mounting overlay2', err, err.stack);
      });
    });
  };

  aufsMountWithDisposer = function(target, layerDiffPaths) {
    return fs.mkdirAsync(target)["catch"](EEXIST, ignore).then(function() {
      var appendFromIndex, appendLayerPaths, options, remainingBytes;
      options = 'noxino,ro,br=';
      remainingBytes = MIN_PAGE_SIZE - options.length;
      layerDiffPaths = layerDiffPaths.map(function(path) {
        return path + "=ro+wh";
      });
      appendFromIndex = layerDiffPaths.findIndex(function(path) {
        remainingBytes -= path.length + 1;
        return remainingBytes < -1;
      });
      if (appendFromIndex === -1) {
        appendFromIndex = layerDiffPaths.length;
      }
      appendLayerPaths = layerDiffPaths.slice(appendFromIndex);
      options += layerDiffPaths.slice(0, appendFromIndex).join(':');
      return execAsync("mount -t aufs -o '" + options + "' none " + target).then(function() {
        return Promise.mapSeries(appendLayerPaths, function(path) {
          return execAsync("mount -t aufs -o 'remount,append:" + path + "' none " + target);
        });
      });
    })["return"](target).disposer(function(target) {
      return execAsync("umount " + target).then(function() {
        return fs.rmdirAsync(target);
      })["catch"](function(err) {
        console.error('Failed to clean up after mounting aufs', err, err.stack);
      });
    });
  };

  DockerToolbelt.prototype.imageRootDirMounted = function(image) {
    return Promise.join(this.info(), this.version().get('Version'), this.getImage(image).inspect(), (function(_this) {
      return function(dockerInfo, dockerVersion, imageInfo) {
        var LowerDir, UpperDir, WorkDir, dkroot, driver, imageId, mountDir, ref, rootDir;
        driver = dockerInfo.Driver;
        dkroot = dockerInfo.DockerRootDir;
        imageId = imageInfo.Id;
        if (driver === 'aufs') {
          return _this.diffPaths(image).then(function(layerDiffPaths) {
            var mountDir;
            mountDir = path.join(dkroot, 'aufs/mnt', getRandomFileName(imageId));
            return aufsMountWithDisposer(mountDir, layerDiffPaths);
          });
        } else if (driver === 'overlay2') {
          rootDir = path.join(dkroot, 'overlay2');
          mountDir = path.join(rootDir, getRandomFileName(imageId));
          ref = imageInfo.GraphDriver.Data, LowerDir = ref.LowerDir, UpperDir = ref.UpperDir, WorkDir = ref.WorkDir;
          return overlay2MountWithDisposer(rootDir, mountDir, LowerDir, UpperDir, WorkDir);
        } else {
          return _this.imageRootDir(image);
        }
      };
    })(this));
  };

  DockerToolbelt.prototype.diffPaths = function(image) {
    return Promise.join(this.info(), this.version().get('Version'), this.getImage(image).inspect(), function(dockerInfo, dockerVersion, imageInfo) {
      var dkroot, driver, imageId;
      driver = dockerInfo.Driver;
      if (driver !== 'aufs' && driver !== 'overlay2') {
        throw new Error('diffPaths can only be used on aufs and overlay2');
      }
      dkroot = dockerInfo.DockerRootDir;
      imageId = imageInfo.Id;
      return getDiffIds(dkroot, driver, imageId).then(function(diffIds) {
        if (!usesContentAddressableFormat(dockerVersion)) {
          return diffIds;
        }
        return Promise.map(getAllChainIds(diffIds), function(layerId) {
          return getCacheId(dkroot, driver, layerId);
        });
      }).call('reverse').map(function(layerId) {
        switch (driver) {
          case 'aufs':
            return path.join(dkroot, 'aufs/diff', layerId);
          case 'overlay2':
            return path.join(dkroot, 'overlay2', layerId, 'diff');
        }
      });
    });
  };

  DockerToolbelt.prototype.aufsDiffPaths = DockerToolbelt.prototype.diffPaths;

  DockerToolbelt.prototype.createEmptyImage = function(imageConfig) {
    var layer, manifest;
    manifest = [
      {
        Config: 'config.json',
        RepoTags: null,
        Layers: ['0000/layer.tar']
      }
    ];
    layer = tar.pack();
    layer.entry({
      name: 'seed'
    }, String(Date.now() + Math.random()));
    layer.finalize();
    return Promise.fromCallback(function(callback) {
      return layer.pipe(es.wait(callback));
    }).then((function(_this) {
      return function(buf) {
        var config, image, imageId, layerConfig, now;
        now = (new Date()).toISOString();
        config = {
          config: imageConfig,
          created: now,
          rootfs: {
            type: 'layers',
            diff_ids: [getDigest(buf)]
          }
        };
        imageId = sha256sum(JSON.stringify(config));
        layerConfig = {
          id: imageId,
          created: now,
          config: imageConfig
        };
        image = tar.pack();
        image.entry({
          name: 'manifest.json'
        }, JSON.stringify(manifest));
        image.entry({
          name: 'config.json'
        }, JSON.stringify(config));
        image.entry({
          name: '0000/VERSION'
        }, '1.0');
        image.entry({
          name: '0000/json'
        }, JSON.stringify(layerConfig));
        image.entry({
          name: '0000/layer.tar'
        }, buf);
        image.finalize();
        return _this.loadImage(image).then(function(stream) {
          return Promise.fromCallback(function(callback) {
            return stream.pipe(es.wait(callback));
          });
        })["return"](imageId);
      };
    })(this));
  };

  DockerToolbelt.prototype.createDeltaAsync = function(src, dest, onProgress) {
    var optsf;
    optsf = {
      path: '/images/delta?',
      method: 'POST',
      options: {
        src: src,
        dest: dest
      },
      isStream: true,
      statusCodes: {
        200: true,
        404: 'no such image',
        500: 'server error'
      }
    };
    return Promise.fromCallback((function(_this) {
      return function(cb) {
        return _this.modem.dial(optsf, cb);
      };
    })(this)).then((function(_this) {
      return function(stream) {
        return Promise.fromCallback(function(cb) {
          return _this.modem.followProgress(stream, cb, function(e) {
            var match;
            if (typeof onProgress === "function") {
              onProgress(e);
            }
            if ((match = /^Created delta: (sha256:\w+)$/.exec(e.status))) {
              return cb(null, match[1]);
            }
          });
        });
      };
    })(this));
  };

  DockerToolbelt.prototype.getRegistryAndName = Promise.method(function(image) {
    var digest, digestMatch, imageName, j, match, registry, tagName;
    match = image.match(/^(?:(localhost|.*?[.:].*?)\/)?(.+?)(?::(.*?))?(?:@(.*?))?$/);
    if (match == null) {
      throw new Error("Could not parse the image: " + image);
    }
    j = match.length - 4, registry = match[j++], imageName = match[j++], tagName = match[j++], digest = match[j++];
    if ((digest == null) && (tagName == null)) {
      tagName = 'latest';
    }
    digestMatch = digest != null ? digest.match(/^[A-Za-z][A-Za-z0-9]*(?:[-_+.][A-Za-z][A-Za-z0-9]*)*:[0-9a-f-A-F]{32,}$/) : void 0;
    if (!imageName || digest && !digestMatch) {
      throw new Error('Invalid image name, expected [domain.tld/]repo/image[:tag][@digest] format');
    }
    return {
      registry: registry,
      imageName: imageName,
      tagName: tagName,
      digest: digest
    };
  });

  DockerToolbelt.prototype.compileRegistryAndName = Promise.method(function(arg) {
    var digest, imageName, ref, ref1, registry, tagName;
    registry = (ref = arg.registry) != null ? ref : '', imageName = arg.imageName, tagName = (ref1 = arg.tagName) != null ? ref1 : '', digest = arg.digest;
    if (registry !== '') {
      registry += '/';
    }
    if (digest == null) {
      if (tagName === '') {
        tagName = 'latest';
      }
      return "" + registry + imageName + ":" + tagName;
    } else {
      return "" + registry + imageName + "@" + digest;
    }
  });

  DockerToolbelt.prototype.normaliseImageName = Promise.method(function(image) {
    return this.getRegistryAndName(image).then(this.compileRegistryAndName);
  });

}).call(this);
