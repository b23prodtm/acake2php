"use strict";
/*
 * Copyright 2018 balena.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const bluebird_1 = require("bluebird");
const _ = require("lodash");
const partitioninfo_1 = require("partitioninfo");
const resin_image_fs_1 = require("resin-image-fs");
const configure_1 = require("./operations/configure");
const copy_1 = require("./operations/copy");
const PARTITION_FIELDS = ['partition', 'to.partition', 'from.partition'];
const MBR_LAST_PRIMARY_PARTITION = 4;
const ACTIONS = {
    configure: configure_1.execute,
    copy: copy_1.execute,
};
const executeOperation = (operation, disk) => __awaiter(void 0, void 0, void 0, function* () {
    return yield ACTIONS[operation.command](operation, disk);
});
const getPartitionIndex = (partition) => {
    // New device-type.json partition format: partition index
    if (typeof partition === 'number') {
        return partition;
    }
    // Old device-type.json partition format: { primary: 4, logical: 1 }
    if (typeof partition.logical === 'number') {
        return partition.logical + MBR_LAST_PRIMARY_PARTITION;
    }
    // Old device-type.json partition format: { primary: 4 }
    if (typeof partition.primary === 'number') {
        return partition.primary;
    }
    throw new Error(`Invalid partition: ${partition}`);
};
const getDiskDeviceType = (disk) => __awaiter(void 0, void 0, void 0, function* () {
    const partitions = yield partitioninfo_1.getPartitions(disk);
    for (const partition of partitions.partitions) {
        if (partition.type === 14) {
            const deviceType = yield bluebird_1.using(resin_image_fs_1.interact(disk, partition.index), (fs) => __awaiter(void 0, void 0, void 0, function* () {
                return yield fs
                    .readFileAsync('/device-type.json')
                    .catchReturn(undefined);
            }));
            if (deviceType) {
                return JSON.parse(deviceType.toString());
            }
        }
    }
});
exports.configure = (disk, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
    console.log('options', options);
    const deviceType = yield getDiskDeviceType(disk);
    console.log('device type read from disk image:\n', JSON.stringify(deviceType, null, 4));
    let operations = _.cloneDeep(_.get(deviceType, 'configuration.operations', []));
    const config = _.get(deviceType, 'configuration.config');
    if (config) {
        operations.push({
            command: 'configure',
            partition: config.partition,
            data: options.config,
        });
    }
    operations = operations.filter((operation) => {
        if (_.isObject(operation.when)) {
            for (const key in operation.when) {
                if (options[key] !== operations.when[key]) {
                    return false;
                }
            }
        }
        return true;
    });
    for (const operation of operations) {
        for (const field of PARTITION_FIELDS) {
            const partition = _.get(operation, field);
            if (partition) {
                _.set(operation, field, getPartitionIndex(partition));
            }
        }
        yield executeOperation(operation, disk);
    }
});
//# sourceMappingURL=configure.js.map