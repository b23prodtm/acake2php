"use strict";
/*
 * Copyright 2018 balena.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const bluebird_1 = require("bluebird");
const udif_1 = require("udif");
const source_destination_1 = require("./source-destination");
const source_source_1 = require("./source-source");
const errors_1 = require("../errors");
const shared_1 = require("../sparse-stream/shared");
const stream_limiter_1 = require("../stream-limiter");
class DmgSource extends source_source_1.SourceSource {
    constructor(source) {
        super(source);
        this.image = new udif_1.Image('', { fs: new source_destination_1.SourceDestinationFs(source) });
    }
    canCreateReadStream() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    canCreateSparseReadStream() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    createReadStream(_emitProgress = false, start = 0, end) {
        return __awaiter(this, void 0, void 0, function* () {
            if (start !== 0) {
                throw new errors_1.NotCapable();
            }
            const stream = yield this.image.createReadStream();
            if (end !== undefined) {
                const transform = new stream_limiter_1.StreamLimiter(stream, end + 1);
                return transform;
            }
            return stream;
        });
    }
    createSparseReadStream(_generateChecksums) {
        return __awaiter(this, void 0, void 0, function* () {
            return Object.assign(this.image.createSparseReadStream(), {
                blocks: yield this.getBlocks(),
            });
        });
    }
    getBlocks() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const blk of this.image.resourceFork.blkx) {
                const childBlocks = blk.map.blocks.filter(b => DmgSource.mappedBlockTypes.includes(b.type));
                if (childBlocks.length === 0) {
                    continue;
                }
                let checksumType;
                let checksum;
                if (blk.map.checksum.type === udif_1.CHECKSUM_TYPE.CRC32) {
                    checksumType = 'crc32';
                    checksum = blk.map.checksum.value;
                }
                const blocks = [];
                result.push({ checksumType, checksum, blocks });
                let lastBlock;
                for (const childBlk of childBlocks) {
                    const offset = (blk.map.sectorNumber + childBlk.sectorNumber) * udif_1.SECTOR_SIZE;
                    const length = childBlk.sectorCount * udif_1.SECTOR_SIZE;
                    if (lastBlock === undefined) {
                        // First iteration of the loop
                        lastBlock = { offset, length };
                    }
                    else if (lastBlock.offset + lastBlock.length === offset) {
                        // Last block and this block are adjacent, increase last block's length
                        lastBlock.length += length;
                    }
                    else {
                        // Last block and this block are not adjacent:
                        blocks.push(lastBlock);
                        lastBlock = { offset, length };
                    }
                }
                // ! because we know lastBlock can't be undefined
                blocks.push(lastBlock);
            }
            return result;
        });
    }
    _getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            const blocks = yield this.getBlocks();
            const blockmappedSize = shared_1.blocksLength(blocks);
            const compressedSize = (yield this.source.getMetadata()).size;
            const size = this.image.getUncompressedSize();
            return { blocks, blockmappedSize, compressedSize, size };
        });
    }
    _open() {
        const _super = Object.create(null, {
            _open: { get: () => super._open }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super._open.call(this);
            yield bluebird_1.promisify(this.image.open).bind(this.image)();
        });
    }
    _close() {
        const _super = Object.create(null, {
            _close: { get: () => super._close }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield bluebird_1.promisify(this.image.close).bind(this.image)();
            yield _super._close.call(this);
        });
    }
}
exports.DmgSource = DmgSource;
DmgSource.mappedBlockTypes = [
    udif_1.BLOCK.RAW,
    udif_1.BLOCK.UDCO,
    udif_1.BLOCK.UDZO,
    udif_1.BLOCK.UDBZ,
    udif_1.BLOCK.LZFSE,
];
DmgSource.requiresRandomReadableSource = true;
DmgSource.mimetype = 'application/x-apple-diskimage';
source_destination_1.SourceDestination.register(DmgSource);
//# sourceMappingURL=dmg.js.map