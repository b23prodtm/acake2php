"use strict";
/*
 * Copyright 2018 balena.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const errors_1 = require("../errors");
const stream_limiter_1 = require("../stream-limiter");
const source_source_1 = require("./source-source");
function isSourceTransform(stream) {
    return stream.sourceStream !== undefined;
}
exports.isSourceTransform = isSourceTransform;
function getRootStream(stream) {
    while (isSourceTransform(stream)) {
        stream = stream.sourceStream;
    }
    return stream;
}
exports.getRootStream = getRootStream;
class CompressedSource extends source_source_1.SourceSource {
    constructor() {
        super(...arguments);
        this.isSizeEstimated = false;
    }
    getSize() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    canCreateReadStream() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    createReadStream(emitProgress = false, start = 0, end) {
        return __awaiter(this, void 0, void 0, function* () {
            if (start !== 0) {
                throw new errors_1.NotCapable();
            }
            const stream = yield this.source.createReadStream(emitProgress);
            // as any because we need to add the sourceStream property
            const transform = this.createTransform();
            stream.pipe(transform);
            transform.sourceStream = stream;
            if (end !== undefined) {
                const limiter = new stream_limiter_1.StreamLimiter(transform, end + 1);
                limiter.sourceStream = transform;
                limiter.on('finish', () => {
                    // Ignore EBADF errors after this:
                    // We might be still reading the source stream from a closed fd
                    stream.on('error', (err) => {
                        if (err.code !== 'EBADF') {
                            throw err;
                        }
                    });
                });
                return limiter;
            }
            return transform;
        });
    }
    _getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceMetadata = yield this.source.getMetadata();
            const compressedSize = sourceMetadata.compressedSize || sourceMetadata.size;
            const size = yield this.getSize();
            let name;
            if (sourceMetadata.name !== undefined) {
                name = path_1.basename(sourceMetadata.name, path_1.extname(sourceMetadata.name));
            }
            return {
                name,
                size,
                compressedSize,
                isSizeEstimated: this.isSizeEstimated,
            };
        });
    }
}
exports.CompressedSource = CompressedSource;
//# sourceMappingURL=compressed-source.js.map