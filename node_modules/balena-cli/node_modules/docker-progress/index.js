// Generated by CoffeeScript 1.12.7
(function() {
  var BalenaProgressReporter, DEFAULT_PROGRESS_BAR_STEP_COUNT, Docker, DockerProgress, JSONStream, LEGACY_DOCKER_VERSION, ProgressReporter, ProgressTracker, Promise, _, awaitRegistryStream, isBalenaEngine, legacy, onProgressHandler, renderProgress, semver, tryExtractDigestHash,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('lodash');

  semver = require('semver');

  Promise = require('bluebird');

  Docker = require('docker-toolbelt');

  JSONStream = require('JSONStream');

  legacy = require('./legacy');

  exports.RegistryV1 = legacy.RegistryV1;

  exports.RegistryV2 = legacy.RegistryV2;

  LEGACY_DOCKER_VERSION = '1.10.0';

  DEFAULT_PROGRESS_BAR_STEP_COUNT = 50;

  tryExtractDigestHash = function(evt) {
    var matchPull;
    if ((evt.aux != null) && (evt.aux.Digest != null)) {
      return evt.aux.Digest;
    }
    if (_.isString(evt.status)) {
      matchPull = evt.status.match(/^Digest:\s([a-zA-Z0-9]+:[a-f0-9]+)$/);
      if (matchPull != null) {
        return matchPull[1];
      }
    }
  };

  awaitRegistryStream = function(stream, onProgress, ignoreErrorEvents) {
    var contentHash;
    contentHash = null;
    return new Promise(function(resolve, reject) {
      var jsonStream;
      jsonStream = JSONStream.parse();
      jsonStream.on('data', function(evt) {
        var error, maybeContent;
        if (typeof evt !== 'object') {
          return;
        }
        try {
          if (evt.error && !ignoreErrorEvents) {
            throw new Error(evt.error);
          }
          maybeContent = tryExtractDigestHash(evt);
          if (maybeContent != null) {
            contentHash = maybeContent;
          }
          return onProgress(evt);
        } catch (error1) {
          error = error1;
          stream.destroy(error);
          return reject(error);
        }
      });
      jsonStream.on('error', reject);
      jsonStream.on('end', function() {
        return resolve(contentHash);
      });
      return stream.pipe(jsonStream);
    });
  };

  isBalenaEngine = function(versionInfo) {
    var ref;
    return (ref = versionInfo['Engine']) === 'balena' || ref === 'balaena' || ref === 'balena-engine';
  };

  renderProgress = function(percentage, stepCount) {
    var bar, barCount, spaceCount;
    percentage = _.clamp(percentage, 0, 100);
    barCount = Math.floor(stepCount * percentage / 100);
    spaceCount = stepCount - barCount;
    bar = "[" + (_.repeat('=', barCount)) + ">" + (_.repeat(' ', spaceCount)) + "]";
    return bar + " " + percentage + "%";
  };

  onProgressHandler = function(onProgressPromise, fallbackOnProgress) {
    var evts, handlePreviousEvents, onProgress;
    evts = [];
    onProgress = function(evt) {
      return evts.push(evt);
    };
    handlePreviousEvents = function(onProgress) {
      _.map(evts, function(evt) {
        try {
          return onProgress(evt);
        } catch (error1) {}
      });
      return evts = [];
    };
    onProgressPromise.then(function(resolvedOnProgress) {
      onProgress = resolvedOnProgress;
      return handlePreviousEvents(resolvedOnProgress);
    })["catch"](function(e) {
      console.warn('error', e);
      onProgress = fallbackOnProgress;
      return handlePreviousEvents(fallbackOnProgress);
    });
    return function(evt) {
      return onProgress(evt);
    };
  };

  ProgressTracker = (function() {
    function ProgressTracker(coalesceBelow) {
      this.coalesceBelow = coalesceBelow != null ? coalesceBelow : 0;
      this.layers = {};
    }

    ProgressTracker.prototype.addLayer = function(id) {
      return this.layers[id] = {
        progress: null,
        coalesced: false
      };
    };

    ProgressTracker.prototype.linkLayer = function(id, tracker) {
      return this.layers[id] = tracker.layers[id];
    };

    ProgressTracker.prototype.updateLayer = function(id, progress) {
      if (id == null) {
        return;
      }
      if (!this.layers[id]) {
        this.addLayer(id);
      }
      this.patchProgressEvent(progress);
      this.layers[id].coalesced = (this.layers[id].progress == null) && progress.total < this.coalesceBelow;
      return this.layers[id].progress = (progress.current / progress.total) || 0;
    };

    ProgressTracker.prototype.finishLayer = function(id) {
      return this.updateLayer(id, {
        current: 1,
        total: 1
      });
    };

    ProgressTracker.prototype.getProgress = function() {
      var avgProgress, layers;
      layers = _.filter(this.layers, {
        coalesced: false
      });
      avgProgress = _.meanBy(layers, 'progress') || 0;
      return Math.round(100 * avgProgress);
    };

    ProgressTracker.prototype.patchProgressEvent = function(progress) {
      if (progress.total == null) {
        progress.total = progress.current;
      }
      return progress.current = Math.min(progress.current, progress.total);
    };

    return ProgressTracker;

  })();

  ProgressReporter = (function() {
    function ProgressReporter(renderProgress1) {
      this.renderProgress = renderProgress1;
    }

    ProgressReporter.prototype.checkProgressError = function(error, extraInfo) {
      var prefix, ref;
      prefix = "Progress error: [" + extraInfo + "]";
      console.warn(prefix, (ref = error.message) != null ? ref : error);
      error.message = prefix + " " + error.message;
      throw error;
    };

    ProgressReporter.prototype.pullProgress = Promise.method(function(image, onProgress) {
      var downloadProgressTracker, extractionProgressTracker, lastPercentage, progressRenderer;
      progressRenderer = this.renderProgress;
      downloadProgressTracker = new ProgressTracker(100 * 1024);
      extractionProgressTracker = new ProgressTracker(1024 * 1024);
      lastPercentage = 0;
      return (function(_this) {
        return function(evt) {
          var downloadedPercentage, err, extractedPercentage, id, percentage, status;
          try {
            id = evt.id, status = evt.status;
            if (id == null) {
              id = '';
            }
            if (status == null) {
              status = '';
            }
            if (status === 'Pulling fs layer') {
              downloadProgressTracker.addLayer(id);
              extractionProgressTracker.addLayer(id);
            } else if (status === 'Ready to download') {
              downloadProgressTracker.linkLayer(id, extractionProgressTracker);
            } else if (status === 'Downloading') {
              downloadProgressTracker.updateLayer(id, evt.progressDetail);
            } else if (status === 'Extracting') {
              extractionProgressTracker.updateLayer(id, evt.progressDetail);
            } else if (status === 'Download complete') {
              downloadProgressTracker.finishLayer(id);
            } else if (status === 'Pull complete') {
              extractionProgressTracker.finishLayer(id);
            } else if (status === 'Already exists') {
              downloadProgressTracker.finishLayer(id);
              extractionProgressTracker.finishLayer(id);
            }
            if (status.startsWith('Status: Image is up to date for ') || status.startsWith('Status: Downloaded newer image for ')) {
              downloadedPercentage = 100;
              extractedPercentage = 100;
            } else {
              downloadedPercentage = downloadProgressTracker.getProgress();
              extractedPercentage = extractionProgressTracker.getProgress();
            }
            percentage = Math.floor((downloadedPercentage + extractedPercentage) / 2);
            percentage = lastPercentage = Math.max(percentage, lastPercentage);
            return onProgress(_.merge(evt, {
              percentage: percentage,
              downloadedPercentage: downloadedPercentage,
              extractedPercentage: extractedPercentage,
              totalProgress: progressRenderer(percentage)
            }));
          } catch (error1) {
            err = error1;
            return _this.checkProgressError(err, "pull id=" + id + " status=" + status);
          }
        };
      })(this);
    });

    ProgressReporter.prototype.pushProgress = Promise.method(function(image, onProgress) {
      var lastPercentage, progressRenderer, progressTracker;
      progressRenderer = this.renderProgress;
      progressTracker = new ProgressTracker(100 * 1024);
      lastPercentage = 0;
      return (function(_this) {
        return function(evt) {
          var err, id, percentage, pushMatch, status;
          try {
            id = evt.id, status = evt.status;
            pushMatch = /Image (.*) already pushed/.exec(status);
            if (id == null) {
              id = pushMatch != null ? pushMatch[1] : void 0;
            }
            if (status == null) {
              status = '';
            }
            if (status === 'Preparing') {
              progressTracker.addLayer(id);
            } else if (status === 'Pushing' && (evt.progressDetail.current != null)) {
              progressTracker.updateLayer(id, evt.progressDetail);
            } else if (_.includes(['Pushed', 'Layer already exists', 'Image already exists'], status) || /^Mounted from /.test(status)) {
              progressTracker.finishLayer(id);
            } else if ((pushMatch != null) || _.includes(['Already exists', 'Image successfully pushed'], status)) {
              progressTracker.finishLayer(id);
            }
            percentage = status.search(/.+: digest: /) === 0 || status.startsWith('Pushing tag for rev ') ? 100 : progressTracker.getProgress();
            percentage = lastPercentage = Math.max(percentage, lastPercentage);
            return onProgress(_.merge(evt, {
              id: id,
              percentage: percentage,
              totalProgress: progressRenderer(percentage)
            }));
          } catch (error1) {
            err = error1;
            return _this.checkProgressError(err, "push id=" + id + " status=" + status);
          }
        };
      })(this);
    });

    return ProgressReporter;

  })();

  BalenaProgressReporter = (function(superClass) {
    extend(BalenaProgressReporter, superClass);

    function BalenaProgressReporter() {
      return BalenaProgressReporter.__super__.constructor.apply(this, arguments);
    }

    BalenaProgressReporter.prototype.pullProgress = Promise.method(function(image, onProgress) {
      var lastPercentage, progressRenderer;
      progressRenderer = this.renderProgress;
      lastPercentage = 0;
      return (function(_this) {
        return function(evt) {
          var current, err, id, percentage, ref, total;
          try {
            id = evt.id;
            if (id !== 'Total') {
              return;
            }
            ref = evt.progressDetail, current = ref.current, total = ref.total;
            percentage = Math.floor(current * 100 / total);
            percentage = lastPercentage = Math.max(percentage, lastPercentage);
            return onProgress(_.merge(evt, {
              percentage: percentage,
              downloadedPercentage: current,
              extractedPercentage: current,
              totalProgress: progressRenderer(percentage)
            }));
          } catch (error1) {
            err = error1;
            return _this.checkProgressError(err, "balena pull id=" + id);
          }
        };
      })(this);
    });

    return BalenaProgressReporter;

  })(ProgressReporter);

  exports.DockerProgress = DockerProgress = (function() {
    function DockerProgress(opts) {
      var ref;
      if (opts == null) {
        opts = {};
      }
      if (!(this instanceof DockerProgress)) {
        return new DockerProgress(opts);
      }
      if (opts.dockerToolbelt != null) {
        if (!_.isFunction(opts.dockerToolbelt.getRegistryAndName) || (((ref = opts.dockerToolbelt.modem) != null ? ref.Promise : void 0) == null)) {
          throw new Error('Invalid dockerToolbelt option, please use an instance of docker-toolbelt v3.0.1 or higher');
        }
        this.docker = opts.dockerToolbelt;
      } else {
        this.docker = new Docker(opts);
      }
      this.reporter = null;
    }

    DockerProgress.prototype.getProgressRenderer = function(stepCount) {
      if (stepCount == null) {
        stepCount = DEFAULT_PROGRESS_BAR_STEP_COUNT;
      }
      return function(percentage) {
        return renderProgress(percentage, stepCount);
      };
    };

    DockerProgress.prototype.getProgressReporter = function() {
      var docker, renderer;
      if (this.reporter != null) {
        return this.reporter;
      }
      docker = this.docker;
      renderer = this.getProgressRenderer();
      return this.reporter = docker.version().then(function(res) {
        var version;
        version = res['Version'];
        if (isBalenaEngine(res)) {
          return new BalenaProgressReporter(renderer);
        } else if (semver.valid(version) && semver.lt(version, LEGACY_DOCKER_VERSION)) {
          return new legacy.ProgressReporter(renderer, docker);
        } else {
          return new ProgressReporter(renderer);
        }
      });
    };

    DockerProgress.prototype.aggregateProgress = function(count, onProgress) {
      var renderer, states;
      renderer = this.getProgressRenderer();
      states = _.times(count, function() {
        return {
          percentage: 0
        };
      });
      return _.times(count, function(index) {
        return function(evt) {
          var percentage;
          states[index].percentage = evt.percentage;
          percentage = Math.floor(_.sumBy(states, 'percentage') / (states.length || 1));
          evt.totalProgress = renderer(percentage);
          evt.percentage = percentage;
          evt.progressIndex = index;
          return onProgress(evt);
        };
      });
    };

    DockerProgress.prototype.pull = function(image, onProgress, options, callback) {
      var ignoreErrorEvents, onProgressPromise;
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      ignoreErrorEvents = !!(options != null ? options.ignoreProgressErrorEvents : void 0);
      onProgressPromise = this.pullProgress(image, onProgress);
      onProgress = onProgressHandler(onProgressPromise, onProgress);
      return this.docker.pull(image, options).then(function(stream) {
        return awaitRegistryStream(stream, onProgress, ignoreErrorEvents);
      }).nodeify(callback);
    };

    DockerProgress.prototype.push = function(image, onProgress, options, callback) {
      var ignoreErrorEvents, onProgressPromise;
      ignoreErrorEvents = !!(options != null ? options.ignoreProgressErrorEvents : void 0);
      onProgressPromise = this.pushProgress(image, onProgress);
      onProgress = onProgressHandler(onProgressPromise, onProgress);
      return this.docker.getImage(image).push(options).then(function(stream) {
        return awaitRegistryStream(stream, onProgress, ignoreErrorEvents);
      }).nodeify(callback);
    };

    DockerProgress.prototype.pullProgress = function(image, onProgress) {
      return this.getProgressReporter().then(function(reporter) {
        return reporter.pullProgress(image, onProgress);
      });
    };

    DockerProgress.prototype.pushProgress = function(image, onProgress) {
      return this.getProgressReporter().then(function(reporter) {
        return reporter.pushProgress(image, onProgress);
      });
    };

    DockerProgress.prototype.getRegistryAndName = function(image) {
      return legacy.getRegistryAndName(this.docker, image);
    };

    DockerProgress.prototype.getLayerDownloadSizes = function(image) {
      return legacy.getLayerDownloadSizes(this.docker, image);
    };

    DockerProgress.prototype.getImageLayerSizes = function(image) {
      return legacy.getImageLayerSizes(this.docker, image);
    };

    return DockerProgress;

  })();

}).call(this);
