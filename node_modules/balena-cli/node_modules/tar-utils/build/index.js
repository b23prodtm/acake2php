"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multicastStream = exports.cloneTarStream = exports.pipePromise = exports.drainStream = exports.streamToBuffer = exports.normalizeTarEntry = void 0;
const Bluebird = require("bluebird");
const path = require("path");
const tar = require("tar-stream");
function noop() {
}
function normalizeTarEntry(name) {
    if (!name) {
        return '';
    }
    return path.posix.normalize(name).replace(/^\/+|\/+$/g, '') || '.';
}
exports.normalizeTarEntry = normalizeTarEntry;
function streamToBuffer(stream) {
    let onData;
    let onError;
    let onEnd;
    return new Bluebird((resolve, reject) => {
        const chunks = [];
        stream.on('end', (onEnd = () => resolve(chunks)));
        stream.on('error', (onError = reject));
        stream.on('data', (onData = (data) => chunks.push(data)));
    })
        .then(Buffer.concat)
        .finally(() => {
        stream.removeListener('data', onData || noop);
        stream.removeListener('error', onError || noop);
        stream.removeListener('end', onEnd || noop);
    });
}
exports.streamToBuffer = streamToBuffer;
function drainStream(stream) {
    let onError;
    let onEnd;
    return new Bluebird((resolve, reject) => {
        stream.on('error', (onError = reject));
        stream.on('end', (onEnd = resolve));
        stream.resume();
    }).finally(() => {
        stream.removeListener('error', onError || noop);
        stream.removeListener('end', onEnd || noop);
    });
}
exports.drainStream = drainStream;
function pipePromise(pipeFrom, pipeTo) {
    let onError;
    let onFinish;
    return new Bluebird((resolve, reject) => {
        pipeFrom.on('error', (onError = reject));
        pipeTo.on('error', onError);
        pipeTo.on('finish', (onFinish = () => resolve(pipeTo)));
        pipeFrom.pipe(pipeTo);
    }).finally(() => {
        pipeFrom.removeListener('error', onError || noop);
        pipeTo.removeListener('error', onError || noop);
        pipeTo.removeListener('finish', onFinish || noop);
    });
}
exports.pipePromise = pipePromise;
function cloneTarStream(sourceTarStream, opts) {
    const extract = tar.extract();
    const pack = tar.pack();
    const origPush = pack.push;
    pack.push = function () {
        origPush.apply(this, arguments);
        return true;
    };
    let packOnError;
    let sourceTarStreamOnError;
    return new Bluebird((resolve, reject) => {
        packOnError = reject;
        sourceTarStreamOnError = reject;
        sourceTarStream.on('error', sourceTarStreamOnError);
        pack.on('error', packOnError);
        extract.on('error', reject);
        extract.on('entry', (header, stream, callback) => {
            if (opts && opts.onEntry) {
                Bluebird.try(() => opts.onEntry(pack, header, stream)).then(callback, callback);
            }
            else {
                streamToBuffer(stream).then(buf => {
                    pack.entry(header, buf, callback);
                });
            }
        });
        extract.once('finish', () => {
            Bluebird.try(() => {
                if (opts && opts.onFinish) {
                    return opts.onFinish(pack);
                }
            })
                .then(() => {
                pack.finalize();
                resolve(pack);
            })
                .catch(reject);
        });
        sourceTarStream.pipe(extract);
    }).finally(() => {
        sourceTarStream.removeListener('error', sourceTarStreamOnError || noop);
        pack.removeListener('error', packOnError || noop);
    });
}
exports.cloneTarStream = cloneTarStream;
function multicastStream(fromStream, toStreams) {
    if (toStreams.length === 0) {
        return Bluebird.resolve();
    }
    let onError;
    return new Bluebird((resolve, reject) => {
        Bluebird.all(toStreams.map((toStream) => {
            let onFinish;
            return new Bluebird(toStreamResolve => toStream.on('finish', (onFinish = toStreamResolve))).finally(() => toStream.removeListener('finish', onFinish || noop));
        }))
            .then(() => resolve())
            .catch(reject);
        fromStream.on('error', (onError = reject));
        for (const toStream of toStreams) {
            toStream.on('error', onError);
            fromStream.pipe(toStream);
        }
    }).finally(() => {
        fromStream.removeListener('error', onError || noop);
        toStreams.forEach(toStream => toStream.removeListener('error', onError || noop));
    });
}
exports.multicastStream = multicastStream;
//# sourceMappingURL=index.js.map