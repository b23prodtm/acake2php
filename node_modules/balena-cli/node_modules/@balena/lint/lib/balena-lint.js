"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lint = void 0;
const fs_1 = require("fs");
const glob = require("glob");
const optimist = require("optimist");
const path = require("path");
const tslint = require("tslint");
const util_1 = require("util");
const exists = async (filename) => {
    try {
        await fs_1.promises.access(filename);
        return true;
    }
    catch (_a) {
        return false;
    }
};
const globAsync = util_1.promisify(glob);
const configurations = {
    coffeescript: {
        configPath: path.join(__dirname, '../config/coffeelint.json'),
        configFileName: 'coffeelint.json',
        extensions: ['coffee'],
        lang: 'coffeescript',
    },
    typescript: {
        configPath: path.join(__dirname, '../config/tslint.json'),
        configFileName: 'tslint.json',
        extensions: ['ts', 'tsx'],
        lang: 'typescript',
    },
    typescriptPrettier: {
        configPath: path.join(__dirname, '../config/tslint-prettier.json'),
        configFileName: 'tslint.json',
        extensions: ['ts', 'tsx'],
        lang: 'typescript',
    },
};
const prettierConfigPath = path.join(__dirname, '../config/.prettierrc');
const getPackageJsonDir = async (dir) => {
    const name = await findFile('package.json', dir);
    if (name === null) {
        throw new Error('Could not find package.json!');
    }
    return path.dirname(name);
};
const read = async (filepath) => {
    const realPath = await fs_1.promises.realpath(filepath);
    return fs_1.promises.readFile(realPath, 'utf8');
};
const findFile = async (name, dir) => {
    dir = dir || process.cwd();
    const filename = path.join(dir, name);
    if (await exists(filename)) {
        return filename;
    }
    const parent = path.dirname(dir);
    if (dir === parent) {
        return null;
    }
    return findFile(name, parent);
};
const parseJSON = async (file) => {
    try {
        return JSON.parse(await fs_1.promises.readFile(file, 'utf8'));
    }
    catch (err) {
        console.error(`Could not parse ${file}`);
        throw err;
    }
};
const findFiles = async (extensions, paths = []) => {
    const files = [];
    await Promise.all(paths.map(async (p) => {
        if ((await fs_1.promises.stat(p)).isDirectory()) {
            files.push(...(await globAsync(`${p}/**/*.@(${extensions.join('|')})`)));
        }
        else {
            files.push(p);
        }
    }));
    return files.map((p) => path.join(p));
};
const lintCoffeeFiles = async (files, config) => {
    const coffeelint = require('coffeelint');
    const errorReport = new coffeelint.getErrorReport();
    await Promise.all(files.map(async (file) => {
        const source = await read(file);
        errorReport.lint(file, source, config);
    }));
    const reporter = require('coffeelint/lib/reporters/default');
    const report = new reporter(errorReport, {
        colorize: process.stdout.isTTY,
        quiet: false,
    });
    report.publish();
    return errorReport.getExitCode();
};
const lintTsFiles = async function (files, config, prettierConfig, autoFix) {
    const prettier = prettierConfig ? await Promise.resolve().then(() => require('prettier')) : undefined;
    const linter = new tslint.Linter({
        fix: autoFix,
        formatter: 'stylish',
    });
    const exitCodes = await Promise.all(files.map(async (file) => {
        var _a, _b, _c, _d;
        let source = await read(file);
        const previousFixCount = (_b = (_a = linter.getResult().fixes) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        linter.lint(file, source, config);
        if (prettier) {
            const afterFixCount = (_d = (_c = linter.getResult().fixes) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
            if (previousFixCount !== afterFixCount) {
                source = await read(file);
            }
            if (autoFix) {
                const newSource = prettier.format(source, prettierConfig);
                if (source !== newSource) {
                    source = newSource;
                    await fs_1.promises.writeFile(file, source);
                }
            }
            else {
                const isPrettified = prettier.check(source, prettierConfig);
                if (!isPrettified) {
                    console.log(`Error: File ${file} hasn't been formatted with prettier`);
                    return 1;
                }
            }
        }
        return 0;
    }));
    const failureCode = exitCodes.find((exitCode) => exitCode !== 0);
    if (failureCode) {
        return failureCode;
    }
    const errorReport = linter.getResult();
    console.log(linter.getResult().output);
    return errorReport.errorCount === 0 ? 0 : 1;
};
const lintMochaTestFiles = async function (files) {
    const { lintMochaTests } = await Promise.resolve().then(() => require('./mocha-tests-lint'));
    const res = await lintMochaTests(files);
    if (res.isError) {
        console.error('Mocha tests check FAILED!');
        console.error(res.message);
        return 1;
    }
    return 0;
};
const runLint = async function (lintConfig, paths, config, autoFix) {
    let linterExitCode;
    const scripts = await findFiles(lintConfig.extensions, paths);
    if (lintConfig.lang === 'typescript') {
        let prettierConfig;
        if (lintConfig.prettierCheck) {
            prettierConfig = (await parseJSON(prettierConfigPath));
            prettierConfig.parser = 'typescript';
        }
        linterExitCode = await lintTsFiles(scripts, config, prettierConfig, autoFix);
    }
    if (lintConfig.lang === 'coffeescript') {
        linterExitCode = await lintCoffeeFiles(scripts, config);
    }
    if (lintConfig.testsCheck) {
        const testsExitCode = await lintMochaTestFiles(scripts);
        if (linterExitCode === 0) {
            linterExitCode = testsExitCode;
        }
    }
    process.on('exit', () => process.exit(linterExitCode));
};
exports.lint = async (passedParams) => {
    const options = optimist(passedParams)
        .usage('Usage: balena-lint [options] [...]')
        .describe('f', 'Specify a linting config file to extend and override balena-lint rules')
        .describe('p', 'Print default balena-lint linting rules')
        .describe('i', 'Ignore linting config files in project directory and its parents')
        .describe('e', 'Override extensions to check, eg "-e js -e jsx"')
        .boolean('typescript', 'Lint typescript files instead of coffeescript')
        .boolean('fix', 'Attempt to automatically fix lint errors')
        .boolean('no-prettier', 'Disables the prettier code format checks')
        .boolean('tests', 'Treat input files as test sources to perform extra relevant checks')
        .boolean('u', 'Run unused import check');
    if (options.argv._.length < 1 && !options.argv.p) {
        options.showHelp();
        process.exit(1);
    }
    if (options.argv.u) {
        const depcheck = await Promise.resolve().then(() => require('depcheck'));
        await Promise.all(options.argv._.map(async (dir) => {
            dir = await getPackageJsonDir(dir);
            const { dependencies } = await depcheck(path.resolve('./', dir), {
                ignoreMatches: [
                    '@types/*',
                    'supervisor',
                    'coffee-script',
                    'coffeescript',
                    'colors',
                    'coffeescope2',
                ],
            });
            if (dependencies.length > 0) {
                console.log(`${dependencies.length} unused dependencies:`);
                for (const dep of dependencies) {
                    console.log(`\t${dep}`);
                }
                process.exit(1);
            }
            console.log('No unused dependencies!');
            console.log();
        }));
    }
    let configOverridePath;
    const prettierCheck = options.argv.prettier !== false;
    const testsCheck = options.argv.tests === true;
    const typescriptCheck = options.argv.typescript;
    const autoFix = options.argv.fix === true;
    const lintConfiguration = typescriptCheck
        ? prettierCheck
            ? configurations.typescriptPrettier
            : configurations.typescript
        : configurations.coffeescript;
    if (options.argv.e) {
        lintConfiguration.extensions = Array.isArray(options.argv.e)
            ? options.argv.e
            : [options.argv.e];
    }
    if (options.argv.p) {
        console.log(await fs_1.promises.readFile(lintConfiguration.configPath, 'utf8'));
        process.exit(0);
    }
    let config = typescriptCheck
        ? tslint.Configuration.loadConfigurationFromPath(lintConfiguration.configPath)
        : await parseJSON(lintConfiguration.configPath);
    if (options.argv.f) {
        configOverridePath = await fs_1.promises.realpath(options.argv.f);
    }
    if (!options.argv.i && !configOverridePath) {
        configOverridePath = await findFile(lintConfiguration.configFileName);
    }
    if (configOverridePath) {
        if (typescriptCheck) {
            const configOverride = tslint.Configuration.loadConfigurationFromPath(configOverridePath);
            config = tslint.Configuration.extendConfigurationFile(config, configOverride);
        }
        else {
            const configOverride = await parseJSON(configOverridePath);
            const { merge } = await Promise.resolve().then(() => require('lodash'));
            config = merge(config, configOverride);
        }
    }
    const paths = options.argv._;
    lintConfiguration.prettierCheck = prettierCheck;
    lintConfiguration.testsCheck = testsCheck;
    await runLint(lintConfiguration, paths, config, autoFix);
};
//# sourceMappingURL=balena-lint.js.map