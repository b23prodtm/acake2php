"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const DockerfileTemplate = require("dockerfile-template");
const utils_1 = require("../utils");
const dockerfileTemplate_1 = require("./dockerfileTemplate");
class ArchDockerfileResolver {
    constructor() {
        this.priority = 3;
        this.name = 'Architecture-specific Dockerfile';
        this.archDockerfiles = [];
    }
    entry(file) {
        const ext = path_1.posix.extname(file.name).substr(1);
        this.archDockerfiles.push([ext, file]);
    }
    needsEntry(entryPath, specifiedDockerfilePath) {
        const nameMatches = specifiedDockerfilePath
            ? entryPath.unparsed === specifiedDockerfilePath
            : entryPath.minusExt === 'Dockerfile';
        return nameMatches && !!entryPath.ext && entryPath.ext !== '.template';
    }
    isSatisfied(bundle) {
        const satisfied = this.getSatisfiedArch(bundle);
        return satisfied.arch !== undefined || satisfied.deviceType !== undefined;
    }
    resolve(bundle, specifiedDockerfilePath, additionalTemplateVars = {}) {
        const name = specifiedDockerfilePath != null
            ? this.getCanonicalName(specifiedDockerfilePath)
            : 'Dockerfile';
        const satisfiedPair = this.getSatisfiedArch(bundle);
        let satisfied;
        if (satisfiedPair.deviceType != null) {
            satisfied = satisfiedPair.deviceType;
        }
        else if (satisfiedPair.arch != null) {
            satisfied = satisfiedPair.arch;
        }
        else {
            return Promise.reject('Resolve called without a satisfied architecture specific dockerfile');
        }
        const vars = Object.assign({ RESIN_ARCH: bundle.architecture, RESIN_MACHINE_NAME: bundle.deviceType, BALENA_ARCH: bundle.architecture, BALENA_MACHINE_NAME: bundle.deviceType }, additionalTemplateVars);
        try {
            this.dockerfileContents = DockerfileTemplate.process(satisfied[1].contents.toString(), vars);
        }
        catch (e) {
            throw new dockerfileTemplate_1.DockerfileTemplateVariableError(e);
        }
        return Promise.resolve({
            name,
            size: satisfied[1].size,
            contents: Buffer.from(this.dockerfileContents),
        });
    }
    getCanonicalName(filename) {
        return utils_1.removeExtension(filename);
    }
    getSatisfiedArch(bundle) {
        let arch;
        let deviceType;
        this.archDockerfiles.map(dockerfile => {
            if (dockerfile[0] === bundle.architecture) {
                arch = dockerfile;
            }
            else if (dockerfile[0] === bundle.deviceType) {
                deviceType = dockerfile;
            }
        });
        return { arch, deviceType };
    }
}
exports.ArchDockerfileResolver = ArchDockerfileResolver;
exports.default = ArchDockerfileResolver;
//# sourceMappingURL=archDockerfile.js.map