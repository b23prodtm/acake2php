"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DockerfileTemplate = require("dockerfile-template");
const typed_error_1 = require("typed-error");
const utils_1 = require("../utils");
class DockerfileTemplateVariableError extends typed_error_1.TypedError {
}
exports.DockerfileTemplateVariableError = DockerfileTemplateVariableError;
class DockerfileTemplateResolver {
    constructor() {
        this.priority = 2;
        this.name = 'Dockerfile.template';
        this.hasDockerfileTemplate = false;
    }
    entry(file) {
        this.templateContent = file.contents;
        this.hasDockerfileTemplate = true;
    }
    needsEntry(entryPath, specifiedDockerfilePath) {
        return (entryPath.ext === '.template' &&
            (specifiedDockerfilePath
                ? entryPath.unparsed === specifiedDockerfilePath
                : entryPath.minusExt === 'Dockerfile'));
    }
    isSatisfied(_bundle) {
        return this.hasDockerfileTemplate;
    }
    resolve(bundle, specifiedDockerfilePath = 'Dockerfile', additionalTemplateVars = {}) {
        const vars = Object.assign({ RESIN_ARCH: bundle.architecture, RESIN_MACHINE_NAME: bundle.deviceType, BALENA_ARCH: bundle.architecture, BALENA_MACHINE_NAME: bundle.deviceType }, additionalTemplateVars);
        try {
            this.dockerfileContents = DockerfileTemplate.process(this.templateContent.toString(), vars);
        }
        catch (e) {
            throw new DockerfileTemplateVariableError(e);
        }
        return Promise.resolve({
            contents: Buffer.from(this.dockerfileContents),
            size: this.dockerfileContents.length,
            name: this.getCanonicalName(specifiedDockerfilePath),
        });
    }
    getCanonicalName(filename) {
        return utils_1.removeExtension(filename);
    }
}
exports.DockerfileTemplateResolver = DockerfileTemplateResolver;
exports.default = DockerfileTemplateResolver;
//# sourceMappingURL=dockerfileTemplate.js.map