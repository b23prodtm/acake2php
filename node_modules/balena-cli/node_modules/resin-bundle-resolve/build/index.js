"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const tar = require("tar-stream");
const TarUtils = require("tar-utils");
const bundle_1 = require("./bundle");
exports.Bundle = bundle_1.default;
const archDockerfile_1 = require("./resolvers/archDockerfile");
exports.ArchDockerfileResolver = archDockerfile_1.default;
const dockerfile_1 = require("./resolvers/dockerfile");
exports.DockerfileResolver = dockerfile_1.default;
const dockerfileTemplate_1 = require("./resolvers/dockerfileTemplate");
exports.DockerfileTemplateResolver = dockerfileTemplate_1.default;
exports.DockerfileTemplateVariableError = dockerfileTemplate_1.DockerfileTemplateVariableError;
const nodeResolver_1 = require("./resolvers/nodeResolver");
const utils_1 = require("./utils");
function resolveInput(bundle, resolvers, resolveListeners, dockerfile, additionalTemplateVars) {
    const extract = tar.extract();
    const pack = tar.pack();
    for (const event of Object.keys(resolveListeners)) {
        for (const listener of resolveListeners[event] || []) {
            pack.on(event, listener);
        }
    }
    if (dockerfile != null) {
        dockerfile = TarUtils.normalizeTarEntry(dockerfile);
    }
    extract.on('error', (error) => pack.emit('error', error));
    extract.on('entry', (header, stream, next) => __awaiter(this, void 0, void 0, function* () {
        try {
            yield resolveTarStreamOnEntry(header, stream, resolvers, pack, dockerfile);
            next();
        }
        catch (error) {
            pack.emit('error', error);
        }
    }));
    extract.once('finish', () => __awaiter(this, void 0, void 0, function* () {
        try {
            yield resolveTarStreamOnFinish(bundle, resolvers, pack, dockerfile, additionalTemplateVars);
        }
        catch (error) {
            pack.emit('error', error);
        }
        finally {
            pack.finalize();
        }
    }));
    bundle.tarStream.pipe(extract);
    return pack;
}
exports.resolveInput = resolveInput;
function resolveTarStreamOnEntry(header, stream, resolvers, pack, dockerfile) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = header.name ? TarUtils.normalizeTarEntry(header.name) : '';
        if (!name) {
            yield TarUtils.drainStream(stream);
            return;
        }
        const candidates = resolvers.filter(r => r.needsEntry(utils_1.parsePosixPath(name), dockerfile));
        if (candidates.length > 0) {
            const fileInfo = {
                name,
                size: header.size || 0,
                contents: yield TarUtils.streamToBuffer(stream),
            };
            for (const resolver of candidates) {
                resolver.entry(fileInfo);
            }
            if (name !== 'Dockerfile' && name !== dockerfile) {
                pack.entry(header, fileInfo.contents);
            }
        }
        else {
            yield TarUtils.pipePromise(stream, pack.entry(header));
        }
    });
}
function resolveTarStreamOnFinish(bundle, resolvers, pack, dockerfile, additionalTemplateVars) {
    return __awaiter(this, void 0, void 0, function* () {
        const satisfied = _(resolvers)
            .filter(r => r.isSatisfied(bundle))
            .orderBy('priority', 'desc')
            .value();
        if (satisfied.length === 0) {
            pack.emit('error', new Error(dockerfile
                ? `Specified file not found or is invalid: ${dockerfile}`
                : 'Could not find a Dockerfile for this service'));
            return;
        }
        const resolver = satisfied[0];
        yield addResolverOutput(bundle, resolver, pack, dockerfile, additionalTemplateVars);
        pack.emit('resolver', resolver.name);
        if (dockerfile != null) {
            const dockerfileLocation = resolver.getCanonicalName(dockerfile);
            pack.emit('resolved-name', dockerfileLocation);
        }
    });
}
function addResolverOutput(bundle, resolver, pack, specifiedDockerfilePath, additionalTemplateVars) {
    return __awaiter(this, void 0, void 0, function* () {
        const dockerfile = yield resolver.resolve(bundle, specifiedDockerfilePath, additionalTemplateVars);
        const content = dockerfile.contents.toString();
        const newContent = (yield bundle.callDockerfileHook(content)) || content;
        pack.entry({ name: dockerfile.name, size: newContent.length }, newContent);
    });
}
function getDefaultResolvers() {
    return [
        new dockerfile_1.default(),
        new dockerfileTemplate_1.default(),
        new archDockerfile_1.default(),
        new nodeResolver_1.default(),
    ];
}
exports.getDefaultResolvers = getDefaultResolvers;
//# sourceMappingURL=index.js.map