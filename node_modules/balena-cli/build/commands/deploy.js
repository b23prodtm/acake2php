"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../command");
const errors_1 = require("../errors");
const lazy_1 = require("../utils/lazy");
const messages_1 = require("../utils/messages");
const compose = require("../utils/compose");
const compose_ts_1 = require("../utils/compose_ts");
const docker_1 = require("../utils/docker");
class DeployCmd extends command_2.default {
    async run() {
        var _a;
        const { args: params, flags: options } = this.parse(DeployCmd);
        (await Promise.resolve().then(() => require('events'))).defaultMaxListeners = 1000;
        const logger = await command_2.default.getLogger();
        logger.logDebug('Parsing input...');
        const { appName, image } = params;
        if (image != null && options.build) {
            throw new errors_1.ExpectedError('Build option is not applicable when specifying an image');
        }
        const sdk = lazy_1.getBalenaSdk();
        const { getRegistrySecrets, validateProjectDirectory } = await Promise.resolve().then(() => require('../utils/compose_ts'));
        const { releaseTagKeys, releaseTagValues } = compose_ts_1.parseReleaseTagKeysAndValues((_a = options['release-tag']) !== null && _a !== void 0 ? _a : []);
        if (image) {
            options['registry-secrets'] = await getRegistrySecrets(sdk, options['registry-secrets']);
        }
        else {
            const { dockerfilePath, registrySecrets, } = await validateProjectDirectory(sdk, {
                dockerfilePath: options.dockerfile,
                noParentCheck: options['noparent-check'] || false,
                projectPath: options.source || '.',
                registrySecretsPath: options['registry-secrets'],
            });
            options.dockerfile = dockerfilePath;
            options['registry-secrets'] = registrySecrets;
        }
        const helpers = await Promise.resolve().then(() => require('../utils/helpers'));
        const app = await helpers.getAppWithArch(appName);
        const dockerUtils = await Promise.resolve().then(() => require('../utils/docker'));
        const [docker, buildOpts, composeOpts] = await Promise.all([
            dockerUtils.getDocker(options),
            dockerUtils.generateBuildOpts(options),
            compose.generateOpts(options),
        ]);
        const release = await this.deployProject(docker, logger, composeOpts, {
            app,
            appName,
            image,
            shouldPerformBuild: !!options.build,
            shouldUploadLogs: !options.nologupload,
            buildEmulated: !!options.emulated,
            buildOpts,
        });
        await compose_ts_1.applyReleaseTagKeysAndValues(sdk, release.id, releaseTagKeys, releaseTagValues);
    }
    async deployProject(docker, logger, composeOpts, opts) {
        var _a, _b, _c, _d;
        const _ = await Promise.resolve().then(() => require('lodash'));
        const doodles = await Promise.resolve().then(() => require('resin-doodles'));
        const sdk = lazy_1.getBalenaSdk();
        const { deployProject: $deployProject, loadProject } = await Promise.resolve().then(() => require('../utils/compose_ts'));
        const appType = (_b = (_a = opts.app) === null || _a === void 0 ? void 0 : _a.application_type) === null || _b === void 0 ? void 0 : _b[0];
        try {
            const project = await loadProject(logger, composeOpts, opts.image);
            if (project.descriptors.length > 1 && !(appType === null || appType === void 0 ? void 0 : appType.supports_multicontainer)) {
                throw new errors_1.ExpectedError('Target application does not support multiple containers. Aborting!');
            }
            let servicesToSkip = await Promise.all(project.descriptors.map(async function (d) {
                if (opts.shouldPerformBuild) {
                    return '';
                }
                try {
                    await docker
                        .getImage((compose_ts_1.isBuildConfig(d.image) ? d.image.tag : d.image) || '')
                        .inspect();
                    return d.serviceName;
                }
                catch (_a) {
                    return '';
                }
            }));
            servicesToSkip = servicesToSkip.filter((d) => !!d);
            const compositionToBuild = _.cloneDeep(project.composition);
            compositionToBuild.services = _.omit(compositionToBuild.services, servicesToSkip);
            let builtImagesByService = {};
            if (_.size(compositionToBuild.services) === 0) {
                logger.logInfo('Everything is up to date (use --build to force a rebuild)');
            }
            else {
                const builtImages = await compose_ts_1.buildProject({
                    docker,
                    logger,
                    projectPath: project.path,
                    projectName: project.name,
                    composition: compositionToBuild,
                    arch: opts.app.arch,
                    deviceType: (_d = (_c = opts.app) === null || _c === void 0 ? void 0 : _c.is_for__device_type) === null || _d === void 0 ? void 0 : _d[0].slug,
                    emulated: opts.buildEmulated,
                    buildOpts: opts.buildOpts,
                    inlineLogs: composeOpts.inlineLogs,
                    convertEol: composeOpts.convertEol,
                    dockerfilePath: composeOpts.dockerfilePath,
                    nogitignore: composeOpts.nogitignore,
                    multiDockerignore: composeOpts.multiDockerignore,
                });
                builtImagesByService = _.keyBy(builtImages, 'serviceName');
            }
            const images = project.descriptors.map((d) => { var _a; return (_a = builtImagesByService[d.serviceName]) !== null && _a !== void 0 ? _a : {
                serviceName: d.serviceName,
                name: (compose_ts_1.isBuildConfig(d.image) ? d.image.tag : d.image) || '',
                logs: 'Build skipped; image for service already exists.',
                props: {},
            }; });
            let release;
            if (appType === null || appType === void 0 ? void 0 : appType.is_legacy) {
                const { deployLegacy } = require('../utils/deploy-legacy');
                const msg = lazy_1.getChalk().yellow('Target application requires legacy deploy method.');
                logger.logWarn(msg);
                const [token, username, url, options] = await Promise.all([
                    sdk.auth.getToken(),
                    sdk.auth.whoami(),
                    sdk.settings.get('balenaUrl'),
                    {
                        appName: opts.appName,
                        imageName: images[0].name,
                        buildLogs: images[0].logs,
                        shouldUploadLogs: opts.shouldUploadLogs,
                    },
                ]);
                const releaseId = await deployLegacy(docker, logger, token, username, url, options);
                release = await sdk.models.release.get(releaseId, {
                    $select: ['commit'],
                });
            }
            else {
                const [userId, auth, apiEndpoint] = await Promise.all([
                    sdk.auth.getUserId(),
                    sdk.auth.getToken(),
                    sdk.settings.get('apiUrl'),
                ]);
                release = await $deployProject(docker, logger, project.composition, images, opts.app.id, userId, `Bearer ${auth}`, apiEndpoint, !opts.shouldUploadLogs);
            }
            logger.outputDeferredMessages();
            logger.logSuccess('Deploy succeeded!');
            logger.logSuccess(`Release: ${release.commit}`);
            console.log();
            console.log(doodles.getDoodle());
            console.log();
            return release;
        }
        catch (err) {
            logger.logError('Deploy failed');
            throw err;
        }
    }
}
exports.default = DeployCmd;
DeployCmd.description = `\
Deploy a single image or a multicontainer project to a balena application.

Usage: \`deploy <appName> ([image] | --build [--source build-dir])\`

Use this command to deploy an image or a complete multicontainer project to an
application, optionally building it first. The source images are searched for
(and optionally built) using the docker daemon in your development machine or
balena device. (See also the \`balena push\` command for the option of building
the image in the balenaCloud build servers.)

Unless an image is specified, this command will look into the current directory
(or the one specified by --source) for a docker-compose.yml file.  If one is
found, this command will deploy each service defined in the compose file,
building it first if an image for it doesn't exist. If a compose file isn't
found, the command will look for a Dockerfile[.template] file (or alternative
Dockerfile specified with the \`-f\` option), and if yet that isn't found, it
will try to generate one.

To deploy to an app on which you're a collaborator, use
\`balena deploy <appOwnerUsername>/<appName>\`.

${messages_1.registrySecretsHelp}

${messages_1.dockerignoreHelp}
`;
DeployCmd.examples = [
    '$ balena deploy myApp',
    '$ balena deploy myApp --build --source myBuildDir/',
    '$ balena deploy myApp myApp/myImage',
    '$ balena deploy myApp myApp/myImage --release-tag key1 "" key2 "value2 with spaces"',
];
DeployCmd.args = [
    {
        name: 'appName',
        description: 'the name of the application to deploy to',
        required: true,
    },
    {
        name: 'image',
        description: 'the image to deploy',
    },
];
DeployCmd.usage = 'deploy <appName> [image]';
DeployCmd.flags = {
    source: command_1.flags.string({
        description: 'specify an alternate source directory; default is the working directory',
        char: 's',
    }),
    build: command_1.flags.boolean({
        description: 'force a rebuild before deploy',
        char: 'b',
    }),
    nologupload: command_1.flags.boolean({
        description: "don't upload build logs to the dashboard with image (if building)",
    }),
    'release-tag': command_1.flags.string({
        description: lazy_1.stripIndent `
				Set release tags if the image deployment is successful. Multiple 
				arguments may be provided, alternating tag keys and values (see examples).
				Hint: Empty values may be specified with "" (bash, cmd.exe) or '""' (PowerShell).
			`,
        multiple: true,
    }),
    ...compose_ts_1.composeCliFlags,
    ...docker_1.dockerCliFlags,
    help: command_1.flags.help({}),
};
DeployCmd.authenticated = true;
DeployCmd.primary = true;
//# sourceMappingURL=deploy.js.map