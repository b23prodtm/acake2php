"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../../command");
const cf = require("../../utils/common-flags");
const lazy_1 = require("../../utils/lazy");
const messages_1 = require("../../utils/messages");
class ConfigGenerateCmd extends command_2.default {
    constructor() {
        super(...arguments);
        this.missingDeviceOrAppMessage = lazy_1.stripIndent `
		Either a device or an application must be specified.

		See the help page for examples:

		  $ balena help config generate
  	`;
        this.deviceTypeNotAllowedMessage = 'The --deviceType option can only be used alongside the --application option';
    }
    async run() {
        const { flags: options } = this.parse(ConfigGenerateCmd);
        const { getApplication } = await Promise.resolve().then(() => require('../../utils/sdk'));
        const balena = lazy_1.getBalenaSdk();
        await this.validateOptions(options);
        let resourceDeviceType;
        let application = null;
        let device = null;
        if (options.device != null) {
            const { tryAsInteger } = await Promise.resolve().then(() => require('../../utils/validation'));
            const rawDevice = await balena.models.device.get(tryAsInteger(options.device), { $expand: { is_of__device_type: { $select: 'slug' } } });
            if (!rawDevice.belongs_to__application) {
                const { ExpectedError } = await Promise.resolve().then(() => require('../../errors'));
                throw new ExpectedError(lazy_1.stripIndent `
					Device ${options.device} does not appear to belong to an accessible application.
					Try with a different device, or use '--application' instead of '--device'.`);
            }
            device = rawDevice;
            resourceDeviceType = device.is_of__device_type[0].slug;
        }
        else {
            application = (await getApplication(balena, options.application, {
                $expand: {
                    is_for__device_type: { $select: 'slug' },
                },
            }));
            resourceDeviceType = application.is_for__device_type[0].slug;
        }
        const deviceType = options.deviceType || resourceDeviceType;
        const deviceManifest = await balena.models.device.getManifestBySlug(deviceType);
        if (options.application && options.deviceType) {
            const appDeviceManifest = await balena.models.device.getManifestBySlug(resourceDeviceType);
            const helpers = await Promise.resolve().then(() => require('../../utils/helpers'));
            if (!helpers.areDeviceTypesCompatible(appDeviceManifest, deviceManifest)) {
                throw new balena.errors.BalenaInvalidDeviceType(`Device type ${options.deviceType} is incompatible with application ${options.application}`);
            }
        }
        const answers = await lazy_1.getCliForm().run(deviceManifest.options, {
            override: options,
        });
        answers.version = options.version;
        const { generateDeviceConfig, generateApplicationConfig } = await Promise.resolve().then(() => require('../../utils/config'));
        let config;
        if (device) {
            config = await generateDeviceConfig(device, options.deviceApiKey || options['generate-device-api-key'] || undefined, answers);
        }
        else if (application) {
            answers.deviceType = deviceType;
            config = await generateApplicationConfig(application, answers);
        }
        if (options.output != null) {
            const fs = await Promise.resolve().then(() => require('fs'));
            await fs.promises.writeFile(options.output, JSON.stringify(config));
        }
        const prettyjson = await Promise.resolve().then(() => require('prettyjson'));
        console.log(prettyjson.render(config));
    }
    async validateOptions(options) {
        const { ExpectedError } = await Promise.resolve().then(() => require('../../errors'));
        options.application = options.application || options.app;
        delete options.app;
        if (options.device == null && options.application == null) {
            throw new ExpectedError(this.missingDeviceOrAppMessage);
        }
        if (!options.application && options.deviceType) {
            throw new ExpectedError(this.deviceTypeNotAllowedMessage);
        }
    }
}
exports.default = ConfigGenerateCmd;
ConfigGenerateCmd.description = lazy_1.stripIndent `
		Generate a config.json file.

		Generate a config.json file for a device or application.

		Calling this command with the exact version number of the targeted image is required.

		This command is interactive by default, but you can do this automatically without interactivity
		by specifying an option for each question on the command line, if you know the questions
		that will be asked for the relevant device type.

		In case that you want to configure an image for an application with mixed device types,
		you can pass the --deviceType argument along with --application to specify the target device type.

		${messages_1.applicationIdInfo.split('\n').join('\n\t\t')}
	`;
ConfigGenerateCmd.examples = [
    '$ balena config generate --device 7cf02a6 --version 2.12.7',
    '$ balena config generate --device 7cf02a6 --version 2.12.7 --generate-device-api-key',
    '$ balena config generate --device 7cf02a6 --version 2.12.7 --device-api-key <existingDeviceKey>',
    '$ balena config generate --device 7cf02a6 --version 2.12.7 --output config.json',
    '$ balena config generate --app MyApp --version 2.12.7',
    '$ balena config generate --app myorg/myapp --version 2.12.7',
    '$ balena config generate --app MyApp --version 2.12.7 --deviceType fincm3',
    '$ balena config generate --app MyApp --version 2.12.7 --output config.json',
    '$ balena config generate --app MyApp --version 2.12.7 --network wifi --wifiSsid mySsid --wifiKey abcdefgh --appUpdatePollInterval 1',
];
ConfigGenerateCmd.usage = 'config generate';
ConfigGenerateCmd.flags = {
    version: command_1.flags.string({
        description: 'a balenaOS version',
        required: true,
    }),
    application: { ...cf.application, exclusive: ['app', 'device'] },
    app: { ...cf.app, exclusive: ['application', 'device'] },
    device: command_1.flags.string({
        description: 'device uuid',
        char: 'd',
        exclusive: ['application', 'app'],
    }),
    deviceApiKey: command_1.flags.string({
        description: 'custom device key - note that this is only supported on balenaOS 2.0.3+',
        char: 'k',
    }),
    deviceType: command_1.flags.string({
        description: 'device type slug',
    }),
    'generate-device-api-key': command_1.flags.boolean({
        description: 'generate a fresh device key for the device',
    }),
    output: command_1.flags.string({
        description: 'path of output file',
        char: 'o',
    }),
    network: command_1.flags.string({
        description: 'the network type to use: ethernet or wifi',
        options: ['ethernet', 'wifi'],
    }),
    wifiSsid: command_1.flags.string({
        description: 'the wifi ssid to use (used only if --network is set to wifi)',
    }),
    wifiKey: command_1.flags.string({
        description: 'the wifi key to use (used only if --network is set to wifi)',
    }),
    appUpdatePollInterval: command_1.flags.string({
        description: 'how frequently (in minutes) to poll for application updates',
    }),
    help: cf.help,
};
ConfigGenerateCmd.authenticated = true;
//# sourceMappingURL=generate.js.map