"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../command");
const lazy_1 = require("../utils/lazy");
const compose = require("../utils/compose");
const messages_1 = require("../utils/messages");
const compose_ts_1 = require("../utils/compose_ts");
const docker_1 = require("../utils/docker");
class BuildCmd extends command_2.default {
    async run() {
        const { args: params, flags: options } = this.parse(BuildCmd);
        await command_2.default.checkLoggedInIf(!!options.application);
        (await Promise.resolve().then(() => require('events'))).defaultMaxListeners = 1000;
        const sdk = lazy_1.getBalenaSdk();
        const logger = await command_2.default.getLogger();
        logger.logDebug('Parsing input...');
        options.source = params.source;
        delete params.source;
        await this.validateOptions(options, sdk);
        const app = await this.getAppAndResolveArch(options);
        const { docker, buildOpts, composeOpts } = await this.prepareBuild(options);
        try {
            await this.buildProject(docker, logger, composeOpts, {
                app,
                arch: options.arch,
                deviceType: options.deviceType,
                buildEmulated: options.emulated,
                buildOpts,
            });
        }
        catch (err) {
            logger.logError('Build failed.');
            throw err;
        }
        logger.outputDeferredMessages();
        logger.logSuccess('Build succeeded!');
    }
    async validateOptions(opts, sdk) {
        if ((opts.application == null &&
            (opts.arch == null || opts.deviceType == null)) ||
            (opts.application != null &&
                (opts.arch != null || opts.deviceType != null))) {
            const { ExpectedError } = await Promise.resolve().then(() => require('../errors'));
            throw new ExpectedError('You must specify either an application or an arch/deviceType pair to build for');
        }
        const { validateProjectDirectory } = await Promise.resolve().then(() => require('../utils/compose_ts'));
        const { dockerfilePath, registrySecrets } = await validateProjectDirectory(sdk, {
            dockerfilePath: opts.dockerfile,
            noParentCheck: opts['noparent-check'] || false,
            projectPath: opts.source || '.',
            registrySecretsPath: opts['registry-secrets'],
        });
        opts.dockerfile = dockerfilePath;
        opts['registry-secrets'] = registrySecrets;
    }
    async getAppAndResolveArch(opts) {
        if (opts.application) {
            const { getAppWithArch } = await Promise.resolve().then(() => require('../utils/helpers'));
            const app = await getAppWithArch(opts.application);
            opts.arch = app.arch;
            opts.deviceType = app.is_for__device_type[0].slug;
            return app;
        }
    }
    async prepareBuild(options) {
        const { getDocker, generateBuildOpts } = await Promise.resolve().then(() => require('../utils/docker'));
        const [docker, buildOpts, composeOpts] = await Promise.all([
            getDocker(options),
            generateBuildOpts(options),
            compose.generateOpts(options),
        ]);
        return {
            docker,
            buildOpts,
            composeOpts,
        };
    }
    async buildProject(docker, logger, composeOpts, opts) {
        var _a, _b;
        const { loadProject } = await Promise.resolve().then(() => require('../utils/compose_ts'));
        const project = await loadProject(logger, composeOpts);
        const appType = (_b = (_a = opts.app) === null || _a === void 0 ? void 0 : _a.application_type) === null || _b === void 0 ? void 0 : _b[0];
        if (appType != null &&
            project.descriptors.length > 1 &&
            !appType.supports_multicontainer) {
            logger.logWarn('Target application does not support multiple containers.\n' +
                'Continuing with build, but you will not be able to deploy.');
        }
        await compose_ts_1.buildProject({
            docker,
            logger,
            projectPath: project.path,
            projectName: project.name,
            composition: project.composition,
            arch: opts.arch,
            deviceType: opts.deviceType,
            emulated: opts.buildEmulated,
            buildOpts: opts.buildOpts,
            inlineLogs: composeOpts.inlineLogs,
            convertEol: composeOpts.convertEol,
            dockerfilePath: composeOpts.dockerfilePath,
            nogitignore: composeOpts.nogitignore,
            multiDockerignore: composeOpts.multiDockerignore,
        });
    }
}
exports.default = BuildCmd;
BuildCmd.description = `\
Build a project locally.

Use this command to build an image or a complete multicontainer project with
the provided docker daemon in your development machine or balena device.
(See also the \`balena push\` command for the option of building images in the
balenaCloud build servers.)

You must provide either an application or a device-type/architecture pair.

This command will look into the given source directory (or the current working
directory if one isn't specified) for a docker-compose.yml file, and if found,
each service defined in the compose file will be built. If a compose file isn't
found, it will look for a Dockerfile[.template] file (or alternative Dockerfile
specified with the \`--dockerfile\` option), and if no dockerfile is found, it
will try to generate one.

${messages_1.registrySecretsHelp}

${messages_1.dockerignoreHelp}
`;
BuildCmd.examples = [
    '$ balena build --application myApp',
    '$ balena build ./source/ --application myApp',
    '$ balena build --deviceType raspberrypi3 --arch armv7hf --emulated',
    '$ balena build --docker /var/run/docker.sock --application myApp   # Linux, Mac',
    '$ balena build --docker //./pipe/docker_engine --application myApp # Windows',
    '$ balena build --dockerHost my.docker.host --dockerPort 2376 --ca ca.pem --key key.pem --cert cert.pem -a myApp',
];
BuildCmd.args = [
    {
        name: 'source',
        description: 'path of project source directory',
    },
];
BuildCmd.usage = 'build [source]';
BuildCmd.flags = {
    arch: command_1.flags.string({
        description: 'the architecture to build for',
        char: 'A',
    }),
    deviceType: command_1.flags.string({
        description: 'the type of device this build is for',
        char: 'd',
    }),
    application: command_1.flags.string({
        description: 'name of the target balena application this build is for',
        char: 'a',
    }),
    ...compose_ts_1.composeCliFlags,
    ...docker_1.dockerCliFlags,
    help: command_1.flags.help({}),
};
BuildCmd.primary = true;
//# sourceMappingURL=build.js.map