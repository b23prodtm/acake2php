"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../../command");
const cf = require("../../utils/common-flags");
const lazy_1 = require("../../utils/lazy");
class DeviceRestartCmd extends command_2.default {
    async run() {
        var _a;
        const { args: params, flags: options } = this.parse(DeviceRestartCmd);
        const { tryAsInteger } = await Promise.resolve().then(() => require('../../utils/validation'));
        const balena = lazy_1.getBalenaSdk();
        const ux = lazy_1.getCliUx();
        const deviceIds = params.uuid.split(',').map((id) => {
            return tryAsInteger(id);
        });
        const serviceNames = (_a = options.service) === null || _a === void 0 ? void 0 : _a.split(',');
        for (const deviceId of deviceIds) {
            ux.action.start(`Restarting services on device ${deviceId}`);
            if (serviceNames) {
                await this.restartServices(balena, deviceId, serviceNames);
            }
            else {
                await this.restartAllServices(balena, deviceId);
            }
            ux.action.stop();
        }
    }
    async restartServices(balena, deviceId, serviceNames) {
        const { ExpectedError, instanceOf } = await Promise.resolve().then(() => require('../../errors'));
        const { getExpandedProp } = await Promise.resolve().then(() => require('../../utils/pine'));
        let device;
        try {
            device = await balena.models.device.getWithServiceDetails(deviceId, {
                $expand: {
                    is_running__release: { $select: 'commit' },
                },
            });
        }
        catch (e) {
            const { BalenaDeviceNotFound } = await Promise.resolve().then(() => require('balena-errors'));
            if (instanceOf(e, BalenaDeviceNotFound)) {
                throw new ExpectedError(`Device ${deviceId} not found.`);
            }
            else {
                throw e;
            }
        }
        const activeRelease = getExpandedProp(device.is_running__release, 'commit');
        serviceNames.forEach((service) => {
            if (!device.current_services[service]) {
                throw new ExpectedError(`Service ${service} not found on device ${deviceId}.`);
            }
        });
        const restartPromises = [];
        for (const serviceName of serviceNames) {
            const service = device.current_services[serviceName];
            const serviceContainer = service.find((s) => {
                return s.commit === activeRelease;
            });
            if (serviceContainer) {
                restartPromises.push(balena.models.device.restartService(deviceId, serviceContainer.image_id));
            }
        }
        try {
            await Promise.all(restartPromises);
        }
        catch (e) {
            if (e.message.toLowerCase().includes('no online device')) {
                throw new ExpectedError(`Device ${deviceId} is not online.`);
            }
            else {
                throw e;
            }
        }
    }
    async restartAllServices(balena, deviceId) {
        const { instanceOf, ExpectedError } = await Promise.resolve().then(() => require('../../errors'));
        try {
            const device = await balena.models.device.get(deviceId);
            if (!device.is_online) {
                throw new ExpectedError(`Device ${deviceId} is not online.`);
            }
        }
        catch (e) {
            const { BalenaDeviceNotFound } = await Promise.resolve().then(() => require('balena-errors'));
            if (instanceOf(e, BalenaDeviceNotFound)) {
                throw new ExpectedError(`Device ${deviceId} not found.`);
            }
            else {
                throw e;
            }
        }
        await balena.models.device.restartApplication(deviceId);
    }
}
exports.default = DeviceRestartCmd;
DeviceRestartCmd.description = lazy_1.stripIndent `
		Restart containers on a device.

		Restart containers on a device.
		If the --service flag is provided, then only those services' containers
		will be restarted, otherwise all containers on the device will be restarted.

		Multiple devices and services may be specified with a comma-separated list
		of values (no spaces).

		Note this does not reboot the device, to do so use instead \`balena device reboot\`.
		`;
DeviceRestartCmd.examples = [
    '$ balena device restart 23c73a1',
    '$ balena device restart 55d43b3,23c73a1',
    '$ balena device restart 23c73a1 --service myService',
    '$ balena device restart 23c73a1 -s myService1,myService2',
];
DeviceRestartCmd.args = [
    {
        name: 'uuid',
        description: 'comma-separated list (no blank spaces) of device UUIDs to restart',
        required: true,
    },
];
DeviceRestartCmd.usage = 'device restart <uuid>';
DeviceRestartCmd.flags = {
    service: command_1.flags.string({
        description: 'comma-separated list (no blank spaces) of service names to restart',
        char: 's',
    }),
    help: cf.help,
};
DeviceRestartCmd.authenticated = true;
//# sourceMappingURL=restart.js.map