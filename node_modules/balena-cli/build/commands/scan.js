"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../command");
const cf = require("../utils/common-flags");
const lazy_1 = require("../utils/lazy");
class ScanCmd extends command_2.default {
    async run() {
        const _ = await Promise.resolve().then(() => require('lodash'));
        const { discover } = await Promise.resolve().then(() => require('balena-sync'));
        const prettyjson = await Promise.resolve().then(() => require('prettyjson'));
        const dockerUtils = await Promise.resolve().then(() => require('../utils/docker'));
        const dockerPort = 2375;
        const dockerTimeout = 2000;
        const { flags: options } = this.parse(ScanCmd);
        const discoverTimeout = options.timeout != null ? options.timeout * 1000 : undefined;
        const ux = lazy_1.getCliUx();
        ux.action.start('Scanning for local balenaOS devices');
        const localDevices = await discover.discoverLocalBalenaOsDevices(discoverTimeout);
        const engineReachableDevices = await Promise.all(localDevices.map(async ({ address }) => {
            const docker = dockerUtils.createClient({
                host: address,
                port: dockerPort,
                timeout: dockerTimeout,
            });
            try {
                await docker.pingAsync();
                return true;
            }
            catch (err) {
                return false;
            }
        }));
        const developmentDevices = localDevices.filter((_localDevice, index) => engineReachableDevices[index]);
        const productionDevices = _.differenceWith(localDevices, developmentDevices, _.isEqual);
        const productionDevicesInfo = _.map(productionDevices, (device) => {
            return {
                host: device.host,
                address: device.address,
                osVariant: 'production',
                dockerInfo: undefined,
                dockerVersion: undefined,
            };
        });
        const devicesInfo = await Promise.all(developmentDevices.map(async ({ host, address }) => {
            const docker = dockerUtils.createClient({
                host: address,
                port: dockerPort,
                timeout: dockerTimeout,
            });
            const [dockerInfo, dockerVersion] = await Promise.all([
                docker.infoAsync().catchReturn('Could not get Docker info'),
                docker.versionAsync().catchReturn('Could not get Docker version'),
            ]);
            return {
                host,
                address,
                osVariant: 'development',
                dockerInfo,
                dockerVersion,
            };
        }));
        ux.action.stop('Reporting scan results');
        if (!options.verbose) {
            devicesInfo.forEach((d) => {
                d.dockerInfo = _.isObject(d.dockerInfo)
                    ? _.pick(d.dockerInfo, ScanCmd.dockerInfoProperties)
                    : d.dockerInfo;
                d.dockerVersion = _.isObject(d.dockerVersion)
                    ? _.pick(d.dockerVersion, ScanCmd.dockerVersionProperties)
                    : d.dockerVersion;
            });
        }
        const cmdOutput = productionDevicesInfo.concat(devicesInfo);
        if (!options.json && cmdOutput.length === 0) {
            console.error(process.platform === 'win32'
                ? ScanCmd.noDevicesFoundMessage + ScanCmd.windowsTipMessage
                : ScanCmd.noDevicesFoundMessage);
            return;
        }
        console.log(options.json
            ? JSON.stringify(cmdOutput, null, 4)
            : prettyjson.render(cmdOutput, { noColor: true }));
    }
}
exports.default = ScanCmd;
ScanCmd.description = lazy_1.stripIndent `
		Scan for balenaOS devices on your local network.

		Scan for balenaOS devices on your local network.

		The output includes device information collected through balenaEngine for
		devices running a development image of balenaOS. Devices running a production
		image do not expose balenaEngine (on TCP port 2375), which is why less
		information is printed about them.
`;
ScanCmd.examples = [
    '$ balena scan',
    '$ balena scan --timeout 120',
    '$ balena scan --verbose',
];
ScanCmd.usage = 'scan';
ScanCmd.flags = {
    verbose: command_1.flags.boolean({
        default: false,
        char: 'v',
        description: 'display full info',
    }),
    timeout: command_1.flags.integer({
        char: 't',
        description: 'scan timeout in seconds',
    }),
    help: cf.help,
    json: command_1.flags.boolean({
        default: false,
        char: 'j',
        description: 'produce JSON output instead of tabular output',
    }),
};
ScanCmd.primary = true;
ScanCmd.root = true;
ScanCmd.dockerInfoProperties = [
    'Containers',
    'ContainersRunning',
    'ContainersPaused',
    'ContainersStopped',
    'Images',
    'Driver',
    'SystemTime',
    'KernelVersion',
    'OperatingSystem',
    'Architecture',
];
ScanCmd.dockerVersionProperties = ['Version', 'ApiVersion'];
ScanCmd.noDevicesFoundMessage = 'Could not find any balenaOS devices on the local network.';
ScanCmd.windowsTipMessage = `

Note for Windows users:
  The 'scan' command relies on the Bonjour service. Check whether Bonjour is
  installed (Control Panel > Programs and Features). If not, you can download
  Bonjour for Windows (included with Bonjour Print Services) from here:
  https://support.apple.com/kb/DL999

  After installing Bonjour, restart your PC and run the 'balena scan' command
  again.`;
//# sourceMappingURL=scan.js.map