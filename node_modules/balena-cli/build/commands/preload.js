"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../command");
const cf = require("../utils/common-flags");
const lazy_1 = require("../utils/lazy");
const messages_1 = require("../utils/messages");
const docker_1 = require("../utils/docker");
const _ = require("lodash");
const validation_1 = require("../utils/validation");
const errors_1 = require("../errors");
class PreloadCmd extends command_2.default {
    constructor() {
        super(...arguments);
        this.applicationExpandOptions = {
            owns__release: {
                $select: ['id', 'commit', 'end_timestamp', 'composition'],
                $orderby: [{ end_timestamp: 'desc' }, { id: 'desc' }],
                $expand: {
                    contains__image: {
                        $select: ['image'],
                        $expand: {
                            image: {
                                $select: ['image_size', 'is_stored_at__image_location'],
                            },
                        },
                    },
                },
                $filter: {
                    status: 'success',
                },
            },
            should_be_running__release: {
                $select: 'commit',
            },
        };
    }
    async run() {
        const { args: params, flags: options } = this.parse(PreloadCmd);
        const balena = lazy_1.getBalenaSdk();
        const balenaPreload = await Promise.resolve().then(() => require('balena-preload'));
        const visuals = lazy_1.getVisuals();
        const nodeCleanup = await Promise.resolve().then(() => require('node-cleanup'));
        const { instanceOf } = await Promise.resolve().then(() => require('../errors'));
        try {
            const fs = await Promise.resolve().then(() => require('fs'));
            await fs.promises.access(params.image);
        }
        catch (error) {
            throw new errors_1.ExpectedError(`The provided image path does not exist: ${params.image}`);
        }
        if (options.app && !options.app.includes('/')) {
            const { getApplication } = await Promise.resolve().then(() => require('../utils/sdk'));
            const application = await getApplication(balena, options.app);
            if (!application) {
                throw new errors_1.ExpectedError(`Application not found: ${options.app}`);
            }
            options.app = application.slug;
        }
        const progressBars = {};
        const progressHandler = function (event) {
            var _a;
            var _b;
            const progressBar = ((_a = progressBars[_b = event.name]) !== null && _a !== void 0 ? _a : (progressBars[_b] = new visuals.Progress(event.name)));
            return progressBar.update({ percentage: event.percentage });
        };
        const spinners = {};
        const spinnerHandler = function (event) {
            var _a;
            var _b;
            const spinner = ((_a = spinners[_b = event.name]) !== null && _a !== void 0 ? _a : (spinners[_b] = new visuals.Spinner(event.name)));
            if (event.action === 'start') {
                return spinner.start();
            }
            else {
                console.log();
                return spinner.stop();
            }
        };
        const commit = this.isCurrentCommit(options.commit || '')
            ? 'latest'
            : options.commit;
        const image = params.image;
        const appId = options.app;
        const splashImage = options['splash-image'];
        const additionalSpace = options['additional-space'];
        const dontCheckArch = options['dont-check-arch'] || false;
        const pinDevice = options['pin-device-to-release'] || false;
        if (dontCheckArch && !appId) {
            throw new errors_1.ExpectedError('You need to specify an application if you disable the architecture check.');
        }
        const certificates = options['add-certificate'] || [];
        for (const certificate of certificates) {
            if (!certificate.endsWith('.crt')) {
                throw new errors_1.ExpectedError('Certificate file name must end with ".crt"');
            }
        }
        const dockerUtils = await Promise.resolve().then(() => require('../utils/docker'));
        const docker = await dockerUtils.getDocker(options);
        const preloader = new balenaPreload.Preloader(null, docker, appId, commit, image, splashImage, undefined, dontCheckArch, pinDevice, certificates, additionalSpace);
        let gotSignal = false;
        nodeCleanup(function (_exitCode, signal) {
            if (signal) {
                gotSignal = true;
                nodeCleanup.uninstall();
                preloader.cleanup().then(() => {
                    process.kill(process.pid, signal);
                });
                return false;
            }
        });
        if (process.env.DEBUG) {
            preloader.stderr.pipe(process.stderr);
        }
        preloader.on('progress', progressHandler);
        preloader.on('spinner', spinnerHandler);
        try {
            await new Promise((resolve, reject) => {
                preloader.on('error', reject);
                resolve(this.prepareAndPreload(preloader, balena, {
                    appId,
                    commit,
                    pinDevice,
                }));
            });
        }
        catch (err) {
            if (instanceOf(err, balena.errors.BalenaError)) {
                const code = err.code ? `(${err.code})` : '';
                throw new errors_1.ExpectedError(`${err.message} ${code}`);
            }
            else {
                throw err;
            }
        }
        finally {
            if (!gotSignal) {
                await preloader.cleanup();
            }
        }
    }
    async getDeviceTypes() {
        if (this.allDeviceTypes === undefined) {
            const balena = lazy_1.getBalenaSdk();
            const deviceTypes = await balena.models.config.getDeviceTypes();
            this.allDeviceTypes = _.sortBy(deviceTypes, 'name');
        }
        return this.allDeviceTypes;
    }
    isCurrentCommit(commit) {
        return commit === 'latest' || commit === 'current';
    }
    async getDeviceTypesWithSameArch(deviceTypeSlug) {
        const deviceTypes = await this.getDeviceTypes();
        const deviceType = _.find(deviceTypes, { slug: deviceTypeSlug });
        if (!deviceType) {
            throw new Error(`Device type "${deviceTypeSlug}" not found in API query`);
        }
        return _(deviceTypes).filter({ arch: deviceType.arch }).map('slug').value();
    }
    async getApplicationsWithSuccessfulBuilds(deviceTypeSlug) {
        const balena = lazy_1.getBalenaSdk();
        const deviceTypes = await this.getDeviceTypesWithSameArch(deviceTypeSlug);
        return balena.pine.get({
            resource: 'my_application',
            options: {
                $filter: {
                    is_for__device_type: {
                        $any: {
                            $alias: 'dt',
                            $expr: {
                                dt: {
                                    slug: { $in: deviceTypes },
                                },
                            },
                        },
                    },
                    owns__release: {
                        $any: {
                            $alias: 'r',
                            $expr: {
                                r: {
                                    status: 'success',
                                },
                            },
                        },
                    },
                },
                $expand: this.applicationExpandOptions,
                $select: ['id', 'app_name', 'should_track_latest_release'],
                $orderby: 'app_name asc',
            },
        });
    }
    async selectApplication(deviceTypeSlug) {
        const visuals = lazy_1.getVisuals();
        const applicationInfoSpinner = new visuals.Spinner('Downloading list of applications and releases.');
        applicationInfoSpinner.start();
        const applications = await this.getApplicationsWithSuccessfulBuilds(deviceTypeSlug);
        applicationInfoSpinner.stop();
        if (applications.length === 0) {
            throw new errors_1.ExpectedError(`You have no apps with successful releases for a '${deviceTypeSlug}' device type.`);
        }
        return lazy_1.getCliForm().ask({
            message: 'Select an application',
            type: 'list',
            choices: applications.map((app) => ({
                name: app.app_name,
                value: app,
            })),
        });
    }
    selectApplicationCommit(releases) {
        if (releases.length === 0) {
            throw new errors_1.ExpectedError('This application has no successful releases.');
        }
        const DEFAULT_CHOICE = { name: 'current', value: 'current' };
        const choices = [DEFAULT_CHOICE].concat(releases.map((release) => ({
            name: `${release.end_timestamp} - ${release.commit}`,
            value: release.commit,
        })));
        return lazy_1.getCliForm().ask({
            message: 'Select a release',
            type: 'list',
            default: 'current',
            choices,
        });
    }
    async offerToDisableAutomaticUpdates(application, commit, pinDevice) {
        const balena = lazy_1.getBalenaSdk();
        if (this.isCurrentCommit(commit) ||
            !application.should_track_latest_release ||
            pinDevice) {
            return;
        }
        const message = `\

This application is set to track the latest release, and non-pinned devices
are automatically updated when a new release is available. This may lead to
unexpected behavior: The preloaded device will download and install the latest
release once it is online.

This prompt gives you the opportunity to disable automatic updates for this
application now. Note that this would result in the application being pinned
to the current latest release, rather than some other release that may have
been selected for preloading. The pinned released may be further managed
through the web dashboard or programatically through the balena API / SDK.
Documentation about release policies and app/device pinning can be found at:
https://www.balena.io/docs/learn/deploy/release-strategy/release-policy/

Alternatively, the --pin-device-to-release flag may be used to pin only the
preloaded device to the selected release.

Would you like to disable automatic updates for this application now?\
`;
        const update = await lazy_1.getCliForm().ask({
            message,
            type: 'confirm',
        });
        if (!update) {
            return;
        }
        return await balena.pine.patch({
            resource: 'application',
            id: application.id,
            body: {
                should_track_latest_release: false,
            },
        });
    }
    async getAppWithReleases(balenaSdk, appId) {
        const { getApplication } = await Promise.resolve().then(() => require('../utils/sdk'));
        return (await getApplication(balenaSdk, appId, {
            $expand: this.applicationExpandOptions,
        }));
    }
    async prepareAndPreload(preloader, balenaSdk, options) {
        var _a;
        await preloader.prepare();
        const application = options.appId
            ? await this.getAppWithReleases(balenaSdk, options.appId)
            : await this.selectApplication(preloader.config.deviceType);
        let commit;
        const appCommit = (_a = application.should_be_running__release[0]) === null || _a === void 0 ? void 0 : _a.commit;
        if (options.commit) {
            if (this.isCurrentCommit(options.commit)) {
                if (!appCommit) {
                    throw new Error(`Unexpected empty commit hash for app ID "${application.id}"`);
                }
                commit = 'latest';
            }
            else {
                const release = _.find(application.owns__release, (r) => r.commit.startsWith(options.commit));
                if (!release) {
                    throw new errors_1.ExpectedError(`There is no release matching commit "${options.commit}"`);
                }
                commit = release.commit;
            }
        }
        else {
            commit = await this.selectApplicationCommit(application.owns__release);
        }
        await preloader.setAppIdAndCommit(application.id, this.isCurrentCommit(commit) ? appCommit : commit);
        await this.offerToDisableAutomaticUpdates(application, commit, options.pinDevice);
        await preloader.preload();
    }
}
exports.default = PreloadCmd;
PreloadCmd.description = lazy_1.stripIndent `
		Preload an app on a disk image (or Edison zip archive).

		Preload a balena application release (app images/containers), and optionally
		a balenaOS splash screen, in a previously downloaded '.img' balenaOS image file
		in the local disk (a zip file is only accepted for the Intel Edison device type).
		After preloading, the balenaOS image file can be flashed to a device's SD card.
		When the device boots, it will not need to download the application, as it was
		preloaded.

		${messages_1.applicationIdInfo.split('\n').join('\n\t\t')}

		Warning: "balena preload" requires Docker to be correctly installed in
		your shell environment. For more information (including Windows support)
		check: https://github.com/balena-io/balena-cli/blob/master/INSTALL.md
	`;
PreloadCmd.examples = [
    '$ balena preload balena.img --app MyApp --commit e1f2592fc6ee949e68756d4f4a48e49bff8d72a0',
    '$ balena preload balena.img --app myorg/myapp --commit e1f2592fc6ee949e68756d4f4a48e49bff8d72a0 --splash-image image.png',
    '$ balena preload balena.img',
];
PreloadCmd.args = [
    {
        name: 'image',
        description: 'the image file path',
        required: true,
    },
];
PreloadCmd.usage = 'preload <image>';
PreloadCmd.flags = {
    app: cf.application,
    commit: command_1.flags.string({
        description: `\
The commit hash for a specific application release to preload, use "current" to specify the current
release (ignored if no appId is given). The current release is usually also the latest, but can be
manually pinned using https://github.com/balena-io-projects/staged-releases .\
`,
        char: 'c',
    }),
    'splash-image': command_1.flags.string({
        description: 'path to a png image to replace the splash screen',
        char: 's',
    }),
    'dont-check-arch': command_1.flags.boolean({
        default: false,
        description: 'disables check for matching architecture in image and application',
    }),
    'pin-device-to-release': command_1.flags.boolean({
        default: false,
        description: 'pin the preloaded device to the preloaded release on provision',
        char: 'p',
    }),
    'additional-space': command_1.flags.integer({
        description: 'expand the image by this amount of bytes instead of automatically estimating the required amount',
        parse: (x) => validation_1.parseAsInteger(x, 'additional-space'),
    }),
    'add-certificate': command_1.flags.string({
        description: `\
Add the given certificate (in PEM format) to /etc/ssl/certs in the preloading container.
The file name must end with '.crt' and must not be already contained in the preloader's
/etc/ssl/certs folder.
Can be repeated to add multiple certificates.\
`,
        multiple: true,
    }),
    ...docker_1.dockerConnectionCliFlags,
    dockerPort: command_1.flags.integer({
        description: 'Docker daemon TCP port number (hint: 2375 for balena devices)',
        parse: (p) => validation_1.parseAsInteger(p, 'dockerPort'),
    }),
    help: command_1.flags.help({}),
};
PreloadCmd.authenticated = true;
PreloadCmd.primary = true;
//# sourceMappingURL=preload.js.map