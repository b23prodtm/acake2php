"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const _ = require("lodash");
const command_2 = require("../command");
const errors_1 = require("../errors");
const cf = require("../utils/common-flags");
const lazy_1 = require("../utils/lazy");
const messages_1 = require("../utils/messages");
const version_1 = require("../utils/version");
class EnvsCmd extends command_2.default {
    async run() {
        const { flags: options } = this.parse(EnvsCmd);
        const variables = [];
        await command_2.default.checkLoggedIn();
        if (!options.application && !options.device) {
            throw new errors_1.ExpectedError('You must specify an application or device');
        }
        const balena = lazy_1.getBalenaSdk();
        let appNameOrSlug = options.application;
        let fullUUID;
        if (options.device) {
            const { getDeviceAndMaybeAppFromUUID } = await Promise.resolve().then(() => require('../utils/cloud'));
            const [device, app] = await getDeviceAndMaybeAppFromUUID(balena, options.device, ['uuid'], ['app_name']);
            fullUUID = device.uuid;
            if (app) {
                appNameOrSlug = app.app_name;
            }
        }
        if (appNameOrSlug && options.service) {
            await validateServiceName(balena, options.service, appNameOrSlug);
        }
        variables.push(...(await getAppVars(balena, appNameOrSlug, options)));
        if (fullUUID) {
            variables.push(...(await getDeviceVars(balena, fullUUID, appNameOrSlug, options)));
        }
        if (!options.json && variables.length === 0) {
            const target = (options.service ? `service "${options.service}" of ` : '') +
                (options.application
                    ? `application "${options.application}"`
                    : `device "${options.device}"`);
            throw new errors_1.ExpectedError(`No environment variables found for ${target}`);
        }
        await this.printVariables(variables, options);
    }
    async printVariables(varArray, options) {
        const fields = ['id', 'name', 'value'];
        varArray = varArray.map((i) => {
            i.appName = i.appName || (options.json ? null : 'N/A');
            return i;
        });
        fields.push(options.json ? 'appName' : 'appName => APPLICATION');
        if (options.device) {
            fields.push(options.json ? 'deviceUUID' : 'deviceUUID => DEVICE');
        }
        if (!options.config) {
            fields.push(options.json ? 'serviceName' : 'serviceName => SERVICE');
        }
        if (options.json) {
            this.log(stringifyVarArray(varArray, fields));
        }
        else {
            this.log(lazy_1.getVisuals().table.horizontal(_.sortBy(varArray, (v) => v.name), fields));
        }
    }
}
exports.default = EnvsCmd;
EnvsCmd.description = lazy_1.stripIndent `
		List the environment or config variables of an application, device or service.

		List the environment or configuration variables of an application, device or
		service, as selected by the respective command-line options. (A service is
		an application container in a "microservices" application.)

		The results include application-wide (fleet), device-wide (multiple services on
		a device) and service-specific variables that apply to the selected application,
		device or service. It can be thought of as including "inherited" variables;
		for example, a service inherits device-wide variables, and a device inherits
		application-wide variables.

		The printed output may include DEVICE and/or SERVICE columns to distinguish
		between application-wide, device-specific and service-specific variables.
		An asterisk in these columns indicates that the variable applies to
		"all devices" or "all services".

		The --config option is used to list "configuration variables" that control
		balena platform features, as opposed to custom environment variables defined
		by the user. The --config and the --service options are mutually exclusive
		because configuration variables cannot be set for specific services.

		The --json option is recommended when scripting the output of this command,
		because the JSON format is less likely to change and it better represents data
		types like lists and empty strings. The 'jq' utility may be helpful in shell
		scripts (https://stedolan.github.io/jq/manual/). When --json is used, an empty
		JSON array ([]) is printed instead of an error message when no variables exist
		for the given query. When querying variables for a device, note that the
		application name may be null in JSON output (or 'N/A' in tabular output) if the
		application linked to the device is no longer accessible by the current user
		(for example, in case the current user has been removed from the application
		by its owner).

		${messages_1.applicationIdInfo.split('\n').join('\n\t\t')}
	`;
EnvsCmd.examples = [
    '$ balena envs --application MyApp',
    '$ balena envs --application myorg/myapp',
    '$ balena envs --application MyApp --json',
    '$ balena envs --application MyApp --service MyService',
    '$ balena envs --application MyApp --service MyService',
    '$ balena envs --application MyApp --config',
    '$ balena envs --device 7cf02a6',
    '$ balena envs --device 7cf02a6 --json',
    '$ balena envs --device 7cf02a6 --config --json',
    '$ balena envs --device 7cf02a6 --service MyService',
];
EnvsCmd.usage = 'envs';
EnvsCmd.flags = {
    ...(version_1.isV13()
        ? {}
        : {
            all: command_1.flags.boolean({
                default: false,
                description: lazy_1.stripIndent `
				No-op since balena CLI v12.0.0.`,
                hidden: true,
            }),
        }),
    application: { exclusive: ['device'], ...cf.application },
    config: command_1.flags.boolean({
        default: false,
        char: 'c',
        description: 'show configuration variables only',
        exclusive: ['service'],
    }),
    device: { exclusive: ['application'], ...cf.device },
    help: cf.help,
    json: cf.json,
    verbose: cf.verbose,
    service: { exclusive: ['config'], ...cf.service },
};
async function validateServiceName(sdk, serviceName, appName) {
    const services = await sdk.models.service.getAllByApplication(appName, {
        $filter: { service_name: serviceName },
    });
    if (services.length === 0) {
        throw new errors_1.ExpectedError(`Service "${serviceName}" not found for application "${appName}"`);
    }
}
async function getAppVars(sdk, appNameOrSlug, options) {
    const appVars = [];
    if (!appNameOrSlug) {
        return appVars;
    }
    const vars = await sdk.models.application[options.config ? 'configVar' : 'envVar'].getAllByApplication(appNameOrSlug);
    fillInInfoFields(vars, appNameOrSlug);
    appVars.push(...vars);
    if (!options.config) {
        const pineOpts = {
            $expand: {
                service: {},
            },
        };
        if (options.service) {
            pineOpts.$filter = {
                service: {
                    service_name: options.service,
                },
            };
        }
        const serviceVars = await sdk.models.service.var.getAllByApplication(appNameOrSlug, pineOpts);
        fillInInfoFields(serviceVars, appNameOrSlug);
        appVars.push(...serviceVars);
    }
    return appVars;
}
async function getDeviceVars(sdk, fullUUID, appNameOrSlug, options) {
    const printedUUID = options.json ? fullUUID : options.device;
    const deviceVars = [];
    if (options.config) {
        const deviceConfigVars = await sdk.models.device.configVar.getAllByDevice(fullUUID);
        fillInInfoFields(deviceConfigVars, appNameOrSlug, printedUUID);
        deviceVars.push(...deviceConfigVars);
    }
    else {
        const pineOpts = {
            $expand: {
                service_install: {
                    $expand: 'installs__service',
                },
            },
        };
        if (options.service) {
            pineOpts.$filter = {
                service_install: {
                    installs__service: { service_name: options.service },
                },
            };
        }
        const deviceServiceVars = await sdk.models.device.serviceVar.getAllByDevice(fullUUID, pineOpts);
        fillInInfoFields(deviceServiceVars, appNameOrSlug, printedUUID);
        deviceVars.push(...deviceServiceVars);
        const deviceEnvVars = await sdk.models.device.envVar.getAllByDevice(fullUUID);
        fillInInfoFields(deviceEnvVars, appNameOrSlug, printedUUID);
        deviceVars.push(...deviceEnvVars);
    }
    return deviceVars;
}
function fillInInfoFields(varArray, appNameOrSlug, deviceUUID) {
    var _a, _b, _c;
    for (const envVar of varArray) {
        if ('service' in envVar) {
            envVar.serviceName = (_a = envVar.service[0]) === null || _a === void 0 ? void 0 : _a.service_name;
        }
        else if ('service_install' in envVar) {
            envVar.serviceName = (_c = ((_b = envVar.service_install[0]) === null || _b === void 0 ? void 0 : _b.installs__service)[0]) === null || _c === void 0 ? void 0 : _c.service_name;
        }
        envVar.appName = appNameOrSlug;
        envVar.serviceName = envVar.serviceName || '*';
        envVar.deviceUUID = deviceUUID || '*';
    }
}
function stringifyVarArray(varArray, fields) {
    const transformed = varArray.map((o) => _.transform(o, (result, value, key) => {
        if (fields.includes(key)) {
            result[key] = value;
        }
    }, {}));
    return JSON.stringify(transformed, null, 4);
}
//# sourceMappingURL=envs.js.map