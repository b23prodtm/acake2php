"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const _ = require("lodash");
const command_2 = require("../../command");
const errors_1 = require("../../errors");
const cf = require("../../utils/common-flags");
const lazy_1 = require("../../utils/lazy");
const messages_1 = require("../../utils/messages");
const BOOT_PARTITION = 1;
const CONNECTIONS_FOLDER = '/system-connections';
const deviceApiKeyDeprecationMsg = lazy_1.stripIndent `
	The --device-api-key option is deprecated and will be removed in a future release.
	A suitable key is automatically generated or fetched if this option is omitted.`;
class OsConfigureCmd extends command_2.default {
    async run() {
        const { args: params, flags: options } = this.parse(OsConfigureCmd);
        options.application = options.application || options.app;
        delete options.app;
        await validateOptions(options);
        const devInit = await Promise.resolve().then(() => require('balena-device-init'));
        const { promises: fs } = await Promise.resolve().then(() => require('fs'));
        const { generateDeviceConfig, generateApplicationConfig } = await Promise.resolve().then(() => require('../../utils/config'));
        const helpers = await Promise.resolve().then(() => require('../../utils/helpers'));
        const { getApplication } = await Promise.resolve().then(() => require('../../utils/sdk'));
        let app;
        let device;
        let deviceTypeSlug;
        const balena = lazy_1.getBalenaSdk();
        if (options.device) {
            device = (await balena.models.device.get(options.device, {
                $expand: {
                    is_of__device_type: { $select: 'slug' },
                },
            }));
            deviceTypeSlug = device.is_of__device_type[0].slug;
        }
        else {
            app = (await getApplication(balena, options.application, {
                $expand: {
                    is_for__device_type: { $select: 'slug' },
                },
            }));
            await checkDeviceTypeCompatibility(balena, options, app);
            deviceTypeSlug =
                options['device-type'] || app.is_for__device_type[0].slug;
        }
        const deviceTypeManifest = await helpers.getManifest(params.image, deviceTypeSlug);
        let configJson;
        if (options.config) {
            const rawConfig = await fs.readFile(options.config, 'utf8');
            configJson = JSON.parse(rawConfig);
        }
        const answers = await askQuestionsForDeviceType(deviceTypeManifest, options, configJson);
        if (options.application) {
            answers.deviceType = deviceTypeSlug;
        }
        answers.version =
            options.version ||
                (await getOsVersionFromImage(params.image, deviceTypeManifest, devInit));
        if (_.isEmpty(configJson)) {
            if (device) {
                configJson = await generateDeviceConfig(device, options['device-api-key'], answers);
            }
            else {
                configJson = await generateApplicationConfig(app, answers);
            }
        }
        if (options['initial-device-name'] &&
            options['initial-device-name'] !== '') {
            configJson.initialDeviceName = options['initial-device-name'];
        }
        console.info('Configuring operating system image');
        const image = params.image;
        await helpers.osProgressHandler(await devInit.configure(image, deviceTypeManifest, configJson || {}, answers));
        if (options['system-connection']) {
            const path = await Promise.resolve().then(() => require('path'));
            const files = await Promise.all(options['system-connection'].map(async (filePath) => {
                const content = await fs.readFile(filePath, 'utf8');
                const name = path.basename(filePath);
                return {
                    name,
                    content,
                };
            }));
            const imagefs = await Promise.resolve().then(() => require('resin-image-fs'));
            for (const { name, content } of files) {
                await imagefs.writeFile({
                    image,
                    partition: BOOT_PARTITION,
                    path: path.join(CONNECTIONS_FOLDER, name),
                }, content);
                console.info(`Copied system-connection file: ${name}`);
            }
        }
    }
}
exports.default = OsConfigureCmd;
OsConfigureCmd.description = lazy_1.stripIndent `
		Configure a previously downloaded balenaOS image.

		Configure a previously downloaded balenaOS image for a specific device type or
		balena application.

		Configuration settings such as WiFi authentication will be taken from the
		following sources, in precedence order:
		1. Command-line options like \`--config-wifi-ssid\`
		2. A given \`config.json\` file specified with the \`--config\` option.
		3. User input through interactive prompts (text menus).

		The --device-type option may be used to override the application's default
		device type, in case of an application with mixed device types.

		The --system-connection (-c) option can be used to inject NetworkManager connection
		profiles for additional network interfaces, such as cellular/GSM or additional
		WiFi or ethernet connections. This option may be passed multiple times in case there
		are multiple files to inject. See connection profile examples and reference at:
		https://www.balena.io/docs/reference/OS/network/2.x/
		https://developer.gnome.org/NetworkManager/stable/nm-settings.html

		${deviceApiKeyDeprecationMsg.split('\n').join('\n\t\t')}

		${messages_1.applicationIdInfo.split('\n').join('\n\t\t')}

		Note: This command is currently not supported on Windows natively. Windows users
		are advised to install the Windows Subsystem for Linux (WSL) with Ubuntu, and use
		the Linux release of the balena CLI:
		https://docs.microsoft.com/en-us/windows/wsl/about
	`;
OsConfigureCmd.examples = [
    '$ balena os configure ../path/rpi3.img --device 7cf02a6',
    '$ balena os configure ../path/rpi3.img --device 7cf02a6 --device-api-key <existingDeviceKey>',
    '$ balena os configure ../path/rpi3.img --app MyApp',
    '$ balena os configure ../path/rpi3.img -a myorg/myapp',
    '$ balena os configure ../path/rpi3.img --app MyApp --version 2.12.7',
    '$ balena os configure ../path/rpi3.img --app MyFinApp --device-type raspberrypi3',
    '$ balena os configure ../path/rpi3.img --app MyFinApp --device-type raspberrypi3 --config myWifiConfig.json',
];
OsConfigureCmd.args = [
    {
        name: 'image',
        required: true,
        description: 'path to a balenaOS image file, e.g. "rpi3.img"',
    },
];
OsConfigureCmd.usage = 'os configure <image>';
OsConfigureCmd.flags = {
    advanced: command_1.flags.boolean({
        char: 'v',
        description: 'ask advanced configuration questions (when in interactive mode)',
    }),
    application: { ...cf.application, exclusive: ['app', 'device'] },
    app: { ...cf.app, exclusive: ['application', 'device'] },
    config: command_1.flags.string({
        description: 'path to a pre-generated config.json file to be injected in the OS image',
    }),
    'config-app-update-poll-interval': command_1.flags.integer({
        description: 'interval (in minutes) for the on-device balena supervisor periodic app update check',
    }),
    'config-network': command_1.flags.string({
        description: 'device network type (non-interactive configuration)',
        options: ['ethernet', 'wifi'],
    }),
    'config-wifi-key': command_1.flags.string({
        description: 'WiFi key (password) (non-interactive configuration)',
    }),
    'config-wifi-ssid': command_1.flags.string({
        description: 'WiFi SSID (network name) (non-interactive configuration)',
    }),
    device: { exclusive: ['app', 'application'], ...cf.device },
    'device-api-key': command_1.flags.string({
        char: 'k',
        description: 'custom device API key (DEPRECATED and only supported with balenaOS 2.0.3+)',
    }),
    'device-type': command_1.flags.string({
        description: 'device type slug (e.g. "raspberrypi3") to override the application device type',
    }),
    'initial-device-name': command_1.flags.string({
        description: 'This option will set the device name when the device provisions',
    }),
    version: command_1.flags.string({
        description: 'balenaOS version, for example "2.32.0" or "2.44.0+rev1"',
    }),
    'system-connection': command_1.flags.string({
        multiple: true,
        char: 'c',
        required: false,
        description: "paths to local files to place into the 'system-connections' directory",
    }),
    help: cf.help,
};
async function validateOptions(options) {
    if (process.platform === 'win32') {
        throw new errors_1.ExpectedError(lazy_1.stripIndent `
			Unsupported platform error: the 'balena os configure' command currently requires
			the Windows Subsystem for Linux in order to run on Windows. It was tested with
			the Ubuntu 18.04 distribution from the Microsoft Store. With WSL, a balena CLI
			release for Linux (rather than Windows) should be installed: for example, the
			standalone zip package for Linux. (It is possible to have both a Windows CLI
			release and a Linux CLI release installed simultaneously.) For more information
			on WSL and the balena CLI installation options, please check:
			- https://docs.microsoft.com/en-us/windows/wsl/about
			- https://github.com/balena-io/balena-cli/blob/master/INSTALL.md
		`);
    }
    if (!options.device && !options.application) {
        throw new errors_1.ExpectedError("Either the '--device' or the '--application' option must be provided");
    }
    if (!options.application && options['device-type']) {
        throw new errors_1.ExpectedError("The '--device-type' option can only be used in conjunction with the '--application' option");
    }
    if (options['device-api-key']) {
        console.error(lazy_1.stripIndent `
			-------------------------------------------------------------------------------------------
			Warning: ${deviceApiKeyDeprecationMsg.split('\n').join('\n\t\t\t')}
			-------------------------------------------------------------------------------------------
		`);
    }
    await command_2.default.checkLoggedIn();
}
async function getOsVersionFromImage(imagePath, deviceTypeManifest, devInit) {
    const osVersion = await devInit.getImageOsVersion(imagePath, deviceTypeManifest);
    if (!osVersion) {
        throw new errors_1.ExpectedError(lazy_1.stripIndent `
			Could not read OS version from the image. Please specify the balenaOS
			version manually with the --version command-line option.`);
    }
    return osVersion;
}
async function checkDeviceTypeCompatibility(sdk, options, app) {
    if (options['device-type']) {
        const [appDeviceType, optionDeviceType] = await Promise.all([
            sdk.models.device.getManifestBySlug(app.is_for__device_type[0].slug),
            sdk.models.device.getManifestBySlug(options['device-type']),
        ]);
        const helpers = await Promise.resolve().then(() => require('../../utils/helpers'));
        if (!helpers.areDeviceTypesCompatible(appDeviceType, optionDeviceType)) {
            throw new errors_1.ExpectedError(`Device type ${options['device-type']} is incompatible with application ${options.application}`);
        }
    }
}
async function askQuestionsForDeviceType(deviceType, options, configJson) {
    const answerSources = [camelifyConfigOptions(options)];
    const defaultAnswers = {};
    const questions = deviceType.options;
    let extraOpts;
    if (!_.isEmpty(configJson)) {
        answerSources.push(configJson);
    }
    if (!options.advanced) {
        const advancedGroup = _.find(questions, {
            name: 'advanced',
            isGroup: true,
        });
        if (!_.isEmpty(advancedGroup)) {
            const helpers = await Promise.resolve().then(() => require('../../utils/helpers'));
            answerSources.push(helpers.getGroupDefaults(advancedGroup));
        }
    }
    for (const questionName of getQuestionNames(deviceType)) {
        for (const answerSource of answerSources) {
            if (answerSource[questionName] != null) {
                defaultAnswers[questionName] = answerSource[questionName];
                break;
            }
        }
    }
    if (!defaultAnswers.network &&
        (defaultAnswers.wifiSsid || defaultAnswers.wifiKey)) {
        defaultAnswers.network = 'wifi';
    }
    if (!_.isEmpty(defaultAnswers)) {
        extraOpts = { override: defaultAnswers };
    }
    return lazy_1.getCliForm().run(questions, extraOpts);
}
function getQuestionNames(deviceType) {
    const questionNames = _.chain(deviceType.options)
        .flatMap((group) => (group.isGroup && group.options) || [])
        .map((groupOption) => groupOption.name)
        .filter()
        .value();
    return questionNames;
}
function camelifyConfigOptions(options) {
    return _.mapKeys(options, (_value, key) => {
        if (key.startsWith('config-')) {
            return key
                .substring('config-'.length)
                .replace(/-[a-z]/g, (match) => match.substring(1).toUpperCase());
        }
        return key;
    });
}
//# sourceMappingURL=configure.js.map