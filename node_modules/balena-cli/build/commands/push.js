"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../command");
const cf = require("../utils/common-flags");
const lazy_1 = require("../utils/lazy");
const messages_1 = require("../utils/messages");
const errors_1 = require("../errors");
const version_1 = require("../utils/version");
const normalization_1 = require("../utils/normalization");
const compose_ts_1 = require("../utils/compose_ts");
var BuildTarget;
(function (BuildTarget) {
    BuildTarget[BuildTarget["Cloud"] = 0] = "Cloud";
    BuildTarget[BuildTarget["Device"] = 1] = "Device";
})(BuildTarget || (BuildTarget = {}));
class PushCmd extends command_2.default {
    async run() {
        const { args: params, flags: options } = this.parse(PushCmd);
        const logger = await command_2.default.getLogger();
        logger.logDebug(`Using build source directory: ${options.source} `);
        const sdk = lazy_1.getBalenaSdk();
        const { validateProjectDirectory } = await Promise.resolve().then(() => require('../utils/compose_ts'));
        const { dockerfilePath, registrySecrets } = await validateProjectDirectory(sdk, {
            dockerfilePath: options.dockerfile,
            noParentCheck: options['noparent-check'],
            projectPath: options.source,
            registrySecretsPath: options['registry-secrets'],
        });
        switch (await this.getBuildTarget(params.applicationOrDevice)) {
            case BuildTarget.Cloud:
                logger.logDebug(`Pushing to cloud for application: ${params.applicationOrDevice}`);
                await this.pushToCloud(params.applicationOrDevice, options, sdk, dockerfilePath, registrySecrets);
                break;
            case BuildTarget.Device:
                logger.logDebug(`Pushing to local device: ${params.applicationOrDevice}`);
                await this.pushToDevice(params.applicationOrDevice, options, dockerfilePath, registrySecrets);
                break;
        }
    }
    async pushToCloud(appNameOrSlug, options, sdk, dockerfilePath, registrySecrets) {
        var _a;
        const remote = await Promise.resolve().then(() => require('../utils/remote-build'));
        const { getApplication } = await Promise.resolve().then(() => require('../utils/sdk'));
        const localOnlyOptions = [
            'nolive',
            'service',
            'system',
            'env',
        ];
        this.checkInvalidOptions(localOnlyOptions, options, 'is only valid when pushing to a local mode device');
        const { releaseTagKeys, releaseTagValues } = compose_ts_1.parseReleaseTagKeysAndValues((_a = options['release-tag']) !== null && _a !== void 0 ? _a : []);
        await command_2.default.checkLoggedIn();
        const [token, baseUrl] = await Promise.all([
            sdk.auth.getToken(),
            sdk.settings.get('balenaUrl'),
        ]);
        const application = (await getApplication(sdk, appNameOrSlug, {
            $expand: {
                organization: {
                    $select: ['handle'],
                },
            },
            $select: ['app_name', 'slug'],
        }));
        if (!application.organization[0]) {
            throw new errors_1.ExpectedError(lazy_1.stripIndent `
				You do not have permissions to push to application ${application.slug}.
				If you are trying to deploy a public app, please make sure that you have created
				your own application first.
			`);
        }
        const opts = {
            dockerfilePath,
            emulated: options.emulated,
            multiDockerignore: options['multi-dockerignore'],
            nocache: options.nocache,
            registrySecrets,
            headless: options.detached,
            convertEol: !options['noconvert-eol'],
        };
        const args = {
            app: application.app_name,
            owner: application.organization[0].handle,
            source: options.source,
            auth: token,
            baseUrl,
            nogitignore: !options.gitignore,
            sdk,
            opts,
        };
        const releaseId = await remote.startRemoteBuild(args);
        if (releaseId) {
            await compose_ts_1.applyReleaseTagKeysAndValues(sdk, releaseId, releaseTagKeys, releaseTagValues);
        }
        else if (releaseTagKeys.length > 0) {
            throw new Error(lazy_1.stripIndent `
				A release ID could not be parsed out of the builder's output.
				As a result, the release tags have not been set.`);
        }
    }
    async pushToDevice(localDeviceAddress, options, dockerfilePath, registrySecrets) {
        const remoteOnlyOptions = ['release-tag'];
        this.checkInvalidOptions(remoteOnlyOptions, options, 'is only valid when pushing to an application');
        const deviceDeploy = await Promise.resolve().then(() => require('../utils/device/deploy'));
        try {
            await deviceDeploy.deployToDevice({
                source: options.source,
                deviceHost: localDeviceAddress,
                dockerfilePath,
                registrySecrets,
                multiDockerignore: options['multi-dockerignore'],
                nocache: options.nocache,
                pull: options.pull,
                nogitignore: !options.gitignore,
                noParentCheck: options['noparent-check'],
                nolive: options.nolive,
                detached: options.detached,
                services: options.service,
                system: options.system,
                env: options.env || [],
                convertEol: !options['noconvert-eol'],
            });
        }
        catch (e) {
            const { BuildError } = await Promise.resolve().then(() => require('../utils/device/errors'));
            if (errors_1.instanceOf(e, BuildError)) {
                throw new errors_1.ExpectedError(e.toString());
            }
            else {
                throw e;
            }
        }
    }
    async getBuildTarget(appOrDevice) {
        const { validateLocalHostnameOrIp } = await Promise.resolve().then(() => require('../utils/validation'));
        return validateLocalHostnameOrIp(appOrDevice)
            ? BuildTarget.Device
            : BuildTarget.Cloud;
    }
    checkInvalidOptions(invalidOptions, options, errorMessage) {
        invalidOptions.forEach((opt) => {
            if (options[opt]) {
                throw new errors_1.ExpectedError(`The --${opt} flag ${errorMessage}`);
            }
        });
    }
}
exports.default = PushCmd;
PushCmd.description = lazy_1.stripIndent `
		Start a build on the remote balenaCloud build servers, or a local mode device.

		Start a build on the remote balenaCloud build servers, or a local mode device.

		When building on the balenaCloud servers, the given source directory will be
		sent to the remote server. This can be used as a drop-in replacement for the
		"git push" deployment method.

		When building on a local mode device, the given source directory will be
		built on the device, and the resulting containers will be run on the device.
		Logs will be streamed back from the device as part of the same invocation.
		The web dashboard can be used to switch a device to local mode:
		https://www.balena.io/docs/learn/develop/local-mode/
		Note that local mode requires a supervisor version of at least v7.21.0.
		The logs from only a single service can be shown with the --service flag, and
		showing only the system logs can be achieved with --system. Note that these
		flags can be used together.

		When pushing to a local device a live session will be started.
		The project source folder is watched for filesystem events, and changes
		to files and folders are automatically synchronized to the running
		containers. The synchronization is only in one direction, from this machine to
		the device, and changes made on the device itself may be overwritten.
		This feature requires a device running supervisor version v9.7.0 or greater.

		${messages_1.registrySecretsHelp.split('\n').join('\n\t\t')}

		${messages_1.dockerignoreHelp.split('\n').join('\n\t\t')}

		Note: the --service and --env flags must come after the applicationOrDevice
		parameter, as per examples.
	`;
PushCmd.examples = [
    '$ balena push myApp',
    '$ balena push myApp --source <source directory>',
    '$ balena push myApp -s <source directory>',
    '$ balena push myApp --release-tag key1 "" key2 "value2 with spaces"',
    '$ balena push myorg/myapp',
    '',
    '$ balena push 10.0.0.1',
    '$ balena push 10.0.0.1 --source <source directory>',
    '$ balena push 10.0.0.1 --service my-service',
    '$ balena push 10.0.0.1 --env MY_ENV_VAR=value --env my-service:SERVICE_VAR=value',
    '$ balena push 10.0.0.1 --nolive',
    '',
    '$ balena push 23c73a1.local --system',
    '$ balena push 23c73a1.local --system --service my-service',
];
PushCmd.args = [
    {
        name: 'applicationOrDevice',
        description: 'application name or slug, or local device IP address or hostname',
        required: true,
        parse: normalization_1.lowercaseIfSlug,
    },
];
PushCmd.usage = 'push <applicationOrDevice>';
PushCmd.flags = {
    source: command_1.flags.string({
        description: lazy_1.stripIndent `
				Source directory to be sent to balenaCloud or balenaOS device
				(default: current working dir)`,
        char: 's',
        default: '.',
    }),
    emulated: command_1.flags.boolean({
        description: lazy_1.stripIndent `
				Don't use native ARM servers; force QEMU ARM emulation on Intel x86-64
				servers during the image build (balenaCloud).`,
        char: 'e',
        default: false,
    }),
    dockerfile: command_1.flags.string({
        description: 'Alternative Dockerfile name/path, relative to the source folder',
    }),
    nocache: command_1.flags.boolean({
        description: lazy_1.stripIndent `
				Don't use cached layers of previously built images for this project. This
				ensures that the latest base image and packages are pulled. Note that build
				logs may still display the message _"Pulling previous images for caching
				purposes" (as the cloud builder needs previous images to compute delta
				updates), but the logs will not display the "Using cache" lines for each
				build step of a Dockerfile.`,
        char: 'c',
        default: false,
    }),
    pull: command_1.flags.boolean({
        description: lazy_1.stripIndent `
				When pushing to a local device, force the base images to be pulled again.
				Currently this option is ignored when pushing to the balenaCloud builders.`,
        default: false,
    }),
    'noparent-check': command_1.flags.boolean({
        description: lazy_1.stripIndent `
				Disable project validation check of 'docker-compose.yml' file in parent folder`,
        default: false,
    }),
    'registry-secrets': command_1.flags.string({
        description: lazy_1.stripIndent `
				Path to a local YAML or JSON file containing Docker registry passwords used
				to pull base images. Note that if registry-secrets are not provided on the
				command line, a secrets configuration file from the balena directory will be
				used (usually $HOME/.balena/secrets.yml|.json)`,
        char: 'R',
    }),
    nolive: command_1.flags.boolean({
        description: lazy_1.stripIndent `
				Don't run a live session on this push. The filesystem will not be monitored,
				and changes will not be synchronized to any running containers. Note that both
				this flag and --detached and required to cause the process to end once the
				initial build has completed.`,
        default: false,
    }),
    detached: command_1.flags.boolean({
        description: lazy_1.stripIndent `
				When pushing to the cloud, this option will cause the build to start, then
				return execution back to the shell, with the status and release ID (if
				applicable).  When pushing to a local mode device, this option will cause
				the command to not tail application logs when the build has completed.`,
        char: 'd',
        default: false,
    }),
    service: command_1.flags.string({
        description: lazy_1.stripIndent `
				Reject logs not originating from this service.
				This can be used in combination with --system and other --service flags.
				Only valid when pushing to a local mode device.`,
        multiple: true,
    }),
    system: command_1.flags.boolean({
        description: lazy_1.stripIndent `
				Only show system logs. This can be used in combination with --service.
				Only valid when pushing to a local mode device.`,
        default: false,
    }),
    env: command_1.flags.string({
        description: lazy_1.stripIndent `
				When performing a push to device, run the built containers with environment
				variables provided with this argument. Environment variables can be applied
				to individual services by adding their service name before the argument,
				separated by a colon, e.g:
					--env main:MY_ENV=value
				Note that if the service name cannot be found in the composition, the entire
				left hand side of the = character will be treated as the variable name.
			`,
        multiple: true,
    }),
    ...(version_1.isV13()
        ? {}
        : {
            'convert-eol': command_1.flags.boolean({
                description: 'No-op and deprecated since balena CLI v12.0.0',
                char: 'l',
                hidden: true,
                default: false,
            }),
        }),
    'noconvert-eol': command_1.flags.boolean({
        description: `Don't convert line endings from CRLF (Windows format) to LF (Unix format).`,
        default: false,
    }),
    'multi-dockerignore': command_1.flags.boolean({
        description: 'Have each service use its own .dockerignore file. See "balena help push".',
        char: 'm',
        default: false,
        exclusive: ['gitignore'],
    }),
    ...(version_1.isV13()
        ? {}
        : {
            nogitignore: command_1.flags.boolean({
                description: 'No-op (default behavior) since balena CLI v12.0.0. See "balena help push".',
                char: 'G',
                hidden: true,
                default: false,
            }),
        }),
    gitignore: command_1.flags.boolean({
        description: lazy_1.stripIndent `
		Consider .gitignore files in addition to the .dockerignore file. This reverts
		to the CLI v11 behavior/implementation (deprecated) if compatibility is
		required until your project can be adapted.`,
        char: 'g',
        default: false,
        exclusive: ['multi-dockerignore'],
    }),
    'release-tag': command_1.flags.string({
        description: lazy_1.stripIndent `
				Set release tags if the push to a cloud application is successful. Multiple
				arguments may be provided, alternating tag keys and values (see examples).
				Hint: Empty values may be specified with "" (bash, cmd.exe) or '""' (PowerShell).
			`,
        multiple: true,
        exclusive: ['detached'],
    }),
    help: cf.help,
};
PushCmd.primary = true;
//# sourceMappingURL=push.js.map