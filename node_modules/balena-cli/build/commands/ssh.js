"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const command_2 = require("../command");
const cf = require("../utils/common-flags");
const lazy_1 = require("../utils/lazy");
const validation_1 = require("../utils/validation");
class SshCmd extends command_2.default {
    async run() {
        const { args: params, flags: options } = this.parse(SshCmd);
        if (validation_1.validateLocalHostnameOrIp(params.applicationOrDevice)) {
            const { performLocalDeviceSSH } = await Promise.resolve().then(() => require('../utils/device/ssh'));
            return await performLocalDeviceSSH({
                address: params.applicationOrDevice,
                port: options.port,
                forceTTY: options.tty,
                verbose: options.verbose,
                service: params.service,
            });
        }
        const { getProxyConfig, which } = await Promise.resolve().then(() => require('../utils/helpers'));
        const { getOnlineTargetDeviceUuid } = await Promise.resolve().then(() => require('../utils/patterns'));
        const sdk = lazy_1.getBalenaSdk();
        const proxyConfig = getProxyConfig();
        const useProxy = !!proxyConfig && !options.noproxy;
        await command_2.default.checkLoggedIn();
        const deviceUuid = await getOnlineTargetDeviceUuid(sdk, params.applicationOrDevice);
        const device = await sdk.models.device.get(deviceUuid, {
            $select: ['id', 'supervisor_version', 'is_online'],
        });
        const deviceId = device.id;
        const supervisorVersion = device.supervisor_version;
        const [whichProxytunnel, username, proxyUrl] = await Promise.all([
            useProxy ? which('proxytunnel', false) : undefined,
            sdk.auth.whoami(),
            sdk.settings.get('proxyUrl'),
        ]);
        const getSshProxyCommand = () => {
            if (!proxyConfig) {
                return;
            }
            if (!whichProxytunnel) {
                console.warn(lazy_1.stripIndent `
					Proxy is enabled but the \`proxytunnel\` binary cannot be found.
					Please install it if you want to route the \`balena ssh\` requests through the proxy.
					Alternatively you can pass \`--noproxy\` param to the \`balena ssh\` command to ignore the proxy config
					for the \`ssh\` requests.

					Attempting the unproxied request for now.`);
                return;
            }
            const p = proxyConfig;
            if (p.username && p.password) {
                process.env.PROXYUSER = p.username;
                process.env.PROXYPASS = p.password;
            }
            return [
                'proxytunnel',
                `--proxy=${p.host}:${p.port}`,
                '--dest=%h:%p',
                ...(options.verbose ? ['--verbose'] : []),
            ];
        };
        const proxyCommand = useProxy ? getSshProxyCommand() : undefined;
        let containerId;
        if (params.service != null) {
            containerId = await this.getContainerId(sdk, deviceUuid, params.service, {
                port: options.port,
                proxyCommand,
                proxyUrl: proxyUrl || '',
                username: username,
            }, supervisorVersion, deviceId);
        }
        let accessCommand;
        if (containerId != null) {
            accessCommand = `enter ${deviceUuid} ${containerId}`;
        }
        else {
            accessCommand = `host ${deviceUuid}`;
        }
        const command = this.generateVpnSshCommand({
            uuid: deviceUuid,
            command: accessCommand,
            verbose: options.verbose,
            port: options.port,
            proxyCommand,
            proxyUrl: proxyUrl || '',
            username: username,
        });
        const { spawnSshAndThrowOnError } = await Promise.resolve().then(() => require('../utils/ssh'));
        return spawnSshAndThrowOnError(command);
    }
    async getContainerId(sdk, uuid, serviceName, sshOpts, version, id) {
        const semver = await Promise.resolve().then(() => require('balena-semver'));
        if (version == null || id == null) {
            const device = await sdk.models.device.get(uuid, {
                $select: ['id', 'supervisor_version'],
            });
            version = device.supervisor_version;
            id = device.id;
        }
        let containerId;
        if (semver.gte(version, '8.6.0')) {
            const apiUrl = await sdk.settings.get('apiUrl');
            const request = await sdk.request.send({
                method: 'POST',
                url: '/supervisor/v2/containerId',
                baseUrl: apiUrl,
                body: {
                    method: 'GET',
                    deviceId: id,
                },
            });
            if (request.status !== 200) {
                throw new Error(`There was an error connecting to device ${uuid}, HTTP response code: ${request.status}.`);
            }
            const body = request.body;
            if (body.status !== 'success') {
                throw new Error(`There was an error communicating with device ${uuid}.\n\tError: ${body.message}`);
            }
            containerId = body.services[serviceName];
        }
        else {
            console.error(lazy_1.stripIndent `
			Using legacy method to detect container ID. This will be slow.
			To speed up this process, please update your device to an OS
			which has a supervisor version of at least v8.6.0.
		`);
            const childProcess = await Promise.resolve().then(() => require('child_process'));
            const { escapeRegExp } = await Promise.resolve().then(() => require('lodash'));
            const { which } = await Promise.resolve().then(() => require('../utils/helpers'));
            const { deviceContainerEngineBinary } = await Promise.resolve().then(() => require('../utils/device/ssh'));
            const sshBinary = await which('ssh');
            const sshArgs = this.generateVpnSshCommand({
                uuid,
                verbose: false,
                port: sshOpts.port,
                command: `host ${uuid} "${deviceContainerEngineBinary}" ps --format "{{.ID}} {{.Names}}"`,
                proxyCommand: sshOpts.proxyCommand,
                proxyUrl: sshOpts.proxyUrl,
                username: sshOpts.username,
            });
            if (process.env.DEBUG) {
                console.error(`[debug] [${sshBinary}, ${sshArgs.join(', ')}]`);
            }
            const subProcess = childProcess.spawn(sshBinary, sshArgs, {
                stdio: [null, 'pipe', null],
            });
            const containers = await new Promise((resolve, reject) => {
                const output = [];
                subProcess.stdout.on('data', (chunk) => output.push(chunk.toString()));
                subProcess.on('close', (code) => {
                    if (code !== 0) {
                        reject(new Error(`Non-zero error code when looking for service container: ${code}`));
                    }
                    else {
                        resolve(output.join(''));
                    }
                });
            });
            const lines = containers.split('\n');
            const regex = new RegExp(`\\/?${escapeRegExp(serviceName)}_\\d+_\\d+`);
            for (const container of lines) {
                const [cId, name] = container.split(' ');
                if (regex.test(name)) {
                    containerId = cId;
                    break;
                }
            }
        }
        if (containerId == null) {
            throw new Error(`Could not find a service ${serviceName} on device ${uuid}.`);
        }
        return containerId;
    }
    generateVpnSshCommand(opts) {
        return [
            ...(opts.verbose ? ['-vvv'] : []),
            '-t',
            ...['-o', 'LogLevel=ERROR'],
            ...['-o', 'StrictHostKeyChecking=no'],
            ...['-o', 'UserKnownHostsFile=/dev/null'],
            ...(opts.proxyCommand && opts.proxyCommand.length
                ? ['-o', `ProxyCommand=${opts.proxyCommand.join(' ')}`]
                : []),
            ...(opts.port ? ['-p', opts.port.toString()] : []),
            `${opts.username}@ssh.${opts.proxyUrl}`,
            opts.command,
        ];
    }
}
exports.default = SshCmd;
SshCmd.description = lazy_1.stripIndent `
		SSH into the host or application container of a device.

		Start a shell on a local or remote device. If a service name is not provided,
		a shell will be opened on the host OS.

		If an application is provided, an interactive menu will be presented
		for the selection of an online device. A shell will then be opened for the
		host OS or service container of the chosen device.

		For local devices, the IP address and .local domain name are supported.
		If the device is referenced by IP or \`.local\` address, the connection
		is initiated directly to balenaOS on port \`22222\` via an
		openssh-compatible client. Otherwise, any connection initiated remotely
		traverses the balenaCloud VPN.

		Commands may be piped to the standard input for remote execution (see examples).
		Note however that remote command execution on service containers (as opposed to
		the host OS) is not currently possible when a device UUID is used (instead of
		an IP address) because of a balenaCloud backend limitation.

		Note: \`balena ssh\` requires an openssh-compatible client to be correctly
		installed in your shell environment. For more information (including Windows
		support) please check:
			https://github.com/balena-io/balena-cli/blob/master/INSTALL.md#additional-dependencies,
	`;
SshCmd.examples = [
    '$ balena ssh MyApp',
    '$ balena ssh f49cefd',
    '$ balena ssh f49cefd my-service',
    '$ balena ssh f49cefd --port <port>',
    '$ balena ssh 192.168.0.1 --verbose',
    '$ balena ssh f49cefd.local my-service',
    '$ echo "uptime; exit;" | balena ssh f49cefd',
    '$ echo "uptime; exit;" | balena ssh 192.168.0.1 myService',
];
SshCmd.args = [
    {
        name: 'applicationOrDevice',
        description: 'application name/slug/id, device uuid, or address of local device',
        required: true,
    },
    {
        name: 'service',
        description: 'service name, if connecting to a container',
        required: false,
    },
];
SshCmd.usage = 'ssh <applicationOrDevice> [service]';
SshCmd.flags = {
    port: command_1.flags.integer({
        description: lazy_1.stripIndent `
				SSH server port number (default 22222) if the target is an IP address or .local
				hostname. Otherwise, port number for the balenaCloud gateway (default 22).`,
        char: 'p',
        parse: (p) => validation_1.parseAsInteger(p, 'port'),
    }),
    tty: command_1.flags.boolean({
        default: false,
        description: 'force pseudo-terminal allocation (bypass TTY autodetection for stdin)',
        char: 't',
    }),
    verbose: command_1.flags.boolean({
        default: false,
        description: 'increase verbosity',
        char: 'v',
    }),
    noproxy: command_1.flags.boolean({
        default: false,
        description: 'bypass global proxy configuration for the ssh connection',
    }),
    help: cf.help,
};
SshCmd.primary = true;
//# sourceMappingURL=ssh.js.map