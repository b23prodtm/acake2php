"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadOSImage = exports.getDeviceAndMaybeAppFromUUID = exports.getDeviceAndAppFromUUID = exports.serviceIdToName = void 0;
const _ = require("lodash");
const lazy_1 = require("./lazy");
const errors_1 = require("../errors");
exports.serviceIdToName = _.memoize(async (sdk, serviceId) => {
    const serviceName = await sdk.pine.get({
        resource: 'service',
        id: serviceId,
        options: {
            $select: 'service_name',
        },
    });
    if (serviceName != null) {
        return serviceName.service_name;
    }
    return;
}, (_sdk, id) => id.toString());
exports.getDeviceAndAppFromUUID = _.memoize(async (sdk, deviceUUID, selectDeviceFields, selectAppFields) => {
    const [device, app] = await exports.getDeviceAndMaybeAppFromUUID(sdk, deviceUUID, selectDeviceFields, selectAppFields);
    if (app == null) {
        throw new errors_1.ExpectedError(lazy_1.stripIndent `
				Unable to access the application that device ${deviceUUID} belongs to.
				Hint: check whether the application owner might have withdrawn access to it.
			`);
    }
    return [device, app];
}, (_sdk, deviceUUID) => deviceUUID);
exports.getDeviceAndMaybeAppFromUUID = _.memoize(async (sdk, deviceUUID, selectDeviceFields, selectAppFields) => {
    const pineOpts = {
        $expand: selectAppFields
            ? { belongs_to__application: { $select: selectAppFields } }
            : 'belongs_to__application',
    };
    if (selectDeviceFields) {
        pineOpts.$select = selectDeviceFields;
    }
    const device = await sdk.models.device.get(deviceUUID, pineOpts);
    const apps = device.belongs_to__application;
    if (_.isEmpty(apps) || _.isEmpty(apps[0])) {
        return [device, undefined];
    }
    return [device, apps[0]];
}, (_sdk, deviceUUID) => deviceUUID);
async function downloadOSImage(deviceType, outputPath, OSVersion) {
    console.info(`Getting device operating system for ${deviceType}`);
    if (!OSVersion) {
        console.warn('OS version not specified: using latest stable version');
    }
    OSVersion = OSVersion
        ? await resolveOSVersion(deviceType, OSVersion)
        : 'default';
    const displayVersion = OSVersion === 'default' ? '' : ` ${OSVersion}`;
    const manager = await Promise.resolve().then(() => require('balena-image-manager'));
    const stream = await manager.get(deviceType, OSVersion);
    const visuals = lazy_1.getVisuals();
    const bar = new visuals.Progress(`Downloading Device OS${displayVersion}`);
    const spinner = new visuals.Spinner(`Downloading Device OS${displayVersion} (size unknown)`);
    stream.on('progress', (state) => {
        if (state != null) {
            return bar.update(state);
        }
        else {
            return spinner.start();
        }
    });
    stream.on('end', () => {
        spinner.stop();
    });
    let output;
    if (stream.mime === 'application/zip') {
        const unzip = await Promise.resolve().then(() => require('node-unzip-2'));
        output = unzip.Extract({ path: outputPath });
    }
    else {
        const fs = await Promise.resolve().then(() => require('fs'));
        output = fs.createWriteStream(outputPath);
    }
    const streamToPromise = await Promise.resolve().then(() => require('stream-to-promise'));
    await streamToPromise(stream.pipe(output));
    console.info('The image was downloaded successfully');
    return outputPath;
}
exports.downloadOSImage = downloadOSImage;
async function resolveOSVersion(deviceType, version) {
    if (version !== 'menu') {
        if (version[0] === 'v') {
            version = version.slice(1);
        }
        return version;
    }
    const { versions: vs, recommended, } = await lazy_1.getBalenaSdk().models.os.getSupportedVersions(deviceType);
    const choices = vs.map((v) => ({
        value: v,
        name: `v${v}` + (v === recommended ? ' (recommended)' : ''),
    }));
    return lazy_1.getCliForm().ask({
        message: 'Select the OS version:',
        type: 'list',
        choices,
        default: recommended,
    });
}
//# sourceMappingURL=cloud.js.map