"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.awaitInterruptibleTask = exports.addSIGINTHandler = exports.expandForAppName = exports.getProxyConfig = exports.whichSpawn = exports.which = exports.shellEscape = exports.isWindowsComExeShell = exports.getManualSortCompareFunction = exports.retry = exports.delay = exports.getAppWithArch = exports.osProgressHandler = exports.areDeviceTypesCompatible = exports.getManifest = exports.runCommand = exports.sudo = exports.stateToString = exports.getGroupDefaults = void 0;
const child_process_1 = require("child_process");
const _ = require("lodash");
const os = require("os");
const errors_1 = require("../errors");
const lazy_1 = require("./lazy");
const util_1 = require("util");
const preparser_1 = require("../preparser");
function getGroupDefaults(group) {
    return _.chain(group)
        .get('options')
        .map((question) => [question.name, question.default])
        .fromPairs()
        .value();
}
exports.getGroupDefaults = getGroupDefaults;
function stateToString(state) {
    const percentage = _.padStart(`${state.percentage}`, 3, '0');
    const chalk = lazy_1.getChalk();
    const result = `${chalk.blue(percentage + '%')} ${chalk.cyan(state.operation.command)}`;
    switch (state.operation.command) {
        case 'copy':
            return `${result} ${state.operation.from.path} -> ${state.operation.to.path}`;
        case 'replace':
            return `${result} ${state.operation.file.path}, ${state.operation.copy} -> ${state.operation.replace}`;
        case 'run-script':
            return `${result} ${state.operation.script}`;
        default:
            throw new Error(`Unsupported operation: ${state.operation.command}`);
    }
}
exports.stateToString = stateToString;
async function sudo(command, { stderr, msg, isCLIcmd, } = {}) {
    const { executeWithPrivileges } = await Promise.resolve().then(() => require('./sudo'));
    if (os.platform() !== 'win32') {
        console.log(msg ||
            'Admin privileges required: you may be asked for your computer password to continue.');
    }
    isCLIcmd !== null && isCLIcmd !== void 0 ? isCLIcmd : (isCLIcmd = true);
    await executeWithPrivileges(command, stderr, isCLIcmd);
}
exports.sudo = sudo;
function runCommand(commandArgs) {
    if (preparser_1.isSubcommand(commandArgs)) {
        commandArgs = [
            commandArgs[0] + ':' + commandArgs[1],
            ...commandArgs.slice(2),
        ];
    }
    const { run } = require('@oclif/command');
    return run(commandArgs);
}
exports.runCommand = runCommand;
async function getManifest(image, deviceType) {
    const init = await Promise.resolve().then(() => require('balena-device-init'));
    const manifest = await init.getImageManifest(image);
    if (manifest != null) {
        return manifest;
    }
    return lazy_1.getBalenaSdk().models.device.getManifestBySlug(deviceType);
}
exports.getManifest = getManifest;
exports.areDeviceTypesCompatible = (appDeviceType, osDeviceType) => lazy_1.getBalenaSdk().models.os.isArchitectureCompatibleWith(osDeviceType.arch, appDeviceType.arch) && !!appDeviceType.isDependent === !!osDeviceType.isDependent;
async function osProgressHandler(step) {
    step.on('stdout', process.stdout.write.bind(process.stdout));
    step.on('stderr', process.stderr.write.bind(process.stderr));
    step.on('state', function (state) {
        if (state.operation.command === 'burn') {
            return;
        }
        console.log(exports.stateToString(state));
    });
    const visuals = lazy_1.getVisuals();
    const progressBars = {
        write: new visuals.Progress('Writing Device OS'),
        check: new visuals.Progress('Validating Device OS'),
    };
    step.on('burn', (state) => progressBars[state.type].update(state));
    await new Promise((resolve, reject) => {
        step.on('error', reject);
        step.on('end', resolve);
    });
}
exports.osProgressHandler = osProgressHandler;
function getAppWithArch(applicationName) {
    return Promise.all([
        getApplication(applicationName),
        lazy_1.getBalenaSdk().models.config.getDeviceTypes(),
    ]).then(function ([app, deviceTypes]) {
        const config = _.find(deviceTypes, {
            slug: app.is_for__device_type[0].slug,
        });
        if (!config) {
            throw new Error('Could not read application information!');
        }
        return { ...app, arch: config.arch };
    });
}
exports.getAppWithArch = getAppWithArch;
function getApplication(applicationName) {
    const match = applicationName.split('/');
    const extraOptions = {
        $expand: {
            application_type: {
                $select: ['name', 'slug', 'supports_multicontainer', 'is_legacy'],
            },
            is_for__device_type: {
                $select: 'slug',
            },
        },
    };
    const balena = lazy_1.getBalenaSdk();
    if (match.length > 1) {
        return balena.models.application.getAppByOwner(match[1], match[0], extraOptions);
    }
    return balena.models.application.get(applicationName, extraOptions);
}
const second = 1000;
const minute = 60 * second;
exports.delay = util_1.promisify(setTimeout);
async function retry({ func, maxAttempts, label, initialDelayMs = 1000, backoffScaler = 2, maxSingleDelayMs = 1 * minute, }) {
    let delayMs = initialDelayMs;
    for (let count = 0; count < maxAttempts - 1; count++) {
        const lastAttemptMs = Date.now();
        try {
            return await func();
        }
        catch (err) {
            if (err instanceof errors_1.SIGINTError) {
                throw err;
            }
            if (count) {
                const elapsedMs = Math.max(0, Date.now() - lastAttemptMs);
                delayMs = Math.max(initialDelayMs, delayMs - elapsedMs);
                delayMs = Math.min(maxSingleDelayMs, delayMs * backoffScaler);
            }
            const sec = delayMs / 1000;
            const secStr = sec < 10 ? sec.toFixed(1) : Math.round(sec).toString();
            console.log(`Retrying "${label}" after ${secStr}s (${count + 1} of ${maxAttempts - 1}) due to: ${err}`);
            await exports.delay(delayMs);
        }
    }
    return await func();
}
exports.retry = retry;
function getManualSortCompareFunction(manuallySortedArray, equalityFunc) {
    return function (a, b) {
        const indexA = manuallySortedArray.findIndex((x, index, array) => equalityFunc(a, x, index, array));
        const indexB = manuallySortedArray.findIndex((x, index, array) => equalityFunc(b, x, index, array));
        if (indexA >= 0 && indexB >= 0) {
            return indexA - indexB;
        }
        else if (indexA < 0 && indexB < 0) {
            return a < b ? -1 : a > b ? 1 : 0;
        }
        else {
            return indexA < 0 ? 1 : -1;
        }
    };
}
exports.getManualSortCompareFunction = getManualSortCompareFunction;
function isWindowsComExeShell() {
    return (process.env.SHELL == null &&
        process.env.ComSpec != null &&
        process.env.ComSpec.endsWith('cmd.exe'));
}
exports.isWindowsComExeShell = isWindowsComExeShell;
function shellEscape(args, detectShell = false) {
    const isCmdExe = detectShell
        ? isWindowsComExeShell()
        : process.platform === 'win32';
    if (isCmdExe) {
        return args.map((v) => windowsCmdExeEscapeArg(v));
    }
    else {
        const shellEscapeFunc = require('shell-escape');
        return args.map((v) => shellEscapeFunc([v]));
    }
}
exports.shellEscape = shellEscape;
function windowsCmdExeEscapeArg(arg) {
    if (arg.length > 1 && arg.startsWith('"') && arg.endsWith('"')) {
        arg = arg.slice(1, -1);
    }
    arg = arg.replace(/[()%!^<>&|]/g, '^$&');
    return `"${arg.replace(/["]/g, '""')}"`;
}
async function which(program, rejectOnMissing = true) {
    const whichMod = await Promise.resolve().then(() => require('which'));
    let programPath;
    try {
        programPath = await whichMod(program);
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            if (rejectOnMissing) {
                throw new errors_1.ExpectedError(`'${program}' program not found. Is it installed?`);
            }
            else {
                return '';
            }
        }
        throw err;
    }
    return programPath;
}
exports.which = which;
async function whichSpawn(programName, args, options = { stdio: 'inherit' }, returnExitCodeOrSignal = false) {
    const program = await which(programName);
    if (process.env.DEBUG) {
        console.error(`[debug] [${program}, ${args.join(', ')}]`);
    }
    let error;
    let exitCode;
    let exitSignal;
    try {
        [exitCode, exitSignal] = await new Promise((resolve, reject) => {
            child_process_1.spawn(program, args, options)
                .on('error', reject)
                .on('close', (code, signal) => resolve([code, signal]));
        });
    }
    catch (err) {
        error = err;
    }
    if (error || (!returnExitCodeOrSignal && (exitCode || exitSignal))) {
        const msg = [
            `${programName} failed with exit code=${exitCode} signal=${exitSignal}:`,
            `[${program}, ${args.join(', ')}]`,
            ...(error ? [`${error}`] : []),
        ];
        throw new Error(msg.join('\n'));
    }
    return [exitCode, exitSignal];
}
exports.whichSpawn = whichSpawn;
function getProxyConfig() {
    const tunnelNgConfig = global.PROXY_CONFIG;
    if (tunnelNgConfig) {
        let username;
        let password;
        const proxyAuth = tunnelNgConfig.proxyAuth;
        if (proxyAuth) {
            const i = proxyAuth.lastIndexOf(':');
            if (i > 0) {
                username = proxyAuth.substring(0, i);
                password = proxyAuth.substring(i + 1);
            }
        }
        return {
            host: tunnelNgConfig.host,
            port: `${tunnelNgConfig.port}`,
            username,
            password,
            proxyAuth: tunnelNgConfig.proxyAuth,
        };
    }
    else {
        const proxyUrl = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
        if (proxyUrl) {
            const { URL } = require('url');
            let url;
            try {
                url = new URL(proxyUrl);
            }
            catch (_e) {
                return;
            }
            return {
                host: url.hostname,
                port: url.port,
                username: url.username,
                password: url.password,
                proxyAuth: url.username && url.password
                    ? `${url.username}:${url.password}`
                    : undefined,
            };
        }
    }
}
exports.getProxyConfig = getProxyConfig;
exports.expandForAppName = {
    $expand: {
        belongs_to__application: { $select: 'app_name' },
        is_of__device_type: { $select: 'slug' },
        is_running__release: { $select: 'commit' },
    },
};
const installReadlineSigintEmitter = _.once(function emitSigint() {
    if (process.platform === 'win32') {
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
        });
        rl.on('SIGINT', () => process.emit('SIGINT'));
    }
});
function addSIGINTHandler(sigintHandler, once = true) {
    installReadlineSigintEmitter();
    if (once) {
        process.once('SIGINT', sigintHandler);
    }
    else {
        process.on('SIGINT', sigintHandler);
    }
}
exports.addSIGINTHandler = addSIGINTHandler;
async function awaitInterruptibleTask(task, ...theArgs) {
    let sigintHandler = () => undefined;
    const sigintPromise = new Promise((_resolve, reject) => {
        sigintHandler = () => {
            reject(new errors_1.SIGINTError('Task aborted on SIGINT signal'));
        };
        addSIGINTHandler(sigintHandler);
    });
    try {
        return await Promise.race([sigintPromise, task(...theArgs)]);
    }
    finally {
        process.removeListener('SIGINT', sigintHandler);
    }
}
exports.awaitInterruptibleTask = awaitInterruptibleTask;
//# sourceMappingURL=helpers.js.map