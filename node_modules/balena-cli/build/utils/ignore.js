"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDockerignoreByService = exports.filterFilesWithDockerignore = exports.getDockerIgnoreInstance = exports.FileIgnorer = exports.IgnoreFileType = void 0;
const _ = require("lodash");
const fs_1 = require("fs");
const path = require("path");
const MultiBuild = require("resin-multibuild");
const dockerIgnore = require("@zeit/dockerignore");
const ignore_1 = require("ignore");
const errors_1 = require("../errors");
const { toPosixPath } = MultiBuild.PathUtils;
var IgnoreFileType;
(function (IgnoreFileType) {
    IgnoreFileType[IgnoreFileType["DockerIgnore"] = 0] = "DockerIgnore";
    IgnoreFileType[IgnoreFileType["GitIgnore"] = 1] = "GitIgnore";
})(IgnoreFileType = exports.IgnoreFileType || (exports.IgnoreFileType = {}));
class FileIgnorer {
    constructor(basePath) {
        this.basePath = basePath;
        this.filter = (filename) => {
            const relFile = path.relative(this.basePath, filename);
            if (/(^|\/)\.(balena|resin)\//.test(toPosixPath(relFile))) {
                return true;
            }
            if (/^Dockerfile$|^Dockerfile\.\S+/.test(path.basename(relFile)) ||
                path.basename(relFile) === 'docker-compose.yml') {
                return true;
            }
            const dockerIgnoreHandle = dockerIgnore();
            const gitIgnoreHandle = ignore_1.default();
            const ignoreTypes = [
                { handle: dockerIgnoreHandle, entries: this.dockerIgnoreEntries },
                { handle: gitIgnoreHandle, entries: this.gitIgnoreEntries },
            ];
            _.each(ignoreTypes, ({ handle, entries }) => {
                _.each(entries, ({ pattern, filePath }) => {
                    if (FileIgnorer.contains(path.posix.dirname(filePath), filename)) {
                        handle.add(pattern);
                    }
                });
            });
            return !_.some(ignoreTypes, ({ handle }) => handle.ignores(relFile));
        };
        this.dockerIgnoreEntries = [];
        this.gitIgnoreEntries = [];
    }
    getIgnoreFileType(relativePath) {
        for (const { pattern, type, allowSubdirs } of FileIgnorer.ignoreFiles) {
            if (path.basename(relativePath) === pattern &&
                (allowSubdirs || path.dirname(relativePath) === '.')) {
                return type;
            }
        }
        return null;
    }
    async addIgnoreFile(fullPath, type) {
        const contents = await fs_1.promises.readFile(fullPath, 'utf8');
        contents.split('\n').forEach((line) => {
            if (/\s*#/.test(line) || _.isEmpty(line)) {
                return;
            }
            this.addEntry(line, fullPath, type);
        });
        return;
    }
    addEntry(pattern, filePath, type) {
        const entry = { pattern, filePath };
        switch (type) {
            case IgnoreFileType.DockerIgnore:
                this.dockerIgnoreEntries.push(entry);
                break;
            case IgnoreFileType.GitIgnore:
                this.gitIgnoreEntries.push(entry);
                break;
        }
    }
    static contains(path1, path2) {
        path1 = path.posix.normalize(path1);
        path2 = path.posix.normalize(path2);
        return !/^\.\.\//.test(path.posix.relative(path1, path2));
    }
}
exports.FileIgnorer = FileIgnorer;
FileIgnorer.ignoreFiles = [
    {
        pattern: '.gitignore',
        type: IgnoreFileType.GitIgnore,
        allowSubdirs: true,
    },
    {
        pattern: '.dockerignore',
        type: IgnoreFileType.DockerIgnore,
        allowSubdirs: false,
    },
];
async function readDockerIgnoreFile(projectDir) {
    const dockerIgnorePath = path.join(projectDir, '.dockerignore');
    let dockerIgnoreStr = '';
    try {
        dockerIgnoreStr = await fs_1.promises.readFile(dockerIgnorePath, 'utf8');
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            throw new errors_1.ExpectedError(`Error reading file "${dockerIgnorePath}": ${err.message}`);
        }
    }
    return dockerIgnoreStr;
}
async function getDockerIgnoreInstance(directory) {
    const dockerIgnoreStr = await readDockerIgnoreFile(directory);
    const $dockerIgnore = (await Promise.resolve().then(() => require('@balena/dockerignore'))).default;
    const ig = $dockerIgnore({ ignorecase: false });
    ig.add(['**/.git']);
    if (dockerIgnoreStr) {
        ig.add(dockerIgnoreStr);
    }
    ig.add([
        '!**/.balena',
        '!**/.resin',
        '!**/Dockerfile',
        '!**/Dockerfile.*',
        '!**/docker-compose.yml',
    ]);
    return ig;
}
exports.getDockerIgnoreInstance = getDockerIgnoreInstance;
async function filterFilesWithDockerignore(projectDir, multiDockerignore, serviceDirsByService) {
    projectDir = path.resolve(projectDir);
    const root = '.' + path.sep;
    const ignoreByService = await getDockerignoreByService(projectDir, multiDockerignore, serviceDirsByService);
    const ignoreByDir = {};
    for (let [serviceName, dir] of Object.entries(serviceDirsByService)) {
        dir = path.normalize(dir);
        dir = dir.endsWith(path.sep) ? dir : dir + path.sep;
        ignoreByDir[dir] = ignoreByService[serviceName];
    }
    if (!ignoreByDir[root]) {
        ignoreByDir[root] = await getDockerIgnoreInstance(projectDir);
    }
    const dockerignoreServiceDirs = multiDockerignore
        ? Object.keys(ignoreByDir).filter((dir) => dir && dir !== root)
        : [];
    const dockerignoreFiles = [];
    const filteredFileList = [];
    const klaw = await Promise.resolve().then(() => require('klaw'));
    await new Promise((resolve, reject) => {
        klaw(projectDir, { preserveSymlinks: false })
            .on('error', reject)
            .on('end', resolve)
            .on('data', (item) => {
            const { path: filePath, stats } = item;
            if (!stats.isFile()) {
                return;
            }
            const relPath = path.relative(projectDir, filePath);
            const fileInfo = {
                filePath,
                relPath,
                stats,
            };
            if (path.basename(relPath) === '.dockerignore') {
                dockerignoreFiles.push(fileInfo);
            }
            for (const dir of dockerignoreServiceDirs) {
                if (relPath.startsWith(dir)) {
                    if (!ignoreByDir[dir].ignores(relPath.substring(dir.length))) {
                        filteredFileList.push(fileInfo);
                    }
                    return;
                }
            }
            if (!ignoreByDir[root].ignores(relPath)) {
                filteredFileList.push(fileInfo);
            }
        });
    });
    return { filteredFileList, dockerignoreFiles };
}
exports.filterFilesWithDockerignore = filterFilesWithDockerignore;
let dockerignoreByService = null;
async function getDockerignoreByService(projectDir, multiDockerignore, serviceDirsByService) {
    if (dockerignoreByService) {
        return dockerignoreByService;
    }
    const cachedDirs = {};
    projectDir = path.resolve(projectDir);
    dockerignoreByService = {};
    for (let [serviceName, dir] of Object.entries(serviceDirsByService)) {
        dir = multiDockerignore ? dir : '.';
        const absDir = path.resolve(projectDir, dir);
        if (!cachedDirs[absDir]) {
            cachedDirs[absDir] = await getDockerIgnoreInstance(absDir);
        }
        dockerignoreByService[serviceName] = cachedDirs[absDir];
    }
    return dockerignoreByService;
}
exports.getDockerignoreByService = getDockerignoreByService;
//# sourceMappingURL=ignore.js.map