"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.leave = exports.join = void 0;
const errors_1 = require("../errors");
const lazy_1 = require("./lazy");
const ssh_1 = require("./ssh");
const MIN_BALENAOS_VERSION = 'v2.14.0';
async function join(logger, sdk, deviceHostnameOrIp, appName, appUpdatePollInterval) {
    logger.logDebug('Determining device...');
    deviceHostnameOrIp = deviceHostnameOrIp || (await selectLocalDevice());
    await assertDeviceIsCompatible(deviceHostnameOrIp);
    logger.logDebug(`Using device: ${deviceHostnameOrIp}`);
    logger.logDebug('Determining device type...');
    const deviceType = await getDeviceType(deviceHostnameOrIp);
    logger.logDebug(`Device type: ${deviceType}`);
    logger.logDebug('Determining application...');
    const app = await getOrSelectApplication(sdk, deviceType, appName);
    logger.logDebug(`Using application: ${app.app_name} (${app.is_for__device_type[0].slug})`);
    if (app.is_for__device_type[0].slug !== deviceType) {
        logger.logDebug(`Forcing device type to: ${deviceType}`);
        app.is_for__device_type[0].slug = deviceType;
    }
    logger.logDebug('Determining device OS version...');
    const deviceOsVersion = await getOsVersion(deviceHostnameOrIp);
    logger.logDebug(`Device OS version: ${deviceOsVersion}`);
    logger.logDebug('Generating application config...');
    const config = await generateApplicationConfig(sdk, app, {
        version: deviceOsVersion,
        appUpdatePollInterval,
    });
    logger.logDebug(`Using config: ${JSON.stringify(config, null, 2)}`);
    logger.logDebug('Configuring...');
    await configure(deviceHostnameOrIp, config);
    const platformUrl = await sdk.settings.get('balenaUrl');
    logger.logSuccess(`Device successfully joined ${platformUrl}!`);
}
exports.join = join;
async function leave(logger, deviceHostnameOrIp) {
    logger.logDebug('Determining device...');
    deviceHostnameOrIp = deviceHostnameOrIp || (await selectLocalDevice());
    await assertDeviceIsCompatible(deviceHostnameOrIp);
    logger.logDebug(`Using device: ${deviceHostnameOrIp}`);
    logger.logDebug('Deconfiguring...');
    await deconfigure(deviceHostnameOrIp);
    logger.logSuccess('Device successfully left the platform.');
}
exports.leave = leave;
async function execCommand(deviceIp, cmd, msg) {
    const through = await Promise.resolve().then(() => require('through2'));
    const visuals = lazy_1.getVisuals();
    const spinner = new visuals.Spinner(`[${deviceIp}] Connecting...`);
    const innerSpinner = spinner.spinner;
    const stream = through(function (data, _enc, cb) {
        innerSpinner.setSpinnerTitle(`%s [${deviceIp}] ${msg}`);
        cb(null, data);
    });
    spinner.start();
    await ssh_1.exec(deviceIp, cmd, stream);
    spinner.stop();
}
async function configure(deviceIp, config) {
    const json = JSON.stringify(config);
    const b64 = Buffer.from(json).toString('base64');
    const str = `"$(base64 -d <<< ${b64})"`;
    await execCommand(deviceIp, `os-config join ${str}`, 'Configuring...');
}
async function deconfigure(deviceIp) {
    await execCommand(deviceIp, 'os-config leave', 'Configuring...');
}
async function assertDeviceIsCompatible(deviceIp) {
    const cmd = 'os-config --version';
    try {
        await ssh_1.execBuffered(deviceIp, cmd);
    }
    catch (err) {
        if (err instanceof errors_1.ExpectedError) {
            throw err;
        }
        console.error(`${err}\n`);
        throw new errors_1.ExpectedError(lazy_1.stripIndent `
			Failed to execute "${cmd}" on device "${deviceIp}".
			Depending on more specific error messages above, this may mean that the device
			is incompatible. Please ensure that the device is running a balenaOS release
			newer than ${MIN_BALENAOS_VERSION}.`);
    }
}
async function getDeviceType(deviceIp) {
    const output = await ssh_1.getDeviceOsRelease(deviceIp);
    const match = /^SLUG="([^"]+)"$/m.exec(output);
    if (!match) {
        throw new Error('Failed to determine device type');
    }
    return match[1];
}
async function getOsVersion(deviceIp) {
    const output = await ssh_1.getDeviceOsRelease(deviceIp);
    const match = /^VERSION_ID="([^"]+)"$/m.exec(output);
    if (!match) {
        throw new Error('Failed to determine OS version ID');
    }
    return match[1];
}
async function selectLocalDevice() {
    const { forms } = await Promise.resolve().then(() => require('balena-sync'));
    let hostnameOrIp;
    try {
        hostnameOrIp = await forms.selectLocalBalenaOsDevice();
        console.error(`==> Selected device: ${hostnameOrIp}`);
    }
    catch (e) {
        if (e.message.toLowerCase().includes('could not find any')) {
            throw new errors_1.ExpectedError(e);
        }
        else {
            throw e;
        }
    }
    return hostnameOrIp;
}
async function selectAppFromList(applications) {
    const _ = await Promise.resolve().then(() => require('lodash'));
    const { selectFromList } = await Promise.resolve().then(() => require('../utils/patterns'));
    return selectFromList('Select application', _.map(applications, (app) => {
        return { name: app.slug, ...app };
    }));
}
async function getOrSelectApplication(sdk, deviceType, appName) {
    const _ = await Promise.resolve().then(() => require('lodash'));
    const allDeviceTypes = await sdk.models.config.getDeviceTypes();
    const deviceTypeManifest = _.find(allDeviceTypes, { slug: deviceType });
    if (!deviceTypeManifest) {
        throw new errors_1.ExpectedError(`"${deviceType}" is not a valid device type`);
    }
    const compatibleDeviceTypes = _(allDeviceTypes)
        .filter((dt) => sdk.models.os.isArchitectureCompatibleWith(deviceTypeManifest.arch, dt.arch) &&
        !!dt.isDependent === !!deviceTypeManifest.isDependent &&
        dt.state !== 'DISCONTINUED')
        .map((type) => type.slug)
        .value();
    if (!appName) {
        return createOrSelectAppOrExit(sdk, compatibleDeviceTypes, deviceType);
    }
    const options = {
        $expand: {
            is_for__device_type: { $select: 'slug' },
        },
    };
    let name;
    const match = appName.split('/');
    if (match.length > 1) {
        options.$filter = { slug: appName.toLowerCase() };
        name = match[1];
    }
    else {
        options.$filter = { app_name: appName };
        name = appName;
    }
    const applications = (await sdk.models.application.getAll(options));
    if (applications.length === 0) {
        const shouldCreateApp = await lazy_1.getCliForm().ask({
            message: `No application found with name "${appName}".\n` +
                'Would you like to create it now?',
            type: 'confirm',
            default: true,
        });
        if (shouldCreateApp) {
            return createApplication(sdk, deviceType, name);
        }
        process.exit(1);
    }
    const validApplications = applications.filter((app) => _.includes(compatibleDeviceTypes, app.is_for__device_type[0].slug));
    if (validApplications.length === 0) {
        throw new errors_1.ExpectedError('No application found with a matching device type');
    }
    if (validApplications.length === 1) {
        return validApplications[0];
    }
    return selectAppFromList(applications);
}
async function createOrSelectAppOrExit(sdk, compatibleDeviceTypes, deviceType) {
    const applications = (await sdk.models.application.getAll({
        $expand: { is_for__device_type: { $select: 'slug' } },
        $filter: {
            is_for__device_type: {
                $any: {
                    $alias: 'dt',
                    $expr: { dt: { slug: { $in: compatibleDeviceTypes } } },
                },
            },
        },
    }));
    if (applications.length === 0) {
        const shouldCreateApp = await lazy_1.getCliForm().ask({
            message: 'You have no applications this device can join.\n' +
                'Would you like to create one now?',
            type: 'confirm',
            default: true,
        });
        if (shouldCreateApp) {
            return createApplication(sdk, deviceType);
        }
        process.exit(1);
    }
    return selectAppFromList(applications);
}
async function createApplication(sdk, deviceType, name) {
    const validation = await Promise.resolve().then(() => require('./validation'));
    const username = await sdk.auth.whoami();
    if (!username) {
        throw new sdk.errors.BalenaNotLoggedIn();
    }
    const applicationName = await new Promise(async (resolve, reject) => {
        while (true) {
            try {
                const appName = await lazy_1.getCliForm().ask({
                    message: 'Enter a name for your new application:',
                    type: 'input',
                    default: name,
                    validate: validation.validateApplicationName,
                });
                try {
                    await sdk.models.application.get(appName, {
                        $filter: {
                            $or: [
                                { slug: { $startswith: `${username.toLowerCase()}/` } },
                                { $not: { slug: { $contains: '/' } } },
                            ],
                        },
                    });
                    errors_1.printErrorMessage('You already have an application with that name; please choose another.');
                    continue;
                }
                catch (err) {
                    return resolve(appName);
                }
            }
            catch (err) {
                return reject(err);
            }
        }
    });
    const app = await sdk.models.application.create({
        name: applicationName,
        deviceType,
        organization: username,
    });
    return (await sdk.models.application.get(app.id, {
        $expand: {
            is_for__device_type: { $select: 'slug' },
        },
    }));
}
async function generateApplicationConfig(sdk, app, options) {
    const { generateApplicationConfig: configGen } = await Promise.resolve().then(() => require('./config'));
    const manifest = await sdk.models.device.getManifestBySlug(app.is_for__device_type[0].slug);
    const opts = manifest.options &&
        manifest.options.filter((opt) => opt.name !== 'network');
    const override = {
        appUpdatePollInterval: options.appUpdatePollInterval,
    };
    const values = {
        ...(opts ? await lazy_1.getCliForm().run(opts, { override }) : {}),
        ...options,
    };
    const config = await configGen(app, values);
    if (config.connectivity === 'connman') {
        delete config.connectivity;
        delete config.files;
    }
    return config;
}
//# sourceMappingURL=promote.js.map