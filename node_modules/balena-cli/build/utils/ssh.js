"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.spawnSshAndThrowOnError = exports.getDeviceOsRelease = exports.execBuffered = exports.exec = exports.ExecError = void 0;
const child_process_1 = require("child_process");
const _ = require("lodash");
const typed_error_1 = require("typed-error");
const errors_1 = require("../errors");
class ExecError extends typed_error_1.TypedError {
    constructor(cmd, exitCode) {
        super(`Command '${cmd}' failed with error: ${exitCode}`);
        this.cmd = cmd;
        this.exitCode = exitCode;
    }
}
exports.ExecError = ExecError;
async function exec(deviceIp, cmd, stdout) {
    const { which } = await Promise.resolve().then(() => require('./helpers'));
    const program = await which('ssh');
    const args = [
        '-n',
        '-t',
        '-p',
        '22222',
        '-o',
        'LogLevel=ERROR',
        '-o',
        'StrictHostKeyChecking=no',
        '-o',
        'UserKnownHostsFile=/dev/null',
        `root@${deviceIp}`,
        cmd,
    ];
    if (process.env.DEBUG) {
        const logger = (await Promise.resolve().then(() => require('./logger'))).getLogger();
        logger.logDebug(`Executing [${program},${args}]`);
    }
    const stdio = [
        'inherit',
        stdout ? 'pipe' : 'inherit',
        'inherit',
    ];
    const exitCode = await new Promise((resolve, reject) => {
        const ps = child_process_1.spawn(program, args, { stdio })
            .on('error', reject)
            .on('close', resolve);
        if (stdout) {
            ps.stdout.pipe(stdout);
        }
    });
    if (exitCode !== 0) {
        throw new ExecError(cmd, exitCode);
    }
}
exports.exec = exec;
async function execBuffered(deviceIp, cmd, enc) {
    const through = await Promise.resolve().then(() => require('through2'));
    const buffer = [];
    await exec(deviceIp, cmd, through(function (data, _enc, cb) {
        buffer.push(data.toString(enc));
        cb();
    }));
    return buffer.join('');
}
exports.execBuffered = execBuffered;
exports.getDeviceOsRelease = _.memoize(async (deviceIp) => execBuffered(deviceIp, 'cat /etc/os-release'));
async function spawnSshAndThrowOnError(args, options) {
    const { whichSpawn } = await Promise.resolve().then(() => require('./helpers'));
    const [exitCode, exitSignal] = await whichSpawn('ssh', args, options, true);
    if (exitCode || exitSignal) {
        process.exitCode = exitCode;
        throw new errors_1.ExpectedError(sshErrorMessage(exitSignal, exitCode));
    }
}
exports.spawnSshAndThrowOnError = spawnSshAndThrowOnError;
function sshErrorMessage(exitSignal, exitCode) {
    const msg = [];
    if (exitSignal) {
        msg.push(`Warning: ssh process was terminated with signal "${exitSignal}"`);
    }
    else {
        msg.push(`Warning: ssh process exited with non-zero code "${exitCode}"`);
        switch (exitCode) {
            case 255:
                msg.push(`
Are the SSH keys correctly configured in balenaCloud? See:
https://www.balena.io/docs/learn/manage/ssh-access/#add-an-ssh-key-to-balenacloud`);
                msg.push('Are you accidentally using `sudo`?');
        }
    }
    return msg.join('\n');
}
//# sourceMappingURL=ssh.js.map