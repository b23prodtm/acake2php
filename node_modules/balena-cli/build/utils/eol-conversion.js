"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectEncoding = exports.readFileWithEolConversion = exports.convertEolInPlace = void 0;
const fs_1 = require("fs");
const Logger = require("./logger");
const globalLogger = Logger.getLogger();
const LARGE_FILE_THRESHOLD = 10 * 1000 * 1000;
const CONVERTIBLE_ENCODINGS = ['ascii', 'utf-8'];
const DETECT_MAX_BYTES = 1024;
function convertEolInPlace(buf) {
    const CR = 13;
    const LF = 10;
    let foundCR = false;
    let j;
    for (let i = (j = 0); i < buf.length; i++, j++) {
        const b = (buf[j] = buf[i]);
        if (b === CR) {
            foundCR = true;
        }
        else {
            if (foundCR && b === LF) {
                j--;
                buf[j] = LF;
            }
            foundCR = false;
        }
    }
    return buf.slice(0, j);
}
exports.convertEolInPlace = convertEolInPlace;
async function readFileWithEolConversion(filepath, convertEol) {
    const fileBuffer = await fs_1.promises.readFile(filepath);
    const fileStats = await fs_1.promises.stat(filepath);
    if (fileStats.size > LARGE_FILE_THRESHOLD) {
        globalLogger.logWarn(`CRLF detection skipped for large file: ${filepath}`);
        return fileBuffer;
    }
    const encoding = await detectEncoding(fileBuffer);
    if (!CONVERTIBLE_ENCODINGS.includes(encoding)) {
        return fileBuffer;
    }
    if (!fileBuffer.includes('\r\n')) {
        return fileBuffer;
    }
    if (convertEol) {
        globalLogger.logInfo(`Converting line endings CRLF -> LF for file: ${filepath}`);
        return convertEolInPlace(fileBuffer);
    }
    else {
        globalLogger.logWarn(`CRLF (Windows) line endings detected in file: ${filepath}`);
        globalLogger.deferredLog('Windows-format line endings were detected in some files, but were not converted due to `--noconvert-eol` option.', Logger.Level.WARN);
        return fileBuffer;
    }
}
exports.readFileWithEolConversion = readFileWithEolConversion;
async function detectEncoding(fileBuffer, bytesRead = fileBuffer.length) {
    if (bytesRead === 0) {
        return '';
    }
    const totalBytes = Math.min(bytesRead, DETECT_MAX_BYTES);
    if (bytesRead >= 3 &&
        fileBuffer[0] === 0xef &&
        fileBuffer[1] === 0xbb &&
        fileBuffer[2] === 0xbf) {
        return 'utf-8';
    }
    if (bytesRead >= 4 &&
        fileBuffer[0] === 0x00 &&
        fileBuffer[1] === 0x00 &&
        fileBuffer[2] === 0xfe &&
        fileBuffer[3] === 0xff) {
        return 'utf-32';
    }
    if (bytesRead >= 4 &&
        fileBuffer[0] === 0xff &&
        fileBuffer[1] === 0xfe &&
        fileBuffer[2] === 0x00 &&
        fileBuffer[3] === 0x00) {
        return 'utf-32';
    }
    if (bytesRead >= 4 &&
        fileBuffer[0] === 0x84 &&
        fileBuffer[1] === 0x31 &&
        fileBuffer[2] === 0x95 &&
        fileBuffer[3] === 0x33) {
        return 'gb-18030';
    }
    if (totalBytes >= 5 && fileBuffer.slice(0, 5).toString() === '%PDF-') {
        return 'pdf';
    }
    if (bytesRead >= 2 && fileBuffer[0] === 0xfe && fileBuffer[1] === 0xff) {
        return 'utf-16';
    }
    if (bytesRead >= 2 && fileBuffer[0] === 0xff && fileBuffer[1] === 0xfe) {
        return 'utf-16';
    }
    for (let i = 0; i < totalBytes; i++) {
        let c = fileBuffer[i];
        if (c === 0) {
            return 'binary';
        }
        else if (c === 27) {
            continue;
        }
        else if ((c < 7 || c > 14) && (c < 32 || c > 127)) {
            if (c > 193 && c < 224 && i + 1 < totalBytes) {
                i++;
                c = fileBuffer[i];
                if (c > 127 && c < 192) {
                    continue;
                }
            }
            else if (c > 223 && c < 240 && i + 2 < totalBytes) {
                i++;
                c = fileBuffer[i];
                if (c > 127 &&
                    c < 192 &&
                    fileBuffer[i + 1] > 127 &&
                    fileBuffer[i + 1] < 192) {
                    i++;
                    continue;
                }
            }
            return 'binary';
        }
    }
    return 'utf-8';
}
exports.detectEncoding = detectEncoding;
//# sourceMappingURL=eol-conversion.js.map