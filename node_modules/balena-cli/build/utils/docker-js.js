"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = exports.getDocker = void 0;
const _ = require("lodash");
const errors_1 = require("../errors");
const generateConnectOpts = async function (opts) {
    const { promises: fs } = await Promise.resolve().then(() => require('fs'));
    const connectOpts = {};
    const Modem = await Promise.resolve().then(() => require('docker-modem'));
    const defaultOpts = new Modem();
    const optsOfInterest = [
        'ca',
        'cert',
        'key',
        'host',
        'port',
        'socketPath',
        'protocol',
        'username',
        'sshAuthAgent',
        'timeout',
    ];
    for (const opt of optsOfInterest) {
        connectOpts[opt] = defaultOpts[opt];
    }
    if (opts.docker != null && opts.dockerHost == null) {
        connectOpts.socketPath = opts.docker;
        delete connectOpts.host;
        delete connectOpts.port;
    }
    else if (opts.dockerHost != null && opts.docker == null) {
        connectOpts.host = opts.dockerHost;
        connectOpts.port = opts.dockerPort || 2376;
        delete connectOpts.socketPath;
    }
    else if (opts.docker != null && opts.dockerHost != null) {
        throw new errors_1.ExpectedError("Both a local docker socket and docker host have been provided. Don't know how to continue.");
    }
    if (opts.ca != null || opts.cert != null || opts.key != null) {
        if (!(opts.ca != null && opts.cert != null && opts.key != null)) {
            throw new errors_1.ExpectedError('You must provide a CA, certificate and key in order to use TLS');
        }
        const [ca, cert, key] = await Promise.all([
            fs.readFile(opts.ca, 'utf-8'),
            fs.readFile(opts.cert, 'utf-8'),
            fs.readFile(opts.key, 'utf-8'),
        ]);
        return _.merge(connectOpts, {
            ca,
            cert,
            key,
        });
    }
    return connectOpts;
};
async function getDocker(options) {
    const connectOpts = await generateConnectOpts(options);
    const client = exports.createClient(connectOpts);
    await ensureDockerSeemsAccessible(client);
    return client;
}
exports.getDocker = getDocker;
const getDockerToolbelt = _.once(function () {
    const Docker = require('docker-toolbelt');
    const Bluebird = require('bluebird');
    Bluebird.promisifyAll(Docker.prototype, {
        filter(name) {
            return name === 'run';
        },
        multiArgs: true,
    });
    Bluebird.promisifyAll(Docker.prototype);
    Bluebird.promisifyAll(new Docker({}).getImage().constructor.prototype);
    Bluebird.promisifyAll(new Docker({}).getContainer().constructor.prototype);
    return Docker;
});
exports.createClient = function (opts) {
    const Docker = getDockerToolbelt();
    const docker = new Docker(opts);
    const { modem } = docker;
    if (modem.socketPath && modem.host) {
        if (opts.socketPath) {
            modem.host = undefined;
            modem.port = undefined;
        }
        else if (opts.host) {
            modem.socketPath = undefined;
        }
    }
    return docker;
};
var ensureDockerSeemsAccessible = function (docker) {
    const { exitWithExpectedError } = require('../errors');
    return docker
        .ping()
        .catch((e) => exitWithExpectedError(`Docker seems to be unavailable. Is it installed and running?\n${e}`));
};
//# sourceMappingURL=docker-js.js.map