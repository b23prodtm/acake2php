"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectFromList = exports.getOnlineTargetDeviceUuid = exports.inferOrSelectDevice = exports.awaitDeviceOsUpdate = exports.awaitDevice = exports.selectOrganization = exports.selectApplication = exports.confirm = exports.selectDeviceType = exports.askLoginType = exports.checkLoggedIn = exports.authenticate = void 0;
const _ = require("lodash");
const errors_1 = require("../errors");
const lazy_1 = require("./lazy");
const validation = require("./validation");
const helpers_1 = require("./helpers");
const version_1 = require("./version");
const sdk_1 = require("./sdk");
function authenticate(options) {
    const balena = lazy_1.getBalenaSdk();
    return lazy_1.getCliForm()
        .run([
        {
            message: 'Email:',
            name: 'email',
            type: 'input',
            validate: validation.validateEmail,
        },
        {
            message: 'Password:',
            name: 'password',
            type: 'password',
        },
    ], { override: options })
        .then(balena.auth.login)
        .then(balena.auth.twoFactor.isPassed)
        .then((isTwoFactorAuthPassed) => {
        if (isTwoFactorAuthPassed) {
            return;
        }
        return lazy_1.getCliForm()
            .ask({
            message: 'Two factor auth challenge:',
            name: 'code',
            type: 'input',
        })
            .then(balena.auth.twoFactor.challenge)
            .catch((error) => {
            return balena.auth.logout().then(() => {
                if (error.name === 'BalenaRequestError' &&
                    error.statusCode === 401) {
                    throw new errors_1.ExpectedError('Invalid two factor authentication code');
                }
                throw error;
            });
        });
    });
}
exports.authenticate = authenticate;
async function checkLoggedIn() {
    const balena = lazy_1.getBalenaSdk();
    if (!(await balena.auth.isLoggedIn())) {
        throw new errors_1.NotLoggedInError(lazy_1.stripIndent `
		Login required: use the “balena login” command to log in.
		`);
    }
}
exports.checkLoggedIn = checkLoggedIn;
function askLoginType() {
    return lazy_1.getCliForm().ask({
        message: 'How would you like to login?',
        name: 'loginType',
        type: 'list',
        choices: [
            {
                name: 'Web authorization (recommended)',
                value: 'web',
            },
            {
                name: 'Credentials',
                value: 'credentials',
            },
            {
                name: 'Authentication token',
                value: 'token',
            },
            {
                name: "I don't have a balena account!",
                value: 'register',
            },
        ],
    });
}
exports.askLoginType = askLoginType;
function selectDeviceType() {
    return lazy_1.getBalenaSdk()
        .models.config.getDeviceTypes()
        .then((deviceTypes) => {
        deviceTypes = _.sortBy(deviceTypes, 'name').filter((dt) => dt.state !== 'DISCONTINUED');
        return lazy_1.getCliForm().ask({
            message: 'Device Type',
            type: 'list',
            choices: _.map(deviceTypes, ({ slug: value, name }) => ({
                name,
                value,
            })),
        });
    });
}
exports.selectDeviceType = selectDeviceType;
async function confirm(yesOption, message, yesMessage, exitIfDeclined = false) {
    if (yesOption) {
        if (yesMessage) {
            if (version_1.isV13()) {
                console.error(yesMessage);
            }
            else {
                console.log(yesMessage);
            }
        }
        return;
    }
    const confirmed = await lazy_1.getCliForm().ask({
        message,
        type: 'confirm',
        default: false,
    });
    if (!confirmed) {
        const err = new errors_1.ExpectedError('Aborted');
        if (exitIfDeclined) {
            errors_1.exitWithExpectedError(err);
        }
        throw err;
    }
}
exports.confirm = confirm;
function selectApplication(filter, errorOnEmptySelection = false) {
    const balena = lazy_1.getBalenaSdk();
    return balena.models.application
        .hasAny()
        .then(async (hasAnyApplications) => {
        if (!hasAnyApplications) {
            throw new errors_1.ExpectedError("You don't have any applications");
        }
        const apps = (await balena.models.application.getAll({
            $expand: {
                is_for__device_type: {
                    $select: 'slug',
                },
            },
        }));
        return apps.filter(filter || _.constant(true));
    })
        .then((applications) => {
        if (errorOnEmptySelection && applications.length === 0) {
            throw new errors_1.ExpectedError('No suitable applications found for selection');
        }
        return lazy_1.getCliForm().ask({
            message: 'Select an application',
            type: 'list',
            choices: _.map(applications, (application) => ({
                name: `${application.app_name} (${application.slug}) [${application.is_for__device_type[0].slug}]`,
                value: application,
            })),
        });
    });
}
exports.selectApplication = selectApplication;
async function selectOrganization(organizations) {
    organizations =
        organizations || (await lazy_1.getBalenaSdk().models.organization.getAll());
    return lazy_1.getCliForm().ask({
        message: 'Select an organization',
        type: 'list',
        choices: organizations.map((org) => ({
            name: `${org.name} (${org.handle})`,
            value: org.handle,
        })),
    });
}
exports.selectOrganization = selectOrganization;
async function awaitDevice(uuid) {
    const balena = lazy_1.getBalenaSdk();
    const deviceName = await balena.models.device.getName(uuid);
    const visuals = lazy_1.getVisuals();
    const spinner = new visuals.Spinner(`Waiting for ${deviceName} to come online`);
    const poll = async () => {
        const isOnline = await balena.models.device.isOnline(uuid);
        if (isOnline) {
            spinner.stop();
            console.info(`The device **${deviceName}** is online!`);
            return;
        }
        else {
            spinner.start();
            await helpers_1.delay(3000);
            await poll();
        }
    };
    console.info(`Waiting for ${deviceName} to connect to balena...`);
    await poll();
    return uuid;
}
exports.awaitDevice = awaitDevice;
async function awaitDeviceOsUpdate(uuid, targetOsVersion) {
    const balena = lazy_1.getBalenaSdk();
    const deviceName = await balena.models.device.getName(uuid);
    const visuals = lazy_1.getVisuals();
    const progressBar = new visuals.Progress(`Updating the OS of ${deviceName} to v${targetOsVersion}`);
    progressBar.update({ percentage: 0 });
    const poll = async () => {
        const [osUpdateStatus, { overall_progress: osUpdateProgress },] = await Promise.all([
            balena.models.device.getOsUpdateStatus(uuid),
            balena.models.device.get(uuid, { $select: 'overall_progress' }),
        ]);
        if (osUpdateStatus.status === 'done') {
            console.info(`The device ${deviceName} has been updated to v${targetOsVersion} and will restart shortly!`);
            return;
        }
        if (osUpdateStatus.error) {
            console.error(`Failed to complete Host OS update on device ${deviceName}!`);
            errors_1.exitWithExpectedError(osUpdateStatus.error);
            return;
        }
        if (osUpdateProgress !== null) {
            progressBar.update({ percentage: osUpdateProgress });
        }
        await helpers_1.delay(3000);
        await poll();
    };
    await poll();
    return uuid;
}
exports.awaitDeviceOsUpdate = awaitDeviceOsUpdate;
function inferOrSelectDevice(preferredUuid) {
    const balena = lazy_1.getBalenaSdk();
    return balena.models.device.getAll().then((devices) => {
        const onlineDevices = devices.filter((device) => device.is_online);
        if (_.isEmpty(onlineDevices)) {
            throw new errors_1.ExpectedError("You don't have any devices online");
        }
        const defaultUuid = _(onlineDevices).map('uuid').includes(preferredUuid)
            ? preferredUuid
            : onlineDevices[0].uuid;
        return lazy_1.getCliForm().ask({
            message: 'Select a device',
            type: 'list',
            default: defaultUuid,
            choices: _.map(onlineDevices, (device) => ({
                name: `${device.device_name || 'Untitled'} (${device.uuid.slice(0, 7)})`,
                value: device.uuid,
            })),
        });
    });
}
exports.inferOrSelectDevice = inferOrSelectDevice;
async function getOnlineTargetDeviceUuid(sdk, applicationOrDevice) {
    const logger = (await Promise.resolve().then(() => require('../utils/logger'))).getLogger();
    if (validation.validateUuid(applicationOrDevice)) {
        let device;
        try {
            logger.logDebug(`Trying to fetch device by UUID ${applicationOrDevice} (${typeof applicationOrDevice})`);
            device = await sdk.models.device.get(applicationOrDevice, {
                $select: ['uuid', 'is_online'],
            });
            if (!device.is_online) {
                throw new errors_1.ExpectedError(`Device with UUID ${applicationOrDevice} is offline`);
            }
            return device.uuid;
        }
        catch (err) {
            const { BalenaDeviceNotFound } = await Promise.resolve().then(() => require('balena-errors'));
            if (errors_1.instanceOf(err, BalenaDeviceNotFound)) {
                logger.logDebug(`Device with UUID ${applicationOrDevice} not found`);
            }
            else {
                throw err;
            }
        }
    }
    let app;
    try {
        logger.logDebug(`Trying to fetch application by name/slug/ID: ${applicationOrDevice}`);
        app = await sdk_1.getApplication(sdk, applicationOrDevice);
    }
    catch (err) {
        const { BalenaApplicationNotFound } = await Promise.resolve().then(() => require('balena-errors'));
        if (errors_1.instanceOf(err, BalenaApplicationNotFound)) {
            throw new errors_1.ExpectedError(`Application or Device not found: ${applicationOrDevice}`);
        }
        else {
            throw err;
        }
    }
    const devices = await sdk.models.device.getAllByApplication(app.id, {
        $select: ['device_name', 'uuid'],
        $filter: { is_online: true },
    });
    if (_.isEmpty(devices)) {
        throw new errors_1.ExpectedError(`Application ${app.slug} found, but has no devices online.`);
    }
    return lazy_1.getCliForm().ask({
        message: `Select a device on application ${app.slug}`,
        type: 'list',
        default: devices[0].uuid,
        choices: _.map(devices, (device) => ({
            name: `${device.device_name || 'Untitled'} (${device.uuid.slice(0, 7)})`,
            value: device.uuid,
        })),
    });
}
exports.getOnlineTargetDeviceUuid = getOnlineTargetDeviceUuid;
function selectFromList(message, choices) {
    return lazy_1.getCliForm().ask({
        message,
        type: 'list',
        choices: _.map(choices, (s) => ({
            name: s.name,
            value: s,
        })),
    });
}
exports.selectFromList = selectFromList;
//# sourceMappingURL=patterns.js.map