"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommandIdsFromManifest = exports.getCommandsFromManifest = exports.capitanoizeOclifUsage = exports.CustomMain = exports.CommandHelp = void 0;
const command_1 = require("@oclif/command");
class CommandHelp {
    constructor(command) {
        this.command = command;
    }
    arg(arg) {
        const name = arg.name.toUpperCase();
        if (arg.required) {
            return `${name}`;
        }
        return `[${name}]`;
    }
    defaultUsage() {
        return CommandHelp.compact([
            (this.command.args || [])
                .filter((a) => !a.hidden)
                .map((a) => this.arg(a))
                .join(' '),
        ]).join(' ');
    }
    static compact(array) {
        return array.filter((a) => !!a);
    }
}
exports.CommandHelp = CommandHelp;
class CustomMain extends command_1.Main {
    _helpOverride() {
        if (['-v', '--version', 'version'].includes(this.argv[0])) {
            return false;
        }
        else {
            return super._helpOverride();
        }
    }
}
exports.CustomMain = CustomMain;
function capitanoizeOclifUsage(oclifUsage) {
    return (oclifUsage || '')
        .toString()
        .replace(/(?<=\s)[A-Z]+(?=(\s|$))/g, (match) => `<${match}>`)
        .toLowerCase();
}
exports.capitanoizeOclifUsage = capitanoizeOclifUsage;
async function getCommandsFromManifest() {
    const manifest = require('../../oclif.manifest.json');
    if (manifest.commands == null) {
        throw new Error('Commands section not found in manifest.');
    }
    return manifest.commands;
}
exports.getCommandsFromManifest = getCommandsFromManifest;
async function getCommandIdsFromManifest() {
    const commands = await getCommandsFromManifest();
    return Object.keys(commands);
}
exports.getCommandIdsFromManifest = getCommandIdsFromManifest;
//# sourceMappingURL=oclif-utils.js.map