import * as chokidar from 'chokidar';
import type * as Dockerode from 'dockerode';
import type { Composition } from 'resin-compose-parse';
import type { BuildTask } from 'resin-multibuild';
import Logger = require('../logger');
import type DeviceAPI from './api';
import { DeviceDeployOptions } from './deploy';
declare type BuildLogs = Dictionary<string>;
export interface LivepushOpts {
    buildContext: string;
    composition: Composition;
    buildTasks: BuildTask[];
    docker: Dockerode;
    api: DeviceAPI;
    logger: Logger;
    buildLogs: BuildLogs;
    deployOpts: DeviceDeployOptions;
}
export declare class LivepushManager {
    private lastDeviceStatus;
    private containers;
    private dockerfilePaths;
    private deviceInfo;
    private deployOpts;
    private buildContext;
    private composition;
    private buildTasks;
    private docker;
    private api;
    private logger;
    private imageIds;
    private updateEventsWaiting;
    private deleteEventsWaiting;
    private rebuildsRunning;
    private rebuildRunningIds;
    private rebuildsCancelled;
    constructor(opts: LivepushOpts);
    init(): Promise<void>;
    cleanup(): Promise<void>;
    protected setupFilesystemWatcher(serviceName: string, rootContext: string, serviceContext: string, changedPathHandler: (serviceName: string, changedPath: string) => void, dockerignoreByService: {
        [serviceName: string]: import('@balena/dockerignore').Ignore;
    }, multiDockerignore: boolean): chokidar.FSWatcher;
    close(): void;
    static preprocessDockerfile(content: string): string;
    private static getMultistageImageIDs;
    private awaitDeviceStateSettle;
    private handleFSEvents;
    private handleServiceRebuild;
    private cancelRebuild;
    private assignLivepushOutputHandlers;
    private static extractDockerArrowMessage;
    private getDockerfilePathFromTask;
    private getDebouncedEventHandler;
}
export default LivepushManager;
