"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.performLocalDeviceSSH = exports.deviceContainerEngineBinary = void 0;
const lazy_1 = require("../lazy");
exports.deviceContainerEngineBinary = `$(if [ -f /usr/bin/balena ]; then echo "balena"; else echo "docker"; fi)`;
async function performLocalDeviceSSH(opts) {
    const { escapeRegExp, reduce } = await Promise.resolve().then(() => require('lodash'));
    const { spawnSshAndThrowOnError } = await Promise.resolve().then(() => require('../ssh'));
    const { ExpectedError } = await Promise.resolve().then(() => require('../../errors'));
    let command = '';
    if (opts.service != null) {
        const Docker = await Promise.resolve().then(() => require('dockerode'));
        const docker = new Docker({
            host: opts.address,
            port: 2375,
        });
        const regex = new RegExp(`(^|\\/)${escapeRegExp(opts.service)}_\\d+_\\d+`);
        const nameRegex = /\/?([a-zA-Z0-9_]+)_\d+_\d+/;
        let allContainers;
        try {
            allContainers = await docker.listContainers();
        }
        catch (_e) {
            throw new ExpectedError(lazy_1.stripIndent `
				Could not access docker daemon on device ${opts.address}.
				Please ensure the device is in local mode.`);
        }
        const serviceNames = [];
        const containers = [];
        for (const container of allContainers) {
            for (const name of container.Names) {
                if (regex.test(name)) {
                    containers.push({ id: container.Id, name });
                    break;
                }
                const match = name.match(nameRegex);
                if (match) {
                    serviceNames.push(match[1]);
                }
            }
        }
        if (containers.length === 0) {
            throw new ExpectedError(`Could not find a service on device with name ${opts.service}. ${serviceNames.length > 0
                ? `Available services:\n${reduce(serviceNames, (str, name) => `${str}\t${name}\n`, '')}`
                : ''}`);
        }
        if (containers.length > 1) {
            throw new ExpectedError(lazy_1.stripIndent `
				Found more than one container matching service name "${opts.service}":
				${containers.map((container) => container.name).join(', ')}
				Use different service names to avoid ambiguity.
			`);
        }
        const containerId = containers[0].id;
        const shellCmd = `/bin/sh -c "if [ -e /bin/bash ]; then exec /bin/bash; else exec /bin/sh; fi"`;
        const isTTY = !!opts.forceTTY || (await Promise.resolve().then(() => require('tty'))).isatty(0);
        const ttyFlag = isTTY ? '-t' : '';
        command = `${exports.deviceContainerEngineBinary} exec -i ${ttyFlag} ${containerId} ${shellCmd}`;
    }
    return spawnSshAndThrowOnError([
        ...(opts.verbose ? ['-vvv'] : []),
        '-t',
        ...['-p', opts.port ? opts.port.toString() : '22222'],
        ...['-o', 'LogLevel=ERROR'],
        ...['-o', 'StrictHostKeyChecking=no'],
        ...['-o', 'UserKnownHostsFile=/dev/null'],
        `root@${opts.address}`,
        ...(command ? [command] : []),
    ]);
}
exports.performLocalDeviceSSH = performLocalDeviceSSH;
//# sourceMappingURL=ssh.js.map