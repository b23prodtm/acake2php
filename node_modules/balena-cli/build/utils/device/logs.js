"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServiceColourFn = exports.displayLogObject = exports.displayBuildLog = exports.connectAndDisplayDeviceLogs = void 0;
const ColorHash = require("color-hash");
const _ = require("lodash");
const lazy_1 = require("../lazy");
const errors_1 = require("../../errors");
class DeviceConnectionLostError extends errors_1.ExpectedError {
    constructor(msg) {
        super(msg || DeviceConnectionLostError.defaultMsg);
    }
}
DeviceConnectionLostError.defaultMsg = 'Connection to device lost';
async function displayDeviceLogs(logs, logger, system, filterServices) {
    const { addSIGINTHandler } = await Promise.resolve().then(() => require('../helpers'));
    let gotSignal = false;
    const handleSignal = () => {
        gotSignal = true;
        logs.emit('close');
    };
    addSIGINTHandler(handleSignal);
    process.once('SIGTERM', handleSignal);
    try {
        await new Promise((_resolve, reject) => {
            logs.on('data', (log) => {
                displayLogLine(log, logger, system, filterServices);
            });
            logs.once('error', reject);
            logs.once('end', () => {
                logger.logWarn(DeviceConnectionLostError.defaultMsg);
                if (gotSignal) {
                    reject(new errors_1.SIGINTError('Log streaming aborted on SIGINT signal'));
                }
                else {
                    reject(new DeviceConnectionLostError());
                }
            });
        });
    }
    finally {
        process.removeListener('SIGINT', handleSignal);
        process.removeListener('SIGTERM', handleSignal);
    }
}
async function connectAndDisplayDeviceLogs({ deviceApi, logger, system, filterServices, maxAttempts = 3, }) {
    async function connectAndDisplay() {
        const logStream = await deviceApi.getLogStream();
        return displayDeviceLogs(logStream, logger, system, filterServices);
    }
    const { retry } = await Promise.resolve().then(() => require('../../utils/helpers'));
    try {
        await retry({
            func: connectAndDisplay,
            maxAttempts,
            label: 'Streaming logs',
        });
    }
    catch (err) {
        if (err instanceof DeviceConnectionLostError) {
            err.message = `Max retry count (${maxAttempts - 1}) exceeded while attempting to reconnect to the device`;
        }
        throw err;
    }
}
exports.connectAndDisplayDeviceLogs = connectAndDisplayDeviceLogs;
function displayBuildLog(log, logger) {
    const toPrint = `${exports.getServiceColourFn(log.serviceName)(`[${log.serviceName}]`)} ${log.message}`;
    logger.logBuild(toPrint);
}
exports.displayBuildLog = displayBuildLog;
function displayLogLine(log, logger, system, filterServices) {
    try {
        const obj = JSON.parse(log.toString());
        displayLogObject(obj, logger, system, filterServices);
    }
    catch (e) {
        logger.logDebug(`Dropping device log due to failed parsing: ${e}`);
    }
}
function displayLogObject(obj, logger, system, filterServices) {
    let toPrint;
    if (obj.timestamp != null) {
        toPrint = `[${new Date(obj.timestamp).toLocaleString()}]`;
    }
    else {
        toPrint = `[${new Date().toLocaleString()}]`;
    }
    if (obj.serviceName != null) {
        if (filterServices) {
            if (!_.includes(filterServices, obj.serviceName)) {
                return;
            }
        }
        else if (system) {
            return;
        }
        const colourFn = exports.getServiceColourFn(obj.serviceName);
        toPrint += ` ${colourFn(`[${obj.serviceName}]`)}`;
    }
    else if (filterServices != null && !system) {
        return;
    }
    toPrint += ` ${obj.message}`;
    logger.logLogs(toPrint);
}
exports.displayLogObject = displayLogObject;
exports.getServiceColourFn = _.memoize(_getServiceColourFn);
const colorHash = new ColorHash();
function _getServiceColourFn(serviceName) {
    const [r, g, b] = colorHash.rgb(serviceName);
    return lazy_1.getChalk().rgb(r, g, b);
}
//# sourceMappingURL=logs.js.map