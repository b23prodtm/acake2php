"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBalenaEngine = exports.generateBuildOpts = exports.dockerCliFlags = exports.dockerConnectionCliFlags = void 0;
const command_1 = require("@oclif/command");
const errors_1 = require("../errors");
const validation_1 = require("./validation");
__exportStar(require("./docker-js"), exports);
exports.dockerConnectionCliFlags = {
    docker: command_1.flags.string({
        description: 'Path to a local docker socket (e.g. /var/run/docker.sock)',
        char: 'P',
    }),
    dockerHost: command_1.flags.string({
        description: 'Docker daemon hostname or IP address (dev machine or balena device) ',
        char: 'h',
    }),
    dockerPort: command_1.flags.integer({
        description: 'Docker daemon TCP port number (hint: 2375 for balena devices)',
        char: 'p',
        parse: (p) => validation_1.parseAsInteger(p, 'dockerPort'),
    }),
    ca: command_1.flags.string({
        description: 'Docker host TLS certificate authority file',
    }),
    cert: command_1.flags.string({
        description: 'Docker host TLS certificate file',
    }),
    key: command_1.flags.string({
        description: 'Docker host TLS key file',
    }),
};
exports.dockerCliFlags = {
    tag: command_1.flags.string({
        description: 'The alias to the generated image',
        char: 't',
    }),
    buildArg: command_1.flags.string({
        description: 'Set a build-time variable (eg. "-B \'ARG=value\'"). Can be specified multiple times.',
        char: 'B',
        multiple: true,
    }),
    'cache-from': command_1.flags.string({
        description: `\
Comma-separated list (no spaces) of image names for build cache resolution. \
Implements the same feature as the "docker build --cache-from" option.`,
    }),
    nocache: command_1.flags.boolean({
        description: "Don't use docker layer caching when building",
    }),
    pull: command_1.flags.boolean({
        description: 'Pull the base images again even if they exist locally',
    }),
    squash: command_1.flags.boolean({
        description: 'Squash newly built layers into a single new layer',
    }),
    ...exports.dockerConnectionCliFlags,
};
function parseBuildArgs(args) {
    if (!Array.isArray(args)) {
        args = [args];
    }
    const buildArgs = {};
    args.forEach(function (arg) {
        var _a;
        const pair = /^([^\s]+?)=([^]*)$/.exec(arg);
        if (pair != null) {
            buildArgs[pair[1]] = (_a = pair[2]) !== null && _a !== void 0 ? _a : '';
        }
        else {
            throw new errors_1.ExpectedError(`Could not parse build argument: '${arg}'`);
        }
    });
    return buildArgs;
}
function generateBuildOpts(options) {
    var _a;
    const opts = {};
    if (options.buildArg != null) {
        opts.buildargs = parseBuildArgs(options.buildArg);
    }
    if ((_a = options['cache-from']) === null || _a === void 0 ? void 0 : _a.trim()) {
        opts.cachefrom = options['cache-from'].split(',').filter((i) => !!i.trim());
    }
    if (options.nocache != null) {
        opts.nocache = true;
    }
    if (options.pull != null) {
        opts.pull = true;
    }
    if (options['registry-secrets'] &&
        Object.keys(options['registry-secrets']).length) {
        opts.registryconfig = options['registry-secrets'];
    }
    if (options.squash != null) {
        opts.squash = true;
    }
    if (options.tag != null) {
        opts.t = options.tag;
    }
    return opts;
}
exports.generateBuildOpts = generateBuildOpts;
async function isBalenaEngine(docker) {
    const dockerVersion = (await docker.version());
    return !!(dockerVersion.Engine && dockerVersion.Engine.match(/balena|balaena/));
}
exports.isBalenaEngine = isBalenaEngine;
//# sourceMappingURL=docker.js.map