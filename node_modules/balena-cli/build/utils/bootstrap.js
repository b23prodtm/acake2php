"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgExec = exports.normalizeEnvVars = exports.normalizeEnvVar = exports.parseBoolEnvVar = exports.CliSettings = void 0;
class CliSettings {
    constructor() {
        this.settings = require('balena-settings-client');
    }
    get(name) {
        return this.settings.get(name);
    }
    getCatch(name) {
        try {
            return this.settings.get(name);
        }
        catch (err) {
            if (!/Setting not found/i.test(err.message)) {
                throw err;
            }
        }
    }
}
exports.CliSettings = CliSettings;
function parseBoolEnvVar(varName) {
    var _a;
    return !['0', 'no', 'false', '', undefined].includes((_a = process.env[varName]) === null || _a === void 0 ? void 0 : _a.toLowerCase());
}
exports.parseBoolEnvVar = parseBoolEnvVar;
function normalizeEnvVar(varName) {
    process.env[varName] = parseBoolEnvVar(varName) ? '1' : '';
}
exports.normalizeEnvVar = normalizeEnvVar;
const bootstrapVars = ['DEBUG', 'BALENARC_NO_SENTRY'];
function normalizeEnvVars(varNames = bootstrapVars) {
    for (const varName of varNames) {
        normalizeEnvVar(varName);
    }
}
exports.normalizeEnvVars = normalizeEnvVars;
async function pkgExec(modFunc, args) {
    const [modPath, funcName] = modFunc.split('::');
    let replacedModPath = modPath;
    const match = modPath
        .replace(/\\/g, '/')
        .match(/\/snapshot\/balena-cli\/(.+)/);
    if (match) {
        replacedModPath = `../${match[1]}`;
    }
    process.argv = [process.argv[0], process.argv[1], ...args];
    try {
        const mod = await Promise.resolve().then(() => require(replacedModPath));
        if (funcName) {
            await mod[funcName](...args);
        }
    }
    catch (err) {
        console.error(`Error executing pkgExec "${modFunc}" [${args.join()}]`);
        console.error(err);
    }
}
exports.pkgExec = pkgExec;
//# sourceMappingURL=bootstrap.js.map