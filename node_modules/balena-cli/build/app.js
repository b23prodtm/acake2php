"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.setMaxListeners = exports.setupSentry = void 0;
const packageJSON = require("../package.json");
const bootstrap_1 = require("./utils/bootstrap");
const lazy_1 = require("./utils/lazy");
exports.setupSentry = lazy_1.onceAsync(async () => {
    const config = await Promise.resolve().then(() => require('./config'));
    const Sentry = await Promise.resolve().then(() => require('@sentry/node'));
    Sentry.init({
        dsn: config.sentryDsn,
        release: packageJSON.version,
    });
    Sentry.configureScope((scope) => {
        scope.setExtras({
            is_pkg: !!process.pkg,
            node_version: process.version,
            platform: process.platform,
        });
    });
    return Sentry.getCurrentHub();
});
async function checkNodeVersion() {
    const validNodeVersions = packageJSON.engines.node;
    if (!(await Promise.resolve().then(() => require('semver'))).satisfies(process.version, validNodeVersions)) {
        console.warn(lazy_1.stripIndent `
			------------------------------------------------------------------------------
			Warning: Node version "${process.version}" does not match required versions "${validNodeVersions}".
			This may cause unexpected behavior. To upgrade Node, visit:
			https://nodejs.org/en/download/
			------------------------------------------------------------------------------
			`);
    }
}
function setupBalenaSdkSharedOptions(settings) {
    const BalenaSdk = require('balena-sdk');
    BalenaSdk.setSharedOptions({
        apiUrl: settings.get('apiUrl'),
        dataDirectory: settings.get('dataDirectory'),
    });
}
function setMaxListeners(maxListeners) {
    require('events').EventEmitter.defaultMaxListeners = maxListeners;
}
exports.setMaxListeners = setMaxListeners;
async function init() {
    if (process.env.BALENARC_NO_SENTRY) {
        console.error(`WARN: disabling Sentry.io error reporting`);
    }
    else {
        await exports.setupSentry();
    }
    checkNodeVersion();
    const settings = new bootstrap_1.CliSettings();
    await (await Promise.resolve().then(() => require('./utils/proxy'))).setupGlobalHttpProxy(settings);
    setupBalenaSdkSharedOptions(settings);
    (await Promise.resolve().then(() => require('./utils/update'))).notify();
}
async function oclifRun(command, options) {
    const { CustomMain } = await Promise.resolve().then(() => require('./utils/oclif-utils'));
    const runPromise = CustomMain.run(command).then(() => {
        if (!options.noFlush) {
            return require('@oclif/command/flush');
        }
    }, (error) => {
        var _a;
        if (((_a = error.oclif) === null || _a === void 0 ? void 0 : _a.exit) === 0) {
            return;
        }
        else {
            throw error;
        }
    });
    const { trackPromise } = await Promise.resolve().then(() => require('./hooks/prerun/track'));
    await Promise.all([trackPromise, runPromise]);
}
async function run(cliArgs = process.argv, options = {}) {
    try {
        const { normalizeEnvVars, pkgExec } = await Promise.resolve().then(() => require('./utils/bootstrap'));
        normalizeEnvVars();
        if (cliArgs.length > 3 && cliArgs[2] === 'pkgExec') {
            return pkgExec(cliArgs[3], cliArgs.slice(4));
        }
        await init();
        const { preparseArgs, checkDeletedCommand } = await Promise.resolve().then(() => require('./preparser'));
        checkDeletedCommand(cliArgs.slice(2));
        const args = await preparseArgs(cliArgs);
        await oclifRun(args, options);
    }
    catch (err) {
        await (await Promise.resolve().then(() => require('./errors'))).handleError(err);
    }
    finally {
        process.stdin.pause();
    }
}
exports.run = run;
//# sourceMappingURL=app.js.map